## ✨ What is Java?

**Java** is a:

* **High-level** programming language (close to human language)
* **Object-Oriented** (everything is based on classes and objects)
* **Platform-independent** (runs on any OS via JVM)
* Developed by **James Gosling** at **Sun Microsystems** in **1995**
* Now maintained by **Oracle Corporation**

---

## 🚀 Java Philosophy

### ✅ "Write Once, Run Anywhere" (WORA)

Java code is compiled into **bytecode**, not machine code. This bytecode runs on any system with a **Java Virtual Machine (JVM)**.

📦 You don’t need to rewrite or recompile code for Windows, Mac, or Linux.

---

## 🛡 Key Features of Java

| Feature                  | Description                                                                 |
| ------------------------ | --------------------------------------------------------------------------- |
| **Simple**               | Syntax similar to C/C++, but removes complexity like pointers.              |
| **Object-Oriented**      | Code is organized into objects and classes, making it modular and reusable. |
| **Platform-Independent** | Bytecode (.class file) runs on JVM, not on the OS directly.                 |
| **Secure**               | No direct memory access (no pointers), runs in a secure sandbox.            |
| **Robust**               | Strong memory management, garbage collection, exception handling.           |
| **Portable**             | Same code can run anywhere with JVM.                                        |
| **Multithreaded**        | Supports multithreading (run multiple tasks concurrently).                  |
| **Architecture Neutral** | Doesn't rely on platform-specific features.                                 |
| **Dynamic**              | Can load classes dynamically at runtime.                                    |

---

## ⚙️ How Java Works – High-Level View

### 🔁 Code Execution Flow

```plaintext
YourCode.java
   ↓
javac (Compiler)
   ↓
YourCode.class (Bytecode)
   ↓
java (JVM executes the bytecode)
   ↓
Output on screen
```

📘 **Bytecode**: A special intermediate form of code that the JVM understands.
🔁 **JVM**: Executes the bytecode, handling memory, security, threading, etc.

---

## 🧠 Real-World Analogy

Imagine Java as:

* **A writer** (you) writing in English (Java)
* **A translator** (compiler) converting it into a neutral form (bytecode)
* **An interpreter** (JVM) translating it into different spoken languages (machine code) based on country (OS)

So your "Java letter" can be understood in **any country** without rewriting it!

---

## 📝 Interview Questions

1. What does "Write Once, Run Anywhere" mean in Java?
2. How is Java platform-independent?
3. Why is Java considered secure?
4. What are the main features that make Java robust?
5. How is Java different from C++?

---

## 💡 Quick Facts

* Java is **not** the same as JavaScript.
* Java programs are always compiled first to `.class` (bytecode).
* Java is used in **web apps**, **desktop apps**, **mobile apps (Android)**, **IoT devices**, and **enterprise software**.

---

## 🔚 Summary

Java is:

* Simple
* Powerful
* Secure
* Portable
* Developer-friendly

Its ability to run the same code on **any platform** without changes makes it one of the most **widely used programming languages** in the world.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# ⚙️ **2. Java Architecture – Deep Explanation with Diagram & Example**



## 🔁 **Java Compilation & Execution Pipeline**

### 📌 Main Flow:

```
Source Code (.java)
    ↓
Java Compiler (javac)
    ↓
Bytecode (.class)
    ↓
Java Virtual Machine (JVM)
    ↓
Machine Code (OS-specific)
    ↓
Output
```

---

## 🔍 **Component-Wise Breakdown**

---

### 🧩 **1. Source Code**

> This is the code you write using the Java programming language.

📝 Example:

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}
```

📁 File saved as: `Hello.java`

---

### 🧩 **2. Java Compiler (`javac`)**

> Compiles `.java` file into `.class` file (Bytecode)

✅ Converts human-readable Java code into an intermediate form called **Bytecode** — a `.class` file.

```bash
javac Hello.java  // Outputs Hello.class
```

**Why Bytecode?**

* Platform-independent
* Designed for JVM to interpret/run

---

### 🧩 **3. Bytecode (`.class` file)**

> Intermediate representation of code, readable only by the JVM

🧠 Bytecode is:

* Compact
* Secure
* Not tied to any OS/processor

📝 Example content (just for understanding, not real syntax):

```
0: getstatic #2
3: ldc #3
6: invokevirtual #4
```

---

### 🧩 **4. JVM (Java Virtual Machine)**

> Executes `.class` files on the host machine

The **JVM** is the backbone of the **Java platform's independence**, responsible for:

* Loading classes
* Verifying bytecode
* Memory management
* Executing code

---

## 🧠 **Internal JVM Architecture – Visual Diagram**

```
┌────────────────────────────────────────────┐
│               Java Virtual Machine         │
├────────────────────────────────────────────┤
│  1. Class Loader                           │
│     • Loads .class files into memory       │
│     • Maintains class namespace            │
│                                            │
│  2. Bytecode Verifier                      │
│     • Verifies access rules, stack usage   │
│     • Protects from malicious bytecode     │
│                                            │
│  3. Runtime Data Areas                     │
│     ┌────────────────────────────────────┐ │
│     │ • Heap (for objects)               │ │
│     │ • Stack (for method calls)         │ │
│     │ • Method Area (class info/static)  │ │
│     │ • PC Register (next instruction)   │ │
│     │ • Native Method Stack              │ │
│     └────────────────────────────────────┘ │
│                                            │
│  4. Execution Engine                       │
│     • Interpreter (executes bytecode line) │
│     • JIT Compiler (hotspot optimization)  │
│                                            │
│  5. Native Interface (JNI)                 │
│     • Calls native C/C++ libraries         │
└────────────────────────────────────────────┘
```

---

## 🧩 **5. Machine Code**

> Native OS/CPU-specific code generated by the JVM's **JIT compiler**

🧠 JIT = Just-In-Time compiler:

* Identifies frequently used code blocks ("hot spots")
* Converts them into native code to improve performance

---

## 📘 **Full Code Example**

```java
// File: HelloArchitecture.java
public class HelloArchitecture {
    public static void main(String[] args) {
        System.out.println("JVM architecture is powerful!");
    }
}
```

### 🔧 Execution:

```bash
javac HelloArchitecture.java     // Compiles to HelloArchitecture.class
java HelloArchitecture           // JVM loads and executes
```

🖥 Output:

```
JVM architecture is powerful!
```

---

## 🧠 **Real-World Analogy**

| Component    | Real-World Example                                |
| ------------ | ------------------------------------------------- |
| Source Code  | Recipe in English                                 |
| Compiler     | Translator (English → Symbols)                    |
| Bytecode     | Universal symbols everyone understands            |
| JVM          | Chef who can read and cook based on those symbols |
| Machine Code | Local dish ready for your region                  |

---

## 📋 **Interview Questions from this Section**

1. What is the role of the JVM?
2. Explain the difference between JDK, JRE, and JVM.
3. Why is Java platform-independent but JVM is not?
4. What is bytecode and who interprets it?
5. How does JIT improve performance?

---

## 🧠 **Quick Summary Table**

| Component | Full Form                    | Purpose                                   |
| --------- | ---------------------------- | ----------------------------------------- |
| JDK       | Java Development Kit         | Develop and run Java programs             |
| JRE       | Java Runtime Environment     | Run compiled Java programs (includes JVM) |
| JVM       | Java Virtual Machine         | Run `.class` files and manage memory      |
| Bytecode  | Intermediate compiled format | Ensures cross-platform execution          |
| JIT       | Just-In-Time Compiler        | Optimizes performance during runtime      |

---

✅ If you’re ready, we can now proceed with:

> **📌 Part 3: Data Types & Variables**
> Includes:

* All 8 primitive types
* Non-primitive types (String, arrays, objects)
* Stack vs Heap memory behavior
* Memory diagrams + examples




---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# 🔤 **3. Data Types & Variables – Deep Explanation with Examples**

---

## ✨ What is a Data Type?

A **data type** defines:

* The **type of data** a variable can hold (like numbers, text, etc.)
* How much **memory** it takes
* What **operations** can be performed on it

---

## 🧩 Java Data Types: Two Categories

| Type              | Description                   | Examples                     |
| ----------------- | ----------------------------- | ---------------------------- |
| **Primitive**     | Basic built-in types          | `int`, `float`, `char`, etc. |
| **Non-Primitive** | Objects and class-based types | `String`, `Array`, etc.      |

---

## ✅ **Primitive Data Types (8 total)**

Java provides **8 primitive types** for storing simple values.

| Type      | Size    | Example             | Range              |
| --------- | ------- | ------------------- | ------------------ |
| `byte`    | 1 byte  | `byte b = 100;`     | -128 to 127        |
| `short`   | 2 bytes | `short s = 500;`    | -32,768 to 32,767  |
| `int`     | 4 bytes | `int a = 1000;`     | -2^31 to 2^31-1    |
| `long`    | 8 bytes | `long l = 90000L;`  | -2^63 to 2^63-1    |
| `float`   | 4 bytes | `float f = 5.6f;`   | 6–7 decimal digits |
| `double`  | 8 bytes | `double d = 9.99;`  | 15 decimal digits  |
| `char`    | 2 bytes | `char c = 'A';`     | Unicode characters |
| `boolean` | 1 bit   | `boolean b = true;` | true / false       |

---

### 🧪 Primitive Example:

```java
public class PrimitiveExample {
    public static void main(String[] args) {
        byte b = 127;
        int age = 25;
        float temp = 36.6f;
        char grade = 'A';
        boolean passed = true;

        System.out.println("Byte: " + b);
        System.out.println("Age: " + age);
        System.out.println("Temperature: " + temp);
        System.out.println("Grade: " + grade);
        System.out.println("Passed: " + passed);
    }
}
```

### ✅ Output:

```
Byte: 127
Age: 25
Temperature: 36.6
Grade: A
Passed: true
```

---

## ✅ **Non-Primitive (Reference) Data Types**

Non-primitive data types are created using **classes and objects**.

| Type        | Description                             | Example                   |
| ----------- | --------------------------------------- | ------------------------- |
| `String`    | Sequence of characters (object)         | `String name = "Aswini";` |
| `Array`     | Collection of same-type data            | `int[] arr = {1, 2, 3};`  |
| `Class`     | Custom blueprint to create objects      | `class Car {}`            |
| `Object`    | Instance of a class                     | `Car c = new Car();`      |
| `Interface` | Abstract type for contract-based design | `interface Drawable {}`   |

---

### 🧪 Non-Primitive Example:

```java
public class NonPrimitiveExample {
    public static void main(String[] args) {
        String name = "Java";
        int[] numbers = {10, 20, 30};
        
        System.out.println("Name: " + name);
        System.out.println("First Number: " + numbers[0]);
    }
}
```

### ✅ Output:

```
Name: Java
First Number: 10
```

---

## 📚 Key Differences: Primitive vs Non-Primitive

| Feature           | Primitive                  | Non-Primitive              |
| ----------------- | -------------------------- | -------------------------- |
| Memory Size       | Fixed                      | Varies (depends on object) |
| Null Allowed      | ❌ No                       | ✅ Yes                      |
| Methods Available | ❌ No (except with wrapper) | ✅ Yes                      |
| Stored in         | Stack                      | Heap (object)              |

---

## 🧠 Memory Behavior (Stack vs Heap)

* **Primitive types** are stored directly in **stack memory**
* **Objects & non-primitive** values are stored in **heap**, and accessed via **references in the stack**

---

## 💡 Wrapper Classes (for Primitives as Objects)

| Primitive | Wrapper     |
| --------- | ----------- |
| `int`     | `Integer`   |
| `char`    | `Character` |
| `float`   | `Float`     |
| `boolean` | `Boolean`   |

📝 Example:

```java
Integer a = 100; // Object version of int
```

---

## 📋 Interview Questions

1. What are the 8 primitive data types in Java?
2. Difference between `int` and `Integer`?
3. How is memory managed for primitive vs non-primitive types?
4. Is `String` primitive or object in Java?
5. What is autoboxing and unboxing?

---

## 🧠 Summary

* Java supports **8 built-in primitive types** for simple values.
* Everything else (like `String`, `Array`, `Object`) is **non-primitive** and managed via **references**.
* Primitives are lightweight and faster; objects are powerful and flexible.

---


Certainly! Here's the **complete and clean Java code** for both **primitive** and **non-primitive** data types from **Part 3: Data Types & Variables** — ready to compile and run.

---

## ✅ **1. Primitive Data Types – Full Code**

```java
// File: PrimitiveExample.java

public class PrimitiveExample {
    public static void main(String[] args) {
        byte b = 127;
        short s = 30000;
        int age = 25;
        long population = 7900000000L;

        float temp = 36.6f;
        double pi = 3.1415926535;

        char grade = 'A';
        boolean passed = true;

        System.out.println("Byte Value: " + b);
        System.out.println("Short Value: " + s);
        System.out.println("Int (Age): " + age);
        System.out.println("Long (Population): " + population);

        System.out.println("Float (Temperature): " + temp);
        System.out.println("Double (PI): " + pi);

        System.out.println("Char (Grade): " + grade);
        System.out.println("Boolean (Passed): " + passed);
    }
}
```

---

## ✅ **2. Non-Primitive Data Types – Full Code**

```java
// File: NonPrimitiveExample.java

public class NonPrimitiveExample {
    public static void main(String[] args) {
        // String
        String name = "Java Learner";
        
        // Array
        int[] numbers = {10, 20, 30, 40};

        // Custom class object
        Car myCar = new Car("Red", 2023);

        System.out.println("String Name: " + name);
        System.out.println("Array First Number: " + numbers[0]);
        System.out.println("Car Color: " + myCar.color);
        System.out.println("Car Year: " + myCar.year);
    }
}

// Custom class
class Car {
    String color;
    int year;

    Car(String c, int y) {
        color = c;
        year = y;
    }
}
```

---

### ✅ How to Run These:

1. Save each file (`PrimitiveExample.java` and `NonPrimitiveExample.java`)
2. Compile:

   ```bash
   javac PrimitiveExample.java
   javac NonPrimitiveExample.java
   ```
3. Run:

   ```bash
   java PrimitiveExample
   java NonPrimitiveExample
   ```

---



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# ➕ **4. Java Operators –**

---

## ✅ What is an Operator?

An **operator** in Java is a symbol used to **perform operations** on variables and values — like arithmetic, comparisons, logic, assignments, and even bit manipulation.

---

## 📚 Java Operator Categories

| Category   | Description                 |
| ---------- | --------------------------- |
| Arithmetic | Math operations             |
| Relational | Comparison operations       |
| Logical    | Boolean expressions         |
| Bitwise    | Binary/bit-level operations |
| Assignment | Assign or modify values     |
| Unary      | Operate on single operand   |
| Ternary    | `?:` operator               |

---

## 🔢 1. **Arithmetic Operators**

| Operator | Meaning             | Example  | Result |
| -------- | ------------------- | -------- | ------ |
| `+`      | Addition            | `10 + 5` | 15     |
| `-`      | Subtraction         | `10 - 3` | 7      |
| `*`      | Multiplication      | `4 * 3`  | 12     |
| `/`      | Division            | `10 / 2` | 5      |
| `%`      | Modulus (remainder) | `10 % 3` | 1      |

### 🔹 Example:

```java
public class ArithmeticDemo {
    public static void main(String[] args) {
        int a = 10, b = 3;
        System.out.println("Add: " + (a + b));
        System.out.println("Sub: " + (a - b));
        System.out.println("Mul: " + (a * b));
        System.out.println("Div: " + (a / b));
        System.out.println("Mod: " + (a % b));
    }
}
```

---

## 🔍 2. **Relational (Comparison) Operators**

| Operator | Meaning          | Example  | Result |
| -------- | ---------------- | -------- | ------ |
| `==`     | Equal to         | `a == b` | false  |
| `!=`     | Not equal to     | `a != b` | true   |
| `>`      | Greater than     | `a > b`  | true   |
| `<`      | Less than        | `a < b`  | false  |
| `>=`     | Greater or equal | `a >= b` | true   |
| `<=`     | Less or equal    | `a <= b` | false  |

### 🔹 Example:

```java
public class RelationalDemo {
    public static void main(String[] args) {
        int a = 10, b = 20;
        System.out.println("a == b: " + (a == b));
        System.out.println("a != b: " + (a != b));
        System.out.println("a > b: " + (a > b));
        System.out.println("a < b: " + (a < b));
    }
}
```

---

## 🔐 3. **Logical Operators** (used with booleans)

| Operator | Meaning | Example         | Result |        |   |         |      |
| -------- | ------- | --------------- | ------ | ------ | - | ------- | ---- |
| `&&`     | AND     | `true && false` | false  |        |   |         |      |
| \`       |         | \`              | OR     | \`true |   | false\` | true |
| `!`      | NOT     | `!true`         | false  |        |   |         |      |

### 🔹 Example:

```java
public class LogicalDemo {
    public static void main(String[] args) {
        boolean x = true, y = false;
        System.out.println("AND: " + (x && y));
        System.out.println("OR: " + (x || y));
        System.out.println("NOT X: " + (!x));
    }
}
```

---

## 🔧 4. **Bitwise Operators** (binary-level operations)

| Operator | Meaning     | Example (5 & 3)      | Binary Result     |        |            |
| -------- | ----------- | -------------------- | ----------------- | ------ | ---------- |
| `&`      | AND         | `0101 & 0011`        | `0001 (1)`        |        |            |
| \`       | \`          | OR                   | \`0101            | 0011\` | `0111 (7)` |
| `^`      | XOR         | `0101 ^ 0011`        | `0110 (6)`        |        |            |
| `~`      | Complement  | `~0101`              | `1010` (inverted) |        |            |
| `<<`     | Left shift  | `5 << 1` (5 \* 2^1)  | 10                |        |            |
| `>>`     | Right shift | `10 >> 1` (10 / 2^1) | 5                 |        |            |

### 🔹 Example:

```java
public class BitwiseDemo {
    public static void main(String[] args) {
        int a = 5; // 0101
        int b = 3; // 0011

        System.out.println("a & b: " + (a & b));
        System.out.println("a | b: " + (a | b));
        System.out.println("a ^ b: " + (a ^ b));
        System.out.println("~a: " + (~a));
        System.out.println("a << 1: " + (a << 1));
        System.out.println("a >> 1: " + (a >> 1));
    }
}
```

---

## 📝 5. **Assignment Operators**

| Operator | Usage    | Meaning      |
| -------- | -------- | ------------ |
| `=`      | `a = 10` | Assign value |
| `+=`     | `a += 5` | `a = a + 5`  |
| `-=`     | `a -= 3` | `a = a - 3`  |
| `*=`     | `a *= 2` | `a = a * 2`  |
| `/=`     | `a /= 4` | `a = a / 4`  |
| `%=`     | `a %= 2` | `a = a % 2`  |

### 🔹 Example:

```java
public class AssignmentDemo {
    public static void main(String[] args) {
        int a = 10;
        a += 5;  // now a = 15
        a *= 2;  // now a = 30

        System.out.println("Final Value: " + a); // 30
    }
}
```

---

## ☝️ 6. **Unary Operators**

| Operator | Meaning     | Example | Result  |
| -------- | ----------- | ------- | ------- |
| `++`     | Increment   | `a++`   | a = a+1 |
| `--`     | Decrement   | `a--`   | a = a-1 |
| `+`      | Unary plus  | `+a`    | +a      |
| `-`      | Unary minus | `-a`    | -a      |

```java
int a = 5;
System.out.println(a++); // 5 (then 6)
System.out.println(++a); // 7
```

---

## 🎭 7. **Ternary Operator**

Used as a shortcut for `if-else`.

### Syntax:

```java
condition ? trueResult : falseResult;
```

### 🔹 Example:

```java
public class TernaryDemo {
    public static void main(String[] args) {
        int age = 20;
        String result = (age >= 18) ? "Adult" : "Minor";
        System.out.println("You are: " + result);
    }
}
```

---

## 📋 Interview Questions

1. Difference between `==` and `equals()`?
2. What’s the difference between `&` and `&&`?
3. Why do we use bitwise operators?
4. What is the output of `a = a++` and `++a`?
5. How is ternary operator better than if-else?

---

## ✅ Summary Table

| Type       | Examples                   |                     |         |
| ---------- | -------------------------- | ------------------- | ------- |
| Arithmetic | `+`, `-`, `*`, `/`, `%`    |                     |         |
| Relational | `==`, `!=`, `>`, `<`, `>=` |                     |         |
| Logical    | `&&`, \`                   |                     | `, `!\` |
| Bitwise    | `&`, \`                    | `, `^`, `<<`, `>>\` |         |
| Assignment | `=`, `+=`, `-=`, etc.      |                     |         |
| Unary      | `++`, `--`, `-`, `+`       |                     |         |
| Ternary    | `? :`                      |                     |         |

---

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# 🔁 **5. Control Structures – Deep Explanation with Examples**

Java provides **two categories** of control structures:

1. **Decision-Making (Branching)**: `if`, `if-else`, `else-if`, `switch`
2. **Loops (Iteration)**: `for`, `while`, `do-while`, `for-each`

---

## 🧭 1. **Decision-Making Statements**

---

### ✅ `if` Statement

**Syntax:**

```java
if (condition) {
    // code runs if condition is true
}
```

**Example:**

```java
int age = 20;
if (age >= 18) {
    System.out.println("You are an adult.");
}
```

---

### ✅ `if-else` Statement

**Syntax:**

```java
if (condition) {
    // true block
} else {
    // false block
}
```

**Example:**

```java
int age = 16;
if (age >= 18) {
    System.out.println("You can vote.");
} else {
    System.out.println("You are too young to vote.");
}
```

---

### ✅ `else-if` Ladder

Used to check multiple conditions sequentially.

**Example:**

```java
int marks = 75;

if (marks >= 90) {
    System.out.println("Grade A");
} else if (marks >= 75) {
    System.out.println("Grade B");
} else if (marks >= 60) {
    System.out.println("Grade C");
} else {
    System.out.println("Fail");
}
```

---

### ✅ `switch` Statement

Best for handling **discrete values** (e.g., numbers, characters, strings).

**Syntax:**

```java
switch (expression) {
    case value1: // code
        break;
    case value2: // code
        break;
    default: // fallback
}
```

**Example:**

```java
int day = 3;
switch (day) {
    case 1: System.out.println("Monday"); break;
    case 2: System.out.println("Tuesday"); break;
    case 3: System.out.println("Wednesday"); break;
    default: System.out.println("Invalid");
}
```

---

## 🔁 2. **Looping Structures (Iteration)**

---

### ✅ `for` Loop

Used when the number of iterations is known.

**Syntax:**

```java
for (initialization; condition; increment) {
    // body
}
```

**Example:**

```java
for (int i = 1; i <= 5; i++) {
    System.out.println("Count: " + i);
}
```

---

### ✅ `while` Loop

Used when the condition is checked **before** executing the body.

**Syntax:**

```java
while (condition) {
    // loop body
}
```

**Example:**

```java
int i = 1;
while (i <= 3) {
    System.out.println("While loop: " + i);
    i++;
}
```

---

### ✅ `do-while` Loop

Executes the loop **at least once**, even if condition is false.

**Syntax:**

```java
do {
    // loop body
} while (condition);
```

**Example:**

```java
int i = 1;
do {
    System.out.println("Do-while loop: " + i);
    i++;
} while (i <= 3);
```

---

### ✅ `for-each` Loop (Enhanced for Loop)

Used to iterate over **arrays/collections**.

**Syntax:**

```java
for (type var : array) {
    // loop body
}
```

**Example:**

```java
int[] nums = {10, 20, 30};
for (int n : nums) {
    System.out.println("Number: " + n);
}
```

---

## 🧠 Comparison Table: `for`, `while`, `do-while`, `for-each`

| Loop       | When to Use                   | Condition Checked  |
| ---------- | ----------------------------- | ------------------ |
| `for`      | Known iterations              | Before loop        |
| `while`    | Unknown iterations            | Before loop        |
| `do-while` | Ensure at least one execution | After loop         |
| `for-each` | Iterating over arrays         | Implicitly handled |

---

## 📋 Interview Questions

1. Difference between `while` and `do-while`?
2. Can `switch` work with strings? *(Yes, from Java 7+)*
3. When should you use `for-each` vs `for`?
4. Can you use break/continue inside loops? *(Yes)*
5. What happens if a loop condition is always `true`?

---

## 📝 Practice Exercise (Optional)

Print the first 10 even numbers using:

* a `for` loop
* a `while` loop
* a `do-while` loop

---

## ✅ Summary

| Control Structure | Used For         | Example Keywords           |
| ----------------- | ---------------- | -------------------------- |
| Branching         | Decision making  | `if`, `else`, `switch`     |
| Looping           | Repetition       | `for`, `while`, `do-while` |
| Collections       | Simple traversal | `for-each`                 |

---

Absolutely! Let's focus deeply on the **`for-each` loop** in Java — how it works, when to use it, its syntax, behavior, limitations, internal logic, and real-world use cases.

---

# 🔁 **Java `for-each` Loop – Deep Explanation**

---

## ✅ What is a `for-each` Loop?

The `for-each` loop is a **simplified version of the traditional `for` loop**, designed for **looping over arrays or collections** without worrying about indexes.

---

## 📘 Syntax

```java
for (dataType variable : arrayOrCollection) {
    // code to execute
}
```

* `dataType`: Type of elements in array/collection
* `variable`: Temporary variable that holds each element one by one
* `arrayOrCollection`: The iterable data structure

---

## 🔹 Example 1: Iterating over an array

```java
public class ForEachArray {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40};

        for (int num : numbers) {
            System.out.println("Value: " + num);
        }
    }
}
```

**Output:**

```
Value: 10
Value: 20
Value: 30
Value: 40
```

---

## 🔹 Example 2: Iterating over a `String` array

```java
public class ForEachString {
    public static void main(String[] args) {
        String[] names = {"Java", "Python", "C++"};

        for (String name : names) {
            System.out.println("Language: " + name);
        }
    }
}
```

---

## 🔹 Example 3: Using `for-each` with Collections (like `ArrayList`)

```java
import java.util.ArrayList;

public class ForEachList {
    public static void main(String[] args) {
        ArrayList<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Mango");

        for (String fruit : fruits) {
            System.out.println("Fruit: " + fruit);
        }
    }
}
```

---

## 🧠 Internally: How `for-each` Works

Under the hood, the `for-each` loop uses an **Iterator** to traverse elements one by one from the collection/array.

```java
for (String name : names) { ... }
```

Is internally similar to:

```java
for (int i = 0; i < names.length; i++) {
    String name = names[i];
    ...
}
```

---

## ❗ Limitations of `for-each` loop

| Limitation                                | Explanation                              |
| ----------------------------------------- | ---------------------------------------- |
| Cannot access index                       | No built-in access to index (`i`)        |
| Cannot modify original elements           | Modifies only local copies               |
| Not suitable for removing items           | Causes `ConcurrentModificationException` |
| Not usable with primitives in collections | Collections only store objects           |

---

## 🔄 Modifying Elements: Why `for-each` fails here

```java
int[] nums = {1, 2, 3};
for (int n : nums) {
    n = n * 2; // Modifies only copy, NOT actual array
}
System.out.println(nums[0]); // Still prints 1
```

✅ Use a normal `for` loop instead if you want to modify elements.

---

## 🧪 Real-World Use Case

```java
public class StudentList {
    public static void main(String[] args) {
        String[] students = {"Aswini", "Rahul", "Meena"};
        for (String student : students) {
            System.out.println("Welcome, " + student);
        }
    }
}
```

---

## ✅ Best Practices

* ✔ Use `for-each` for **read-only traversal** of arrays/lists.
* ❌ Don’t use it when you need:

  * The **index** of the element
  * To **modify** elements directly in the array
  * To **remove** elements during iteration

---

## 📋 Interview Questions

1. Can we use `for-each` on `HashMap`?

   * ✅ Yes, using `entrySet()` or `keySet()`

2. Can we modify the original array in a `for-each` loop?

   * ❌ No, it uses a copy of the element

3. Is `for-each` faster than `for`?

   * ✅ Sometimes, but not always (depends on use case)

---

## ✅ Summary Table

| Feature               | `for-each` Loop               |
| --------------------- | ----------------------------- |
| Simplicity            | High                          |
| Index Access          | Not available                 |
| Element Modification  | Not possible (on primitives)  |
| Safe with Collections | Yes (read-only)               |
| Performance           | Efficient for read operations |

---


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# 🔢 **6. Arrays in Java – Deep Explanation with Examples**

---

## ✅ What is an Array?

An **array** in Java is a **fixed-size container** that can hold **multiple values of the same data type** under one variable name.

### ✅ Why use arrays?

* To store **multiple values** in a **single variable**
* Efficient for **indexed access**
* Saves memory and improves performance

---

## 📘 Syntax of Array Declaration

```java
dataType[] arrayName;           // recommended
dataType arrayName[];           // also allowed (from C/C++)
```

---

## 📌 Types of Arrays in Java

| Type             | Description                                |
| ---------------- | ------------------------------------------ |
| **1D Array**     | Simple linear array                        |
| **2D Array**     | Table or matrix-like structure             |
| **Jagged Array** | Array of arrays with **different lengths** |

---

## ✅ 1. **1D Array (Single Dimensional)**

### 🔹 Declaration & Initialization:

```java
int[] arr = new int[5];        // declaration + memory allocation
arr[0] = 10;                   // assign value

int[] b = {1, 2, 3, 4, 5};     // declaration + initialization
```

### 🔹 Example:

```java
public class OneDArray {
    public static void main(String[] args) {
        int[] nums = {5, 10, 15, 20};

        for (int i = 0; i < nums.length; i++) {
            System.out.println("Element at index " + i + ": " + nums[i]);
        }
    }
}
```

---

## ✅ 2. **2D Array (Matrix)**

A 2D array is an **array of arrays**. Think of it like a table (rows × columns).

### 🔹 Declaration:

```java
int[][] matrix = new int[2][3];  // 2 rows, 3 columns
```

### 🔹 Initialization:

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6}
};
```

### 🔹 Example:

```java
public class TwoDArray {
    public static void main(String[] args) {
        int[][] mat = {
            {1, 2, 3},
            {4, 5, 6}
        };

        for (int i = 0; i < mat.length; i++) {
            for (int j = 0; j < mat[i].length; j++) {
                System.out.print(mat[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

### ✅ Output:

```
1 2 3
4 5 6
```

---

## ✅ 3. **Jagged Arrays (Irregular 2D Arrays)**

Arrays with **different column lengths** per row.

### 🔹 Example:

```java
public class JaggedArray {
    public static void main(String[] args) {
        int[][] jag = new int[3][];
        jag[0] = new int[]{1, 2};
        jag[1] = new int[]{3, 4, 5};
        jag[2] = new int[]{6};

        for (int i = 0; i < jag.length; i++) {
            for (int j = 0; j < jag[i].length; j++) {
                System.out.print(jag[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

---

## 🎯 Accessing Array Elements

* **Indexing starts from 0**
* Access via: `array[index]`
* Modify via: `array[index] = newValue`

---

## 🧠 Memory Representation

```text
int[] arr = {10, 20, 30};

arr[0] → 10
arr[1] → 20
arr[2] → 30
```

All elements are **stored in continuous memory locations**.

---

## ❗ Common Mistakes

| Mistake                          | Explanation                               |
| -------------------------------- | ----------------------------------------- |
| `ArrayIndexOutOfBoundsException` | Accessing beyond the array size           |
| Mixing data types                | Arrays are type-specific                  |
| Changing size                    | Size of array is **fixed** after creation |

---

## 🔁 Array with `for-each` Loop

```java
int[] nums = {100, 200, 300};
for (int x : nums) {
    System.out.println(x);
}
```

---

## 📦 Array with `Objects` Example

```java
class Student {
    String name;
    Student(String name) { this.name = name; }
}

public class ObjectArray {
    public static void main(String[] args) {
        Student[] list = {
            new Student("Aswini"),
            new Student("Ravi"),
            new Student("Priya")
        };

        for (Student s : list) {
            System.out.println("Student: " + s.name);
        }
    }
}
```

---

## ✅ Summary Table

| Feature     | 1D Array   | 2D Array       | Jagged Array             |
| ----------- | ---------- | -------------- | ------------------------ |
| Shape       | Linear     | Rows & Columns | Rows with varied columns |
| Declaration | `int[] a`  | `int[][] b`    | `int[][] jagged`         |
| Accessing   | `a[i]`     | `b[i][j]`      | `jagged[i][j]`           |
| Length      | `a.length` | `b[i].length`  | `jagged[i].length`       |

---

## 📋 Interview Questions

1. Can an array in Java change its size?
2. What is the default value of an `int[]`?
3. Difference between 2D array and jagged array?
4. What exception is thrown if index is invalid?
5. Can arrays store objects? *(Yes)*

---


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# 🧱 **7. Object-Oriented Programming – Deep Explanation**

Java is built on six OOP pillars:

1. **Class**
2. **Object**
3. **Inheritance**
4. **Polymorphism**
5. **Abstraction**
6. **Encapsulation**

---

## ✅ 1. **Class – Blueprint for Objects**

A **class** is a logical template or structure that defines properties (fields) and actions (methods). Think of a **class as a design**, like a house blueprint.

### 🔹 Example:

```java
public class Car {
    // fields (properties)
    String brand;
    int speed;

    // constructor
    Car(String brandName, int spd) {
        brand = brandName;
        speed = spd;
    }

    // method
    void displayInfo() {
        System.out.println(brand + " running at " + speed + " km/h");
    }
}
```

---

## ✅ 2. **Object – Instance of a Class**

An **object** is a **real-world entity** created from a class. Each object has its own copy of properties.

### 🔹 Example:

```java
public class Main {
    public static void main(String[] args) {
        Car myCar = new Car("Toyota", 120); // object creation
        myCar.displayInfo();  // calling method on object
    }
}
```

**Output:**

```
Toyota running at 120 km/h
```

---

## ✅ 3. **Inheritance – Code Reusability**

**Inheritance** lets one class (child/subclass) inherit the fields and methods of another class (parent/superclass).

### 🔹 Use:

* Eliminate duplicate code
* Organize code hierarchically

### 🔹 Example:

```java
class Animal {
    void sleep() {
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Barking...");
    }
}

public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sleep();  // inherited from Animal
        d.bark();   // own method
    }
}
```

**Output:**

```
Sleeping...
Barking...
```

---

## ✅ 4. **Polymorphism – Many Forms**

**Polymorphism** allows the same method to behave differently depending on the context.

### 🔹 Two Types:

1. **Compile-time** (Method Overloading)
2. **Runtime** (Method Overriding)

---

### 📌 a. **Method Overloading**

**Same method name**, different parameters.

```java
class MathUtils {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
}
```

---

### 📌 b. **Method Overriding**

**Same method name and parameters** in parent and child.

```java
class Animal {
    void makeSound() {
        System.out.println("Animal sound");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow...");
    }
}
```

---

## ✅ 5. **Abstraction – Hiding Details**

**Abstraction** shows only **essential features**, hiding complex implementation details.

### ➤ Achieved by:

* **Abstract Classes**
* **Interfaces**

---

### 📌 a. **Abstract Class Example**

```java
abstract class Shape {
    abstract void draw(); // no body
}

class Circle extends Shape {
    void draw() {
        System.out.println("Drawing Circle");
    }
}
```

---

### 📌 b. **Interface Example**

```java
interface Vehicle {
    void run();
}

class Bike implements Vehicle {
    public void run() {
        System.out.println("Bike running");
    }
}
```

---

## ✅ 6. **Encapsulation – Data Hiding**

**Encapsulation** binds fields and methods together, and restricts direct access to data using `private` fields with `getters` and `setters`.

### 🔹 Example:

```java
public class Student {
    private String name;

    // Getter
    public String getName() {
        return name;
    }

    // Setter
    public void setName(String n) {
        name = n;
    }
}
```

```java
class Test {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("Aswini");
        System.out.println(s.getName());
    }
}
```

---

## 🧠 Summary of All OOP Concepts

| Concept       | Description                     | Keyword(s)              |
| ------------- | ------------------------------- | ----------------------- |
| Class         | Blueprint of object             | `class`                 |
| Object        | Instance of class               | `new`                   |
| Inheritance   | Reuse parent features           | `extends`               |
| Polymorphism  | One method, many behaviors      | `overload`, `override`  |
| Abstraction   | Show essential, hide internal   | `abstract`, `interface` |
| Encapsulation | Hide fields with access control | `private`, `get`, `set` |

---




---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





# 📦 **8. Classes and Objects — Deep Explanation for Mastery**

---

## 🧠 What is a Class?

A **class** is a **user-defined data type** or a **blueprint** that contains:

* **Fields (variables)** → define what an object “has”
* **Methods (functions)** → define what an object “can do”

> Think of a class like a **cookie cutter**. You use the same mold (class) to make many cookies (objects).

---

### ✅ Structure of a Class:

```java
class ClassName {
    // 1. Fields (data members)
    // 2. Methods (functions)
}
```

---

### ✅ Example – Class Only:

```java
class Car {
    // Field (also called attribute or property)
    String color;

    // Method (behavior or action)
    void drive() {
        System.out.println("Driving the car...");
    }
}
```

At this point, `Car` is just a definition — **no memory** is allocated yet.

---

## 🚗 What is an Object?

An **object** is a **real instance** of a class. It is created using the `new` keyword and represents:

* A real-world entity
* With **state** (field values) and **behavior** (methods)

---

### ✅ Example – Create Object:

```java
public class Main {
    public static void main(String[] args) {
        Car myCar = new Car(); // object creation
        myCar.color = "Red";   // assigning field value
        myCar.drive();         // calling method
    }
}
```

**Output:**

```
Driving the car...
```

---

## 📌 Anatomy of Class and Object

### 🔹 Step-by-Step Breakdown:

| Element                  | Explanation                                     |
| ------------------------ | ----------------------------------------------- |
| `class Car`              | Declares a class named Car                      |
| `String color;`          | A field to store the color of the car           |
| `void drive()`           | A method (action) the car can perform           |
| `Car myCar = new Car();` | Creates an object `myCar` in memory using `new` |
| `myCar.color = "Red";`   | Accesses and assigns value to the field         |
| `myCar.drive();`         | Calls the method on the object                  |

---

## 🔄 Multiple Objects from One Class

You can create many independent objects from the same class.

```java
Car car1 = new Car();
car1.color = "Red";

Car car2 = new Car();
car2.color = "Blue";
```

Each object has **its own separate memory** for the field `color`.

---

## 🔧 Constructor Deep Dive

> A **constructor** is a special method used to **initialize** an object.

### ✅ Characteristics:

* Same name as the class
* No return type (not even `void`)
* Automatically called during object creation

---

### ✅ Example: Constructor

```java
class Car {
    String color;

    // Constructor
    Car(String c) {
        color = c;
    }

    void drive() {
        System.out.println("Driving a " + color + " car.");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Car c1 = new Car("Black");
        Car c2 = new Car("White");

        c1.drive(); // Output: Driving a Black car.
        c2.drive(); // Output: Driving a White car.
    }
}
```

---

## 🧠 How is it Stored in Memory?

Java stores class and object data in memory like this:

### 🔹 Memory Layout:

```text
Stack                Heap
-----              ---------
c1 ------------->  Car object { color = "Black" }
c2 ------------->  Car object { color = "White" }
```

---

## ⚖️ Difference: Class vs Object

| Feature    | Class                | Object                             |
| ---------- | -------------------- | ---------------------------------- |
| Meaning    | Blueprint/template   | Instance/real-world implementation |
| Memory     | No memory allocation | Allocated in heap memory           |
| Defined by | `class` keyword      | Created using `new` keyword        |
| Example    | `Car`                | `Car myCar = new Car();`           |

---

## 💬 Real-Life Analogy

| Real Object       | Class Name | Field     | Method          |
| ----------------- | ---------- | --------- | --------------- |
| Your Phone        | `Phone`    | `color`   | `makeCall()`    |
| Student in school | `Student`  | `rollNo`  | `attendClass()` |
| Bank Account      | `Account`  | `balance` | `deposit()`     |

---

## 📋 Interview Questions on Class & Object

1. What is the difference between a class and an object?
2. Can a class have multiple methods with the same name? *(Yes – overloading)*
3. When is a constructor called?
4. What is the use of the `new` keyword?
5. What is the default value of a class’s field?

---

## ✅ Summary (For Perfect Mastery)

| Concept     | Description                                            |
| ----------- | ------------------------------------------------------ |
| `class`     | A template for creating objects                        |
| Object      | A specific instance of a class                         |
| Field       | Variable defined in a class                            |
| Method      | Function defined in a class                            |
| Constructor | Special method to initialize objects                   |
| `new`       | Allocates memory and returns a reference to the object |

---

## 🔁 Practice Assignment (Optional)

Try writing a class called `Mobile` with:

* Field: `model`, `price`
* Constructor: initializes both
* Method: `showDetails()`

Create 2 objects and print the values.

---



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




# 🧬 **9. Constructors – Deep Explanation for Perfect Mastery**

---

## ✅ What is a Constructor?

A **constructor** in Java is a **special method** used to **initialize objects** when they are created.

### 📌 Key Rules:

* Same name as the class.
* No return type (not even `void`).
* Automatically called when an object is created using `new`.

---

## ✅ Why Use Constructors?

To assign **initial values** to object fields when the object is being created.

Without a constructor, you'd have to manually set values after object creation:

```java
Car c = new Car();
c.color = "Red";  // Manual assignment
```

With a constructor:

```java
Car c = new Car("Red");  // Cleaner and safer
```

---

## 🔷 Types of Constructors

| Type                      | Description                                     |
| ------------------------- | ----------------------------------------------- |
| Default Constructor       | No parameters, provided by compiler             |
| No-Argument Constructor   | Written manually, but still takes no arguments  |
| Parameterized Constructor | Takes arguments to initialize fields            |
| Constructor Overloading   | Multiple constructors with different parameters |
| Constructor Chaining      | One constructor calls another via `this()`      |

---

### ✅ 1. **Default Constructor**

Automatically created by the compiler **only if no constructor is written**.

```java
class Book {
    int pages;

    // No constructor defined ⇒ compiler adds one
}

public class Main {
    public static void main(String[] args) {
        Book b = new Book(); // Calls default constructor
        System.out.println(b.pages); // 0 (default int value)
    }
}
```

---

### ✅ 2. **No-Argument Constructor (Manual)**

Same as default, but you define it explicitly.

```java
class Car {
    String color;

    // No-arg constructor
    Car() {
        color = "Black";
    }

    void show() {
        System.out.println("Color: " + color);
    }
}
```

---

### ✅ 3. **Parameterized Constructor**

Used to pass values when creating objects.

```java
class Car {
    String color;

    Car(String c) {
        color = c;
    }

    void show() {
        System.out.println("Color: " + color);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Car car1 = new Car("Red");
        car1.show(); // Output: Color: Red
    }
}
```

---

### ✅ 4. **Constructor Overloading**

Multiple constructors with **different parameters** to allow **different ways** of object initialization.

```java
class Student {
    String name;
    int age;

    // Constructor 1
    Student() {
        name = "Unknown";
        age = 0;
    }

    // Constructor 2
    Student(String n, int a) {
        name = n;
        age = a;
    }

    void show() {
        System.out.println(name + " - " + age);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student("Aswini", 22);

        s1.show(); // Output: Unknown - 0
        s2.show(); // Output: Aswini - 22
    }
}
```

---

### ✅ 5. **Constructor Chaining (this keyword)**

Use `this()` to call **another constructor** in the **same class**.

```java
class Pen {
    String color;
    int price;

    // Constructor 1
    Pen() {
        this("Blue", 10); // Call constructor 2
    }

    // Constructor 2
    Pen(String c, int p) {
        color = c;
        price = p;
    }

    void show() {
        System.out.println(color + " pen costs " + price);
    }
}
```

**Note**: `this()` must be the **first line** in the constructor.

---

### ✅ 6. **this vs super in Constructors**

| Keyword   | Meaning                                    | Use In                     |
| --------- | ------------------------------------------ | -------------------------- |
| `this()`  | Call another constructor in **same class** | Constructor chaining       |
| `super()` | Call constructor of **parent class**       | In child class constructor |

---

## ❗ Constructor vs Method

| Feature     | Constructor        | Method                        |
| ----------- | ------------------ | ----------------------------- |
| Name        | Same as class name | Any valid identifier          |
| Return type | No return type     | Has a return type (or `void`) |
| Called when | Object is created  | Called explicitly             |
| Purpose     | Initializes object | Performs an action            |

---

## 🧠 Real-Life Analogy

Imagine a **robot factory**:

* Class = blueprint of a robot
* Constructor = the assembling process when a robot is made
* Object = final robot instance

---

## 📝 Full Code (All Concepts Combined)

```java
class Laptop {
    String brand;
    int price;

    // No-arg constructor
    Laptop() {
        this("Unknown", 0); // Calls parameterized constructor
    }

    // Parameterized constructor
    Laptop(String b, int p) {
        brand = b;
        price = p;
    }

    void show() {
        System.out.println("Brand: " + brand + ", Price: " + price);
    }
}

public class Main {
    public static void main(String[] args) {
        Laptop l1 = new Laptop();
        Laptop l2 = new Laptop("HP", 45000);

        l1.show(); // Output: Unknown - 0
        l2.show(); // Output: HP - 45000
    }
}
```

---

## 💡 Interview Questions on Constructors

1. What is a constructor and how is it different from a method?
2. What is constructor overloading? Give examples.
3. Can we call one constructor from another? *(Yes, using `this()`.)*
4. What happens if no constructor is written?
5. Can a constructor be `private`? *(Yes — used in Singleton pattern)*

---

## ✅ Summary Table

| Concept                   | Description                                  |
| ------------------------- | -------------------------------------------- |
| Constructor               | Initializes object fields                    |
| Default Constructor       | Provided by compiler if none is written      |
| Parameterized Constructor | Takes arguments to initialize                |
| Overloading               | Same name, different parameters              |
| Constructor Chaining      | One constructor calls another using `this()` |
| `this()` vs `super()`     | Same class vs Parent class constructor call  |

---



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





# 🔁 **10. Method Overloading and Overriding — Deep Explanation for Perfect Mastery**

---

## 🔷 What is **Polymorphism**?

**Polymorphism** means **"many forms"** — the same method name behaves differently based on the context.

There are **two types** of polymorphism:

| Type             | When It Happens      | Technique              |
| ---------------- | -------------------- | ---------------------- |
| **Compile-time** | During compilation   | **Method Overloading** |
| **Runtime**      | At program execution | **Method Overriding**  |

---

## ✅ PART 1: **Method Overloading (Compile-Time Polymorphism)**

---

### 🔹 What is it?

**Method Overloading** means **defining multiple methods with the same name** in the same class, but with **different**:

* Number of parameters
* Type of parameters
* Order of parameters

🧠 Overloading helps **reuse method names** for similar actions on different data types or parameter sets.

---

### ✅ Rules for Overloading:

| Can Be Different By  | Can It Work? | Example                                      |
| -------------------- | ------------ | -------------------------------------------- |
| Number of Parameters | ✅            | `print(int)` vs `print(int, int)`            |
| Type of Parameters   | ✅            | `print(int)` vs `print(double)`              |
| Order of Parameters  | ✅            | `print(String, int)` vs `print(int, String)` |
| Return Type Only     | ❌            | `int print()` vs `double print()` → Invalid! |

---

### ✅ Overloading Example:

```java
class Printer {
    void print() {
        System.out.println("No arguments");
    }

    void print(int num) {
        System.out.println("Integer: " + num);
    }

    void print(String text) {
        System.out.println("String: " + text);
    }

    void print(String text, int count) {
        System.out.println(text + " repeated " + count + " times");
    }
}

public class Main {
    public static void main(String[] args) {
        Printer p = new Printer();
        p.print();
        p.print(100);
        p.print("Java");
        p.print("Hello", 3);
    }
}
```

**Output:**

```
No arguments
Integer: 100
String: Java
Hello repeated 3 times
```

---

### 💬 Real-Life Analogy:

Imagine a "login" screen:

* `login(String username, String password)`
* `login(String email, String password)`
* `login(String phoneNumber)`

All are **login methods**, but the **inputs vary** → Method Overloading!

---

## ✅ PART 2: **Method Overriding (Runtime Polymorphism)**

---

### 🔹 What is it?

**Method Overriding** occurs when a **subclass redefines** a method from its **parent class**, using the **same method name, parameters, and return type**.

This allows **runtime polymorphism**, meaning:

* Java decides at runtime which method to call (child or parent).

---

### ✅ Rules for Overriding:

| Rule                                                 | Example                       |
| ---------------------------------------------------- | ----------------------------- |
| Method name must be same                             | `void draw()` in both classes |
| Parameters must be same                              | Same number and types         |
| Return type must be same                             | (Java 5+) or covariant        |
| Access modifier can be less restrictive              | `protected` → `public` ✔️     |
| Cannot override `final`, `static`, `private` methods | ❌                             |
| Use `@Override` annotation                           | ✔ Recommended for safety      |

---

### ✅ Overriding Example:

```java
class Animal {
    void sound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();  // Upcasting
        a.sound();  // Output: Bark
    }
}
```

---

### 🧠 Behind the Scenes:

Java looks at the **object type**, not the reference type, to decide which method to run. Even though `a` is an `Animal` reference, it's actually pointing to a `Dog` object.

---

### 💡 Real-Life Analogy:

A remote control (`Animal`) can control many devices:

* TV (Dog)
* AC (Cat)

When you press `power()`, the behavior **depends on the device** (runtime decision).

---

## 🆚 Overloading vs Overriding – Comparison Table

| Feature              | Overloading       | Overriding                    |
| -------------------- | ----------------- | ----------------------------- |
| Type of Polymorphism | Compile-time      | Runtime                       |
| Class Scope          | Same class        | Parent-child relationship     |
| Method Signature     | Must differ       | Must be same                  |
| Return Type          | Can differ        | Should be same (or covariant) |
| Access Modifier      | No restriction    | Cannot be more restrictive    |
| `static` Methods     | Can be overloaded | Cannot be overridden          |

---

## 📝 Combined Code (Overloading + Overriding)

```java
class Shape {
    void draw() {
        System.out.println("Drawing shape...");
    }

    // Overloaded method
    void draw(String color) {
        System.out.println("Drawing shape with color: " + color);
    }
}

class Circle extends Shape {
    // Overriding draw()
    @Override
    void draw() {
        System.out.println("Drawing circle...");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape s = new Shape();
        s.draw();               // Shape's draw()
        s.draw("Blue");         // Overloaded draw()

        Shape c = new Circle();
        c.draw();               // Circle's draw() — Overridden
    }
}
```

**Output:**

```
Drawing shape...
Drawing shape with color: Blue
Drawing circle...
```

---

## 📋 Interview Questions

1. What is method overloading? When is it used?
2. What is method overriding? How is it different from overloading?
3. Can you override a private/static/final method? *(No)*
4. What is the use of `@Override` annotation?
5. Can return types differ in method overloading? *(Yes)* What about overriding? *(No, unless it's covariant)*

---

## ✅ Summary for Mastery

| Topic              | Master Concept                                                 |
| ------------------ | -------------------------------------------------------------- |
| Method Overloading | Same class, method name, different parameters                  |
| Method Overriding  | Different class (inheritance), same method name and parameters |
| Overloading Use    | Improves flexibility (same name for different arguments)       |
| Overriding Use     | Runtime dynamic behavior (real object decides behavior)        |

---



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



# 🔁 **Method Overriding — Deep Explanation for Perfect Mastery**

---

## 🧠 What is Method Overriding?

Method **overriding** means a **child class redefines** a method that already exists in its **parent class**, using:

* The **same method name**
* The **same parameter list**
* The **same return type (or compatible)**

---

## ✅ Why Use Method Overriding?

To allow **specific behavior** in a child class **even if the reference is of the parent class**.

This enables **runtime polymorphism**, where the **actual object type** decides which method gets executed.

---

### 🔹 Example from Your Code:

```java
class A {
    void show() {
        System.out.println("Show in A");
    }
}

class B extends A {
    @Override
    void show() {
        System.out.println("Show in B");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        A obj = new B(); // Parent reference → Child object
        obj.show();      // Output: Show in B
    }
}
```

> Even though `obj` is of type `A`, the `B` version of `show()` runs. Why? Because **method overriding allows dynamic method dispatch** (aka **runtime binding**).

---

## 🔧 Syntax Rules of Overriding

| Rule                                                                     | Explanation                            |
| ------------------------------------------------------------------------ | -------------------------------------- |
| Method name must match                                                   | Exactly same spelling                  |
| Parameter list must match                                                | Same number, type, and order           |
| Return type must match or be covariant                                   | Child class return type can be subtype |
| Access modifier can’t be more restrictive                                | e.g., public → not private             |
| Can override only **non-static**, **non-final**, **non-private** methods | ✔                                      |

---

## ✅ Using `@Override` Annotation

```java
@Override
void show() {
    System.out.println("Overridden");
}
```

* **Optional**, but **recommended**.
* Catches **mistakes** (e.g., spelling, signature mismatch).
* Tells the compiler: “I intend to override this method.”

---

## ✅ Real-World Example: Method Overriding

```java
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Cat meows");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        a1.makeSound(); // Output: Dog barks
        a2.makeSound(); // Output: Cat meows
    }
}
```

---

## ✅ Super Keyword in Overriding

Use `super.methodName()` to call the **parent class’s version** of the method:

```java
class Parent {
    void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    @Override
    void display() {
        super.display(); // Call parent version
        System.out.println("Child display");
    }
}
```

**Output:**

```
Parent display
Child display
```

---

## ⚖️ Method Overriding vs Overloading

| Feature           | Overriding                  | Overloading                       |
| ----------------- | --------------------------- | --------------------------------- |
| Relation          | Involves inheritance        | Same class                        |
| Signature         | Must be same                | Must differ                       |
| Return type       | Must be same or covariant   | Can be same or different          |
| Purpose           | Change behavior in subclass | Provide flexibility in parameters |
| Polymorphism type | Runtime                     | Compile-time                      |

---

## 🛑 What You **CANNOT Override**

| Modifier       | Can You Override?  | Reason                        |
| -------------- | ------------------ | ----------------------------- |
| `static`       | ❌ (it’s shadowing) | Belongs to class, not object  |
| `final`        | ❌                  | Can't change final methods    |
| `private`      | ❌                  | Not accessible in subclass    |
| `constructors` | ❌                  | Constructors aren’t inherited |

---

## ✅ Covariant Return Types (Java 5+)

You can override a method and return a **subclass** of the return type.

```java
class Animal {}
class Dog extends Animal {}

class A {
    Animal getAnimal() {
        return new Animal();
    }
}

class B extends A {
    @Override
    Dog getAnimal() {
        return new Dog(); // Covariant return
    }
}
```

---

## 🧪 Practice Example – Vehicle Simulation

```java
class Vehicle {
    void start() {
        System.out.println("Starting vehicle...");
    }
}

class Bike extends Vehicle {
    @Override
    void start() {
        System.out.println("Bike starts with kick.");
    }
}

class Car extends Vehicle {
    @Override
    void start() {
        System.out.println("Car starts with button.");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle v1 = new Bike();
        Vehicle v2 = new Car();

        v1.start(); // Bike's method
        v2.start(); // Car's method
    }
}
```

---

## 📋 Interview Questions

1. What is method overriding?
2. Can static methods be overridden? *(No, they're hidden)*
3. Can you override a constructor? *(No)*
4. Can you override a method with a different return type? *(Only if it’s covariant)*
5. What is the use of `super` in overriding?

---

## ✅ Summary for Perfect Mastery

| Concept              | Description                                         |
| -------------------- | --------------------------------------------------- |
| Overriding           | Child class modifies a method from the parent class |
| Same Signature       | Method name, parameters, return type must match     |
| Runtime Polymorphism | Actual object decides which method runs             |
| Use of `super`       | Call the overridden method from parent class        |
| Cannot Override      | static, private, final methods or constructors      |
| Use `@Override`      | Helps detect errors and improves readability        |

---




---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# 🧭 **11. `this` and `super` — Deep Explanation for Perfect Mastery**

---

## 🔹 What is `this`?

The `this` keyword in Java is a reference variable that refers to the **current object** of the class.

You use `this` when you want to:

* Differentiate between **instance variables** and **local parameters**
* Call **another constructor** inside the same class
* Pass the current object as an argument
* Return the current object

---

### ✅ 1. **Access current object’s field**

Used when the constructor or method parameters **shadow instance variables** (same name).

```java
class Student {
    String name;

    Student(String name) {
        this.name = name; // 'this' refers to the current object
    }

    void show() {
        System.out.println("Name: " + this.name);
    }
}
```

---

### ✅ 2. **Invoke current object’s method**

```java
class Box {
    void display() {
        System.out.println("Display box");
    }

    void callDisplay() {
        this.display(); // Optional – can be omitted if not conflicting
    }
}
```

---

### ✅ 3. **Invoke another constructor in same class**

You can use `this()` to call **another constructor** from a constructor (constructor chaining).

```java
class Book {
    String title;
    int price;

    Book() {
        this("Java Book", 500); // Calls the parameterized constructor
    }

    Book(String title, int price) {
        this.title = title;
        this.price = price;
    }

    void show() {
        System.out.println(title + " - ₹" + price);
    }
}
```

---

### ✅ 4. **Pass current object as argument**

```java
class Student {
    void display(Student obj) {
        System.out.println("Object received");
    }

    void call() {
        display(this); // Passing current object as parameter
    }
}
```

---

### ✅ 5. **Return current object**

```java
class Bike {
    Bike getBike() {
        return this;
    }
}
```

---

## 🧠 What is `super`?

The `super` keyword in Java refers to the **immediate parent class** of a subclass.

You use `super` when you want to:

* Call **parent class constructor**
* Call **parent class method**
* Access **parent class field**

---

### ✅ 1. **Call parent class constructor**

This must be the **first statement** in a child class constructor.

```java
class Animal {
    Animal(String type) {
        System.out.println("Animal type: " + type);
    }
}

class Dog extends Animal {
    Dog() {
        super("Mammal"); // Calls Animal's constructor
        System.out.println("Dog created");
    }
}
```

**Output:**

```
Animal type: Mammal
Dog created
```

---

### ✅ 2. **Access parent class field**

If a subclass has a field with the same name as its superclass, `super` can access the **parent’s version**.

```java
class Parent {
    int value = 10;
}

class Child extends Parent {
    int value = 20;

    void show() {
        System.out.println("Child value: " + value);
        System.out.println("Parent value: " + super.value);
    }
}
```

---

### ✅ 3. **Call parent class method**

```java
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void sound() {
        super.sound(); // Call parent method
        System.out.println("Dog barks");
    }
}
```

**Output:**

```
Animal makes sound
Dog barks
```

---

## 🆚 `this` vs `super` — Comparison Table

| Feature   | `this`                           | `super`                            |
| --------- | -------------------------------- | ---------------------------------- |
| Refers to | Current object                   | Parent object                      |
| Used in   | Same class                       | Subclass                           |
| Calls     | Current class method/constructor | Parent method/constructor          |
| Access    | Own fields/methods               | Parent fields/methods              |
| Syntax    | `this.variable`, `this.method()` | `super.variable`, `super.method()` |

---

## 🔁 Combined Example (this + super)

```java
class Parent {
    int x = 10;

    Parent() {
        System.out.println("Parent Constructor");
    }

    void display() {
        System.out.println("Parent display: x = " + x);
    }
}

class Child extends Parent {
    int x = 20;

    Child() {
        this(100);         // Calls current class constructor
        System.out.println("Child Constructor");
    }

    Child(int val) {
        super();           // Calls Parent constructor
        this.x = val;      // Current object’s x
    }

    void display() {
        super.display();   // Calls Parent method
        System.out.println("Child x: " + this.x);
        System.out.println("Parent x: " + super.x);
    }
}

public class Main {
    public static void main(String[] args) {
        Child c = new Child();
        c.display();
    }
}
```

**Output:**

```
Parent Constructor
Child Constructor
Parent display: x = 10
Child x: 100
Parent x: 10
```

---

## 📋 Interview Questions

1. What is the difference between `this` and `super`?
2. Can we use both `this()` and `super()` in one constructor?

   * ❌ No, and both must be the **first statement**.
3. What happens if you don’t explicitly call `super()`?

   * Java calls the **default** parent constructor automatically.
4. When do you use `this` vs `super`?
5. Can `this` refer to static fields? *(No – only instance members)*

---

## ✅ Summary for Mastery

| Keyword   | Usage                                                    |
| --------- | -------------------------------------------------------- |
| `this`    | Refers to current object’s fields, methods, constructors |
| `super`   | Refers to parent’s fields, methods, constructors         |
| `this()`  | Calls another constructor in same class                  |
| `super()` | Calls constructor of parent class                        |

---


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



---

## 🏛 **12. Inheritance in Java**

### 🔰 Definition:

**Inheritance** is a mechanism in Java by which one class **acquires (inherits)** the **properties (fields)** and **behaviors (methods)** of another class.

### 📌 Why use Inheritance?

* **Code Reusability** – Write once, reuse many times.
* **Organize classes hierarchically** – Like a family tree.
* **Enhances maintainability** – Common logic in one base class.
* **Supports Polymorphism** – Same code behaves differently.

---

## 🔑 `extends` Keyword

Java uses `extends` to define **inheritance** from a class.

```java
class Parent {
    void show() {
        System.out.println("Parent show()");
    }
}

class Child extends Parent {
    void display() {
        System.out.println("Child display()");
    }
}

public class Main {
    public static void main(String[] args) {
        Child obj = new Child();
        obj.show();    // from Parent
        obj.display(); // from Child
    }
}
```

### 🔍 Explanation:

* `Child extends Parent` means: **Child inherits all non-private methods and variables** from `Parent`.
* `Child` gets `show()` method **without writing it again**.

---

## 🧱 Types of Inheritance in Java

> Java supports:
> ✅ Single
> ✅ Multilevel
> ✅ Hierarchical
> ❌ Multiple (using classes) – but we can achieve it using interfaces.

---

### 1️⃣ **Single Inheritance**

One class inherits another.

#### 📘 Example:

```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();  // inherited
        d.bark(); // own
    }
}
```

#### 💡 Concept:

`Dog` gets all public/protected methods of `Animal`.

---

### 2️⃣ **Multilevel Inheritance**

A class inherits from a class which itself inherits from another.

#### 📘 Example:

```java
class Animal {
    void eat() {
        System.out.println("Eats food");
    }
}

class Mammal extends Animal {
    void walk() {
        System.out.println("Walks on legs");
    }
}

class Dog extends Mammal {
    void bark() {
        System.out.println("Barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();   // from Animal
        d.walk();  // from Mammal
        d.bark();  // from Dog
    }
}
```

#### 💡 Concept:

`Dog` inherits from `Mammal`, which inherits from `Animal`.
So, `Dog` has access to all.

---

### 3️⃣ **Hierarchical Inheritance**

Multiple classes inherit from the same superclass.

#### 📘 Example:

```java
class Animal {
    void eat() {
        System.out.println("Animals eat food");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    void meow() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat(); d.bark();

        Cat c = new Cat();
        c.eat(); c.meow();
    }
}
```

#### 💡 Concept:

* One parent, multiple child classes.
* Common functionality (`eat()`) is reused.

---

## 🚫 Why Java doesn't support Multiple Inheritance (with classes)?

### Problem:

Ambiguity when two parents have the same method.

```java
class A {
    void show() { System.out.println("A"); }
}

class B {
    void show() { System.out.println("B"); }
}

// class C extends A, B { ❌ Not allowed in Java }
```

Java avoids **ambiguity** by **not allowing multiple inheritance using classes**.

---

## ✅ Multiple Inheritance with Interfaces (Allowed)

```java
interface A {
    void show();
}

interface B {
    void display();
}

class C implements A, B {
    public void show() {
        System.out.println("Show from A");
    }

    public void display() {
        System.out.println("Display from B");
    }
}
```

✅ No ambiguity → All methods must be implemented in `C`.

---

## 🧠 Tips to Master Inheritance

| Concept           | Meaning                                             |
| ----------------- | --------------------------------------------------- |
| `super` keyword   | Access parent class method/constructor              |
| Constructor call  | Parent class constructor runs before child          |
| Private members   | Not inherited                                       |
| Method Overriding | Child can redefine parent method                    |
| Upcasting         | Parent reference → child object (`A a = new B()`)   |
| Downcasting       | Child reference → cast from parent (`B b = (B) a;`) |

---

## 🔄 Bonus: `super` Keyword

```java
class A {
    A() {
        System.out.println("A constructor");
    }

    void msg() {
        System.out.println("Hello from A");
    }
}

class B extends A {
    B() {
        super(); // calls A's constructor
        System.out.println("B constructor");
    }

    void msg() {
        super.msg(); // calls A's method
        System.out.println("Hello from B");
    }
}
```

---

## ✅ Summary Table

| Inheritance Type | Syntax                   | Description                          |
| ---------------- | ------------------------ | ------------------------------------ |
| Single           | `class B extends A`      | One child inherits one parent        |
| Multilevel       | `C → B → A`              | Chain of inheritance                 |
| Hierarchical     | `B & C extends A`        | Multiple children inherit one parent |
| Multiple (X)     | Not allowed with classes | Use interfaces instead               |

---


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


---

## 🎭 **13. Polymorphism in Java**

### 🔰 What is Polymorphism?

The word **"Polymorphism"** means "**many forms**."

> In Java, **Polymorphism** allows one interface (like a method or object) to behave **differently** based on context.

---

## 🧠 Two Types of Polymorphism in Java:

| Type         | Also Known As      | When It Happens    |
| ------------ | ------------------ | ------------------ |
| Compile-Time | Method Overloading | During Compilation |
| Run-Time     | Method Overriding  | During Execution   |

---

## 1️⃣ **Compile-Time Polymorphism (Method Overloading)**

### 📘 What is Method Overloading?

> Multiple methods in the **same class** with the **same name** but **different parameters** (number or type).

### ✅ Rules:

* Same method name.
* Different parameters (type/order/number).
* Can change return type, but **not enough alone**.

---

### 📌 Example: Method Overloading

```java
class Calculator {
    // add(int, int)
    int add(int a, int b) {
        return a + b;
    }

    // add(double, double)
    double add(double a, double b) {
        return a + b;
    }

    // add(int, int, int)
    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        System.out.println(calc.add(5, 10));          // calls add(int, int)
        System.out.println(calc.add(5.5, 4.5));       // calls add(double, double)
        System.out.println(calc.add(1, 2, 3));        // calls add(int, int, int)
    }
}
```

### 🔍 Output:

```
15
10.0
6
```

### 💡 Why it's compile-time?

Because **the method call is resolved at compile time** by checking parameters.

---

## 2️⃣ **Run-Time Polymorphism (Method Overriding)**

### 📘 What is Method Overriding?

> A **child class** provides a specific implementation of a **method already defined** in the parent class.

### ✅ Rules:

* Same method name.
* Same parameter list.
* Child class overrides parent’s method.
* Access modifier: Cannot reduce visibility.
* Return type: Same or covariant (subclass type).

---

### 📌 Example: Method Overriding

```java
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a;

        a = new Dog(); // parent ref → dog object
        a.sound();     // Dog barks

        a = new Cat(); // parent ref → cat object
        a.sound();     // Cat meows
    }
}
```

### 🔍 Output:

```
Dog barks
Cat meows
```

### 💡 Why it's run-time?

Because the method is resolved **at runtime** based on the object (`new Dog()` or `new Cat()`).

---

## 🧰 Difference: Overloading vs Overriding

| Feature          | Overloading                         | Overriding                             |
| ---------------- | ----------------------------------- | -------------------------------------- |
| Type             | Compile-Time                        | Run-Time                               |
| Class            | Same class                          | In Parent-Child (Inheritance)          |
| Parameters       | Must be different                   | Must be same                           |
| Return type      | Can differ                          | Must be same or covariant              |
| Access Modifier  | No restriction                      | Can’t be more restrictive              |
| `static` methods | Can be overloaded                   | Cannot be overridden (they are hidden) |
| Purpose          | Add multiple behavior in same class | Customize behavior in subclass         |

---

## 🧪 Bonus: Method Overriding with `super`

```java
class Vehicle {
    void start() {
        System.out.println("Vehicle starts");
    }
}

class Car extends Vehicle {
    @Override
    void start() {
        super.start(); // calls parent method
        System.out.println("Car starts");
    }
}

public class Main {
    public static void main(String[] args) {
        Car c = new Car();
        c.start();
    }
}
```

### 🔍 Output:

```
Vehicle starts
Car starts
```

---

## 🧠 Concept: Dynamic Method Dispatch

> When a **parent reference** is used to refer to a **child object**, and the **overridden method is called at runtime**.

```java
Animal a = new Dog(); // upcasting
a.sound();            // Dog's sound(), not Animal's
```

✅ Java picks the correct method **dynamically** at **runtime**.

---

## 🚫 Note: Static methods cannot be overridden

```java
class A {
    static void show() {
        System.out.println("A static");
    }
}

class B extends A {
    static void show() {
        System.out.println("B static");
    }
}

public class Main {
    public static void main(String[] args) {
        A obj = new B();
        obj.show(); // A static (not B)
    }
}
```

### 🔍 Reason:

Static methods belong to the **class**, not the object.

---

## ✅ Summary Table

| Polymorphism Type | Mechanism       | Binding Time    | Example Feature          |
| ----------------- | --------------- | --------------- | ------------------------ |
| Compile-Time      | Overloading     | At Compile Time | Same method, diff params |
| Run-Time          | Overriding      | At Runtime      | Same method, subclass    |
| Static methods    | Not Overridable | Early binding   | Use class name           |
| Dynamic dispatch  | Yes (Run-Time)  | Late binding    | Parent ref, child obj    |

---

### 💡 Real-World Analogy

* **Overloading**: A **printer** that can print `(String)`, `(Image)`, or `(PDF)`.
* **Overriding**: A **button** click behaves differently in different **screens/apps** — same method, different result.

---

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


---

## 🧰 **14. Encapsulation in Java**

---

### 🔰 What is Encapsulation?

> **Encapsulation** is the process of **hiding internal data** of a class from outside access and only exposing it through **controlled methods** (getters and setters).

📦 Think of a **capsule** that hides its ingredients inside and only provides controlled access from the outside.

---

## ✅ Key Points:

| Feature            | Description                                           |
| ------------------ | ----------------------------------------------------- |
| Data hiding        | Achieved using `private` variables                    |
| Controlled access  | Using `public` getters and setters                    |
| Security           | Prevents unauthorized or invalid changes              |
| Maintainability    | Easy to update internal logic                         |
| Real-world example | ATM: You can't access internal code, only use buttons |

---

## 🔑 Syntax of Encapsulation

```java
class Person {
    // Step 1: Private data members
    private String name;
    private int age;

    // Step 2: Public getter (read)
    public String getName() {
        return name;
    }

    // Step 3: Public setter (write)
    public void setName(String name) {
        this.name = name;
    }

    // Getter and setter for age
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        // Validation logic
        if (age > 0 && age < 150) {
            this.age = age;
        } else {
            System.out.println("Invalid age.");
        }
    }
}
```

---

### 🧪 Usage Example

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Person();

        // Accessing private data via setters
        p.setName("Amit");
        p.setAge(25);

        // Getting data using getters
        System.out.println("Name: " + p.getName());
        System.out.println("Age: " + p.getAge());

        // Try to set invalid age
        p.setAge(-10); // Invalid age.
    }
}
```

---

## 🔍 Output:

```
Name: Amit
Age: 25
Invalid age.
```

---

## 💡 Why Encapsulation is Important?

| Benefit           | Description                                  |
| ----------------- | -------------------------------------------- |
| ✅ Security        | Private data can't be accessed directly      |
| ✅ Data validation | You can add checks inside setters            |
| ✅ Reusability     | Clean, independent modules                   |
| ✅ Flexibility     | Can change internals without affecting users |
| ✅ Simplicity      | Cleaner and well-structured code             |

---

## 🧠 Real-World Analogy

* 🔒 **ATM Machine**
  You press buttons to withdraw money (`public method`)
  You can’t access the money vault (`private data`)

---

## ❌ Without Encapsulation (BAD PRACTICE):

```java
class Student {
    public String name;
    public int marks;
}

public class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.name = "John";
        s.marks = -1000; // ❌ No validation, bad data
    }
}
```

This can lead to bugs, broken logic, or even security issues.

---

## ✅ With Encapsulation (GOOD PRACTICE):

```java
class Student {
    private int marks;

    public void setMarks(int marks) {
        if (marks >= 0 && marks <= 100) {
            this.marks = marks;
        } else {
            System.out.println("Marks must be between 0 and 100");
        }
    }

    public int getMarks() {
        return marks;
    }
}
```

---

## 🧠 Tip: You can make a class **read-only** or **write-only**

### 🔍 Read-Only:

```java
public String getName() { return name; }
// No setter → can’t modify name
```

### 🔍 Write-Only:

```java
public void setSecret(String secret) {
    this.secret = secret;
}
// No getter → can’t read secret
```

---

## ✅ Summary Table

| Term          | Meaning                                       |
| ------------- | --------------------------------------------- |
| `private`     | Restricts direct access                       |
| `getter`      | Returns private data                          |
| `setter`      | Sets/validates private data                   |
| Encapsulation | Combines data + methods, hides internal logic |
| Main use      | Security, validation, clean code              |

---

## 🔄 Final Example with Validation + Read/Write Control

```java
class BankAccount {
    private double balance;

    // Only allow deposits above 100
    public void deposit(double amount) {
        if (amount >= 100) {
            balance += amount;
        } else {
            System.out.println("Minimum deposit is ₹100");
        }
    }

    // No setter for balance (security)
    public double getBalance() {
        return balance;
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount acc = new BankAccount();
        acc.deposit(50);       // ❌ too low
        acc.deposit(500);      // ✅ deposit
        System.out.println("Balance: ₹" + acc.getBalance());
    }
}
```

---

## 📦 Summary

| Encapsulation Part    | Purpose                  |
| --------------------- | ------------------------ |
| `private` variables   | Hide internal data       |
| `public` methods      | Provide access (get/set) |
| Validation inside set | Prevent invalid data     |
| Applied in real-world | Bank, ATM, forms, APIs   |

---

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---

## 📐 **15. Abstraction in Java**

---

### 🔰 What is Abstraction?

> **Abstraction** is the **process of hiding internal implementation details** and **showing only essential features** to the user.

🧠 Think of it like using a **TV remote**: you press a button, and the TV works — you don’t know (or need to know) how it works internally.

---

## 🧱 Why Use Abstraction?

| Benefit            | Description                                   |
| ------------------ | --------------------------------------------- |
| ✅ Hides complexity | Only essential actions exposed                |
| ✅ Clean interface  | Easy for users to interact                    |
| ✅ Security         | Sensitive code hidden                         |
| ✅ Maintainability  | Change implementation without affecting users |
| ✅ Enforces design  | Using abstract methods/interfaces             |

---

## 🧩 Java Provides Abstraction in 2 Ways:

| Way                | Keyword          | Use Case                     |
| ------------------ | ---------------- | ---------------------------- |
| ✅ Abstract Classes | `abstract class` | Partial abstraction (0–100%) |
| ✅ Interfaces       | `interface`      | Full abstraction (100%)      |

---

## 1️⃣ **Abstract Class**

### 🔑 Key Features:

* Can have **abstract methods** (without body).
* Can also have **concrete methods** (with body).
* Cannot be instantiated.
* Subclasses **must override** abstract methods.

---

### 📘 Example: Abstract Class

```java
abstract class Animal {
    abstract void sound();  // abstract method (no body)

    void eat() {            // concrete method
        System.out.println("Animals eat food.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound(); // Dog barks
        d.eat();   // Animals eat food
    }
}
```

### 🧠 Explanation:

* `Animal` is abstract and can’t be directly created.
* `Dog` gives a **concrete implementation** of `sound()`.

---

## 2️⃣ **Interface**

### 🔑 Key Features:

* All methods are **public and abstract** by default (until Java 8).
* From Java 8+, can have `default` and `static` methods.
* **Multiple inheritance supported** using interfaces.
* A class can **implement multiple interfaces**.

---

### 📘 Example: Interface

```java
interface Vehicle {
    void start();  // implicitly public + abstract
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car starts with key");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle v = new Car();
        v.start();  // Car starts with key
    }
}
```

---

## 🧠 Real-World Analogy

| Real Item      | Interface or Abstract Class | Explanation                                                   |
| -------------- | --------------------------- | ------------------------------------------------------------- |
| TV Remote      | Interface                   | You press a button → action happens                           |
| Car            | Abstract class              | All cars have some base features, but each brand customizes   |
| Bank Interface | Abstract/Interface          | You can check balance, withdraw, but don't know internal code |

---

## 🧪 Abstract Class vs Interface: Deep Comparison

| Feature                   | Abstract Class              | Interface                              |
| ------------------------- | --------------------------- | -------------------------------------- |
| Purpose                   | Partial abstraction         | Full abstraction                       |
| Inheritance               | Single class                | Multiple interfaces allowed            |
| Contains concrete method? | Yes                         | Yes (Java 8+) with `default`           |
| Constructor allowed?      | Yes                         | ❌ No                                   |
| Fields                    | Can have variables          | Only constants (`public static final`) |
| Use case                  | When classes share behavior | When classes share abilities           |

---

## ✅ When to Use What?

| Use Case                                               | Use              |
| ------------------------------------------------------ | ---------------- |
| You need to share common code logic (fields + methods) | ✅ Abstract class |
| You want to enforce a contract with no implementation  | ✅ Interface      |
| You want multiple inheritance of behavior              | ✅ Interface      |

---

## 🔍 Advanced Example: Abstraction with Interface + Inheritance

```java
interface Shape {
    double area();          // abstract method
    double perimeter();     // abstract method
}

class Circle implements Shape {
    double radius;

    Circle(double r) {
        this.radius = r;
    }

    public double area() {
        return Math.PI * radius * radius;
    }

    public double perimeter() {
        return 2 * Math.PI * radius;
    }
}

public class Main {
    public static void main(String[] args) {
        Shape s = new Circle(5);
        System.out.println("Area: " + s.area());
        System.out.println("Perimeter: " + s.perimeter());
    }
}
```

---

## 🧠 Important Notes:

* You **cannot instantiate** an abstract class or interface directly.
* A class must `implement` all methods of an interface or `extend` an abstract class and override its abstract methods.
* Abstract classes can have **constructors**, **fields**, and **non-abstract methods**.
* Interfaces have **constants**, not regular fields.

---

## 🔄 Summary Table

| Concept              | Abstract Class   | Interface                        |
| -------------------- | ---------------- | -------------------------------- |
| Abstraction Level    | 0% to 100%       | 100% (fully abstract)            |
| Inheritance          | `extends`        | `implements`                     |
| Multiple inheritance | ❌ Not supported  | ✅ Supported                      |
| Has body methods?    | ✅ Yes            | ✅ (Java 8+ only, with `default`) |
| Can have variables?  | ✅ Yes (any type) | ✅ Only `public static final`     |

---

## ✅ Practice Challenge:

**Q:** Create an abstract class `Employee` with a method `calculateSalary()`.
Create two subclasses: `FullTimeEmployee` and `PartTimeEmployee`, each with different salary calculation logic.
Print salary for each using abstraction.

Would you like me to write this solution for you as well?
Or give you practice tasks based on abstraction?


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


```java
abstract class Animal { abstract void sound(); }
```

Let's break it down step by step and build **perfect mastery** from theory to practice.

---

## 🔍 Full Deep Explanation of:

```java
abstract class Animal {
    abstract void sound();
}
```

---

## 🔰 What is an Abstract Class?

An **abstract class** in Java is a **class that cannot be instantiated** (you can’t create objects from it directly) and **may contain abstract methods** (methods without a body) which **must be implemented by its child classes**.

> It is like a **blueprint** — it defines **what should be done**, but **not how to do it**.

---

### 🧠 Let's Understand Each Part:

### 🔹 `abstract class Animal`

* This defines an **abstract class named `Animal`**.
* It cannot be used to create objects directly: `new Animal()` ❌ is not allowed.
* It may contain **both concrete methods (with body)** and **abstract methods (without body)**.

### 🔹 `abstract void sound();`

* This is an **abstract method**.
* It means: **"Every child class must implement its own version of `sound()`."**
* It has no body `{}` because its **implementation is not known at this level**.

---

## 🔧 Why use Abstract Classes?

| Reason               | Benefit                                                  |
| -------------------- | -------------------------------------------------------- |
| 🧩 Common structure  | Base class can hold shared behavior                      |
| 🧠 Enforce rules     | Subclasses must provide their version of certain methods |
| ♻️ Code reusability  | Write once in base class, reuse in many children         |
| ✅ Polymorphism ready | Useful in upcasting and method overriding                |

---

## 🧪 Let’s Expand the Example – With Subclass

### ✅ Example: Abstract Class + Implementation

```java
abstract class Animal {
    abstract void sound(); // abstract method - must be implemented by child
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}
```

### 🔍 Execution Example:

```java
public class Main {
    public static void main(String[] args) {
        Animal d = new Dog(); // upcasting
        Animal c = new Cat();

        d.sound(); // Dog barks
        c.sound(); // Cat meows
    }
}
```

### ✅ Output:

```
Dog barks
Cat meows
```

---

## 🔒 Why `abstract` Method Has No Body?

Because the **abstract class doesn’t know the exact behavior**.

```java
abstract void sound(); // tells: every Animal must make a sound, but doesn't define how
```

Each subclass (e.g., Dog, Cat, Cow) will define their own `sound()` method.

---

## ✅ Rules of Abstract Class

| Rule                                     | Valid? |
| ---------------------------------------- | ------ |
| Can have abstract & concrete methods     | ✅ Yes  |
| Can have variables                       | ✅ Yes  |
| Can have constructors                    | ✅ Yes  |
| Can be inherited by a subclass           | ✅ Yes  |
| Can be instantiated directly             | ❌ No   |
| Can have `static` methods                | ✅ Yes  |
| Must be declared with `abstract` keyword | ✅ Yes  |

---

### 🔎 What if we don’t override abstract method?

```java
class Tiger extends Animal {
    // forgot to implement sound()
}
```

❌ Compilation error: **Tiger is not abstract and does not override abstract method `sound()`**

---

## 🔍 Use Case: With Concrete Method in Abstract Class

```java
abstract class Animal {
    abstract void sound(); // abstract method

    void eat() { // concrete method
        System.out.println("Animal is eating...");
    }
}
```

### Benefit:

* Shared logic (like `eat()`) can be reused by all animals.
* Specific logic (like `sound()`) must be defined by each child.

---

## 🧠 Real-World Analogy:

| Real Life          | Java Code                                          |
| ------------------ | -------------------------------------------------- |
| Vehicle (abstract) | `abstract class Vehicle`                           |
| start() method     | `abstract void start();` (different for car, bike) |
| fuel() method      | `void fuel() {}` (same for all)                    |

---

## 💡 Combined Summary Example

```java
abstract class Shape {
    abstract double area();
}

class Circle extends Shape {
    double radius;

    Circle(double r) {
        this.radius = r;
    }

    @Override
    double area() {
        return Math.PI * radius * radius;
    }
}

class Square extends Shape {
    double side;

    Square(double s) {
        this.side = s;
    }

    @Override
    double area() {
        return side * side;
    }
}

public class Main {
    public static void main(String[] args) {
        Shape s1 = new Circle(5);
        Shape s2 = new Square(4);

        System.out.println("Circle Area: " + s1.area());
        System.out.println("Square Area: " + s2.area());
    }
}
```

---

### ✅ Output:

```
Circle Area: 78.53981633974483
Square Area: 16.0
```

---

## 💎 Final Takeaways

| Concept           | Meaning                                            |
| ----------------- | -------------------------------------------------- |
| `abstract class`  | Can’t create objects, used as base blueprint       |
| `abstract method` | Must be implemented in subclass                    |
| Subclass          | Must override all abstract methods                 |
| Reusability       | Concrete methods and constructors can be inherited |
| Polymorphism      | Allows upcasting and dynamic method dispatch       |

---

Would you like:

* 🧪 Practice problems on abstract classes?
* 🎨 Diagram comparing interface vs abstract class?
* 👷 Mini-project using abstraction (like shape, vehicle, or employee system)?


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


```java
interface Drawable { void draw(); }
```

---

## 🧠 What Is an Interface?

An **interface** in Java is a **contract** that defines a **set of methods (without implementation)** that any implementing class must define.

> Think of an interface as a **100% abstract class** — it contains only method declarations (until Java 7), and it's used to enforce **what** a class should do, not **how**.

---

## 🔑 Key Concepts to Master

| Concept              | Description                                                                             |
| -------------------- | --------------------------------------------------------------------------------------- |
| Keyword              | `interface`                                                                             |
| Contains             | Only abstract methods (until Java 7); from Java 8+, also `default` and `static` methods |
| Implementation       | Classes use `implements` keyword                                                        |
| Multiple Inheritance | Java allows a class to implement **multiple interfaces**                                |
| No Constructors      | Interfaces cannot have constructors (can't be instantiated directly)                    |
| Public & Abstract    | All interface methods are `public abstract` by default (Java 7 and below)               |

---

## ✅ Example: Interface Declaration

```java
interface Drawable {
    void draw(); // implicitly public and abstract
}
```

This says: "Any class that implements `Drawable` **must define** the `draw()` method."

---

## 🛠 Implementing the Interface

```java
class Circle implements Drawable {
    public void draw() {
        System.out.println("Drawing Circle...");
    }
}

class Rectangle implements Drawable {
    public void draw() {
        System.out.println("Drawing Rectangle...");
    }
}
```

### 🔍 Main Method

```java
public class Main {
    public static void main(String[] args) {
        Drawable d1 = new Circle();
        Drawable d2 = new Rectangle();

        d1.draw(); // Output: Drawing Circle...
        d2.draw(); // Output: Drawing Rectangle...
    }
}
```

---

## ⚙️ Deep Dive – What Happens Behind the Scenes?

* `Drawable` is an interface = **Contract**.
* `Circle` & `Rectangle` = **Implementing classes**, so they must define `draw()`.
* You can use **polymorphism**: a `Drawable` reference can point to any object that "is a Drawable".

---

## 📦 Why Use Interfaces?

| Reason                 | Explanation                                    |
| ---------------------- | ---------------------------------------------- |
| ✅ Abstraction          | Hides implementation details                   |
| ✅ Multiple Inheritance | One class can implement many interfaces        |
| ✅ Loose Coupling       | Allows flexibility in swapping implementations |
| ✅ Design Contracts     | Enforces consistency across unrelated classes  |

---

## 🧬 Real-World Analogy

### Interface = Remote Control

```java
interface Remote {
    void pressPower();
}
```

* TV and AC both can use a remote:

```java
class TV implements Remote {
    public void pressPower() {
        System.out.println("TV turned ON");
    }
}

class AC implements Remote {
    public void pressPower() {
        System.out.println("AC turned ON");
    }
}
```

> Same interface (`Remote`), but different behaviors.

---

## 🧪 Java 8+ Advanced Interface Features

### 1. `default` Methods (from Java 8)

Allows defining a method with a body in interface:

```java
interface Drawable {
    default void show() {
        System.out.println("Showing Drawable");
    }
}
```

* This avoids breaking existing classes when interface evolves.
* Implementing class can **override** this method.

---

### 2. `static` Methods

```java
interface Drawable {
    static void info() {
        System.out.println("Drawable Interface Static Method");
    }
}
```

* Accessed via: `Drawable.info();`

---

### 3. `private` Methods (Java 9+)

Used to break logic inside default/static methods:

```java
interface Drawable {
    private void helper() {
        System.out.println("Helper logic");
    }
}
```

---

## 👥 Interface vs Abstract Class (Quick Comparison)

| Feature                  | Interface                    | Abstract Class                |
| ------------------------ | ---------------------------- | ----------------------------- |
| Instantiation            | ❌                            | ❌                             |
| Constructors             | ❌                            | ✅                             |
| Method Type (pre-Java 8) | Only abstract                | Abstract + Concrete           |
| Java 8+                  | Can have `default`, `static` | ✅                             |
| Variables                | `public static final` only   | Instance and static variables |
| Multiple inheritance     | ✅ (via interfaces)           | ❌                             |

---

## 🔄 Multiple Interface Example (Diamond Problem)

```java
interface A { void show(); }
interface B { void show(); }

class MyClass implements A, B {
    public void show() {
        System.out.println("Resolved Diamond");
    }
}
```

* ✅ No ambiguity because both interfaces just declare methods.
* You must implement `show()` once.

---

## 🏗 Interface Use in Real Projects

### Example: Payment Gateway Integration

```java
interface PaymentGateway {
    void pay(double amount);
}
```

```java
class Paytm implements PaymentGateway {
    public void pay(double amount) {
        System.out.println("Paying ₹" + amount + " via Paytm");
    }
}

class PhonePe implements PaymentGateway {
    public void pay(double amount) {
        System.out.println("Paying ₹" + amount + " via PhonePe");
    }
}
```

```java
public class Store {
    public void checkout(PaymentGateway pg) {
        pg.pay(250.0);
    }

    public static void main(String[] args) {
        Store s = new Store();
        s.checkout(new Paytm());
        s.checkout(new PhonePe());
    }
}
```

> Interfaces allow flexibility to change the payment method without changing the code structure.

---

## 🏁 Final Pro-Level Takeaways

| Concept             | Pro Tip                                                   |
| ------------------- | --------------------------------------------------------- |
| Interfaces          | Use for loose coupling & flexibility                      |
| Method Signature    | Always public abstract (by default)                       |
| `implements`        | A class can implement multiple interfaces                 |
| Interface Evolution | Java 8+ added default/static methods                      |
| Upcasting           | Use interface as reference type for runtime polymorphism  |
| Interface in Design | Used in SOLID Principles, especially Dependency Inversion |

---

Would you like:

* 🧪 Real-world interface interview coding challenges?
* 👷 Project task using interface + abstract class + polymorphism?
* 📝 Practice MCQs to test your mastery?


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---

## 🧩 **Comparison Table – Detailed Explanation**

| Feature                  | Abstract Class                                       | Interface                                                                                         |
| ------------------------ | ---------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| **Fields**               | Can have instance variables and static constants     | Only `public static final` constants (global constants)                                           |
| **Methods**              | Can have abstract + fully defined (concrete) methods | Until Java 7: Only abstract<br>Java 8+: `default`, `static` methods<br>Java 9+: `private` methods |
| **Inheritance**          | Inherit using `extends`                              | Implement using `implements`                                                                      |
| **Multiple Inheritance** | ❌ Cannot extend more than one class                  | ✅ A class can implement multiple interfaces                                                       |
| **Constructors**         | Can have constructors (but can't instantiate)        | ❌ No constructors                                                                                 |
| **Use Case**             | Common behavior with optional customization          | Contract for behavior, enforced across unrelated classes                                          |

---

# 🔬 Deep Dive with Examples

---

### ✅ 1. Fields / Variables

#### ➤ Abstract Class:

```java
abstract class Animal {
    String name = "Unknown";       // Instance variable
    static int count = 0;          // Static variable
}
```

* Can have **any type** of variables: instance, static, protected, etc.
* Variables can be `private`, `protected`, or `public`.

#### ➤ Interface:

```java
interface Animal {
    String TYPE = "Mammal";  // public static final by default
}
```

* All fields in interface are:

  * `public static final`
  * Must be **initialized at declaration**
  * Acts like constants

> ✅ Use interface when you want **constant-only values**.

---

### ✅ 2. Methods

#### ➤ Abstract Class:

```java
abstract class Animal {
    abstract void sound();      // Abstract
    void eat() {                // Concrete
        System.out.println("Eating");
    }
}
```

* Can mix **abstract and non-abstract methods**.
* Good for **template-based behavior**.

#### ➤ Interface (Java 8+):

```java
interface Animal {
    void sound();                   // Abstract (by default)
    
    default void eat() {           // Default method
        System.out.println("Eating in interface");
    }

    static void info() {          // Static method
        System.out.println("Animal Info");
    }
}
```

> Use abstract classes when you want **default implementations + partial abstraction**.<br>
> Use interfaces when you want to **enforce structure across unrelated classes**.

---

### ✅ 3. Inheritance: `extends` vs `implements`

#### ➤ Abstract Class:

```java
abstract class Shape {
    abstract void draw();
}

class Circle extends Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}
```

* Uses `extends`
* Single inheritance only: ❌ cannot extend more than one class

#### ➤ Interface:

```java
interface Drawable {
    void draw();
}

class Square implements Drawable {
    public void draw() {
        System.out.println("Drawing Square");
    }
}
```

* Uses `implements`
* A class can implement **multiple interfaces** ✅

---

### ✅ 4. Multiple Inheritance – Only Possible with Interfaces

```java
interface A { void show(); }
interface B { void show(); }

class Test implements A, B {
    public void show() {
        System.out.println("Implementing both A and B");
    }
}
```

* **No conflict** if both interfaces have same method signature.
* If using `default` methods with same name → must override.

```java
interface A {
    default void run() { System.out.println("Run A"); }
}

interface B {
    default void run() { System.out.println("Run B"); }
}

class Test implements A, B {
    public void run() {
        A.super.run(); // Or B.super.run();
    }
}
```

> Abstract class cannot support multiple inheritance: `class A extends B, C` → ❌ Compilation error

---

## 🧠 When to Use Interface vs Abstract Class

| Use Case                                                     | Prefer           |
| ------------------------------------------------------------ | ---------------- |
| You need to **define a contract** with no implementation     | ✅ Interface      |
| You want to **share code** among related classes             | ✅ Abstract Class |
| You want to create **plugin-like architecture**              | ✅ Interface      |
| You want **partial abstraction with default behavior**       | ✅ Abstract Class |
| You need **multiple inheritance**                            | ✅ Interface      |
| Adding new capabilities (e.g., `Comparable`, `Serializable`) | ✅ Interface      |
| You want to define constants                                 | ✅ Interface      |

---

## 💡 Real-World Analogy

| Abstract Class                                        | Interface                                            |
| ----------------------------------------------------- | ---------------------------------------------------- |
| Blueprint with partial construction done              | Blueprint only                                       |
| Parent class sharing behavior                         | Role-based abilities                                 |
| 🧬 Animal has `eat()` (defined), `sound()` (abstract) | 🧪 Any class that wants to be `Eatable` must `eat()` |

---

## 🧪 Summary Table (Pro-Level)

| Feature              | Abstract Class          | Interface                              |
| -------------------- | ----------------------- | -------------------------------------- |
| Inheritance          | Single (`extends`)      | Multiple (`implements`)                |
| Instantiation        | ❌                       | ❌                                      |
| Constructors         | ✅ (for subclass use)    | ❌                                      |
| Fields               | Any                     | `public static final` only             |
| Methods              | Abstract + Concrete     | Abstract, Default, Static              |
| Ideal For            | Base classes with logic | Contracts across classes               |
| Java 8+ Enhancements | N/A                     | `default`, `static`, `private` methods |

---

## 🏁 conclusion :-

| If You Want...                                      | Use              |
| --------------------------------------------------- | ---------------- |
| Code reusability with optional behavior             | `abstract class` |
| Total abstraction and multiple behavior inheritance | `interface`      |
| Designing APIs / plugin systems                     | `interface`      |
| Creating a superclass                               | `abstract class` |

---


* 🔁 Interface vs Abstract Class **interview trick questions**
* 🧪 Real-world code challenges to practice
* 📚 Summary flashcards for last-minute revision


To fully master **Java Modifiers** at a **pro-to-mastery level**, you must deeply understand:

> 🔹 **Access Modifiers** – control *visibility*
> 🔹 **Non-Access Modifiers** – control *behavior* (like memory use, thread safety, overriding rules, etc.)

---

# 🧷 **17. Modifiers – Deep Explanation with Examples**

---

## 🔑 1. **Access Modifiers**

Controls *where* a class/member can be accessed from.

| Modifier    | Same Class | Same Package | Subclass (Other Package) | Other Packages |
| ----------- | ---------- | ------------ | ------------------------ | -------------- |
| `public`    | ✅          | ✅            | ✅                        | ✅              |
| `protected` | ✅          | ✅            | ✅                        | ❌              |
| *default*   | ✅          | ✅            | ❌                        | ❌              |
| `private`   | ✅          | ❌            | ❌                        | ❌              |

---

### 🔸 `public` – Accessible **everywhere**

```java
public class Car {
    public String brand = "Toyota";
    public void drive() {
        System.out.println("Driving");
    }
}
```

### 🔸 `private` – Accessible **only in same class**

```java
class BankAccount {
    private double balance = 1000;

    private void showBalance() {
        System.out.println(balance);
    }
}
```

> 🔐 Use `private` for encapsulation & security

### 🔸 `protected` – Accessible **within package + subclass (even if in different package)**

```java
package com.a;
public class Animal {
    protected void sound() { System.out.println("Animal sound"); }
}

package com.b;
class Dog extends com.a.Animal {
    void makeSound() { sound(); }  // ✅ allowed
}
```

### 🔸 Default (no modifier) – Package-private

```java
class House {
    void openDoor() { System.out.println("Door opened"); }
}
```

> Only classes in the **same package** can access.

---

## 🔧 2. **Non-Access Modifiers**

---

### 🔸 `static` – Belongs to **class**, not objects

#### ▸ Static Variable

```java
class Employee {
    static int count = 0;
    Employee() { count++; }
}
```

#### ▸ Static Method

```java
class Utils {
    static void greet() {
        System.out.println("Hello");
    }
}
```

> ✅ Call with `ClassName.methodName()` → No object needed.

---

### 🔸 `final` – **Cannot change / override / extend**

#### ▸ Final Variable

```java
final int MAX = 100;  // constant
```

#### ▸ Final Method

```java
class A {
    final void show() {}
}
class B extends A {
    // void show() {} ❌ Cannot override
}
```

#### ▸ Final Class

```java
final class Shape {}
// class Circle extends Shape {} ❌ Not allowed
```

> ✅ Use `final` to make constants, prevent overriding/inheritance.

---

### 🔸 `abstract` – Must be implemented by subclass

#### ▸ Abstract Class

```java
abstract class Animal {
    abstract void makeSound(); // no body
}
```

#### ▸ Abstract Method

```java
abstract void move();  // must be overridden
```

> 🔸 Cannot create objects of abstract class

---

### 🔸 `synchronized` – Thread-safe method/block

```java
class Printer {
    synchronized void printDoc() {
        // only 1 thread at a time
    }
}
```

> Ensures **mutual exclusion** in multithreading

---

### 🔸 `transient` – Skip serialization

```java
class User implements Serializable {
    String username;
    transient String password;  // not serialized
}
```

> ✅ Use `transient` to protect sensitive data during serialization.

---

### 🔸 `volatile` – Always read from **main memory**

```java
class SharedData {
    volatile boolean running = true;
}
```

> Ensures **visibility across threads** – useful in multi-core CPUs.

---

## 🧠 Summary Table

| Modifier       | Type       | Purpose                             |
| -------------- | ---------- | ----------------------------------- |
| `public`       | Access     | Access anywhere                     |
| `private`      | Access     | Access within class                 |
| `protected`    | Access     | Package + subclasses                |
| *default*      | Access     | Package-only access                 |
| `static`       | Non-Access | Shared by all objects (class-level) |
| `final`        | Non-Access | Cannot change, override, inherit    |
| `abstract`     | Non-Access | Must override (no instantiation)    |
| `synchronized` | Non-Access | Lock to one thread                  |
| `transient`    | Non-Access | Skip during serialization           |
| `volatile`     | Non-Access | Thread-safe memory visibility       |

---

## 💡 Real-World Analogy

| Modifier       | Real-World Equivalent                    |
| -------------- | ---------------------------------------- |
| `private`      | 🔒 PIN code: only you know it            |
| `public`       | 📣 Open announcement: everyone can hear  |
| `final`        | 🧱 Cement: can't be reshaped             |
| `static`       | 🏫 School bell: same for all classes     |
| `abstract`     | 🧩 Blueprint: must build real building   |
| `synchronized` | 🚦 Traffic signal: one vehicle at a time |
| `volatile`     | 📡 Live data feed: always latest value   |

---

## 🧪 Interview Trick Questions

1. Can a method be both `abstract` and `final`?
   ❌ No → `abstract` needs override, `final` prevents override.

2. Can a class be `final` and `abstract`?
   ❌ No → `final` = no subclassing, `abstract` = must subclass

3. Can static methods be `synchronized`?
   ✅ Yes → lock on class object

4. What is the difference between `transient` and `volatile`?

   * `transient` → skip during serialization
   * `volatile` → ensure visibility between threads

---

## 🏁 Final Words

| To Master Modifiers...                                                            |
| --------------------------------------------------------------------------------- |
| ✅ Use `public/private/protected` for access rules                                 |
| ✅ Use `final/abstract/static` for class structure                                 |
| ✅ Use `synchronized/volatile/transient` in advanced Java (threads, serialization) |

---

If you want:

* 🧪 Quiz-style questions with tricky options
* 🛠 Live-use coding challenges
* 🗂 Flashcards for all modifiers



Mastering **Java Exception Handling** is crucial for professional-grade applications. It’s not just about using `try-catch`, but understanding **how the Java runtime handles errors**, **how you can control flow**, and **how to build resilient code**.

---

# ✅ **18. Exception Handling – Pro to Mastery Level**

---

## 🔍 What is an Exception?

An **exception** is an event that **disrupts normal program execution**. It occurs during **runtime** and can be **caught or thrown** using Java’s structured mechanism.

> ✅ Exception ≠ Error
> ✅ Exception = Problem you can recover from
> ❌ Error = Problem you should not try to handle (e.g., `OutOfMemoryError`)

---

## 🔶 Java Exception Hierarchy

```
Object
  └── Throwable
       ├── Error           → (Serious issues: JVM-level)
       └── Exception       → (Handled in code)
            ├── RuntimeException (Unchecked)
            └── IOException, SQLException etc. (Checked)
```

---

## 🔑 Key Concepts

| Term        | Description                           |
| ----------- | ------------------------------------- |
| `try`       | Block to monitor for exceptions       |
| `catch`     | Block to handle exception             |
| `finally`   | Always executes (cleanup)             |
| `throw`     | Manually throw an exception           |
| `throws`    | Declare exception in method signature |
| `Throwable` | Superclass of `Error` and `Exception` |

---

## 🔹 1. `try` Block

Wraps code that **might throw an exception**.

```java
try {
    int a = 10 / 0;  // risky code
}
```

---

## 🔹 2. `catch` Block

Handles specific exceptions.

```java
try {
    int a = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Cannot divide by zero!");
}
```

> ✅ You can catch multiple exceptions:

```java
try {
    String s = null;
    System.out.println(s.length());
} catch (NullPointerException e) {
    System.out.println("Null value found");
}
```

---

## 🔹 3. `finally` Block

This **always executes**, no matter what — even if there's a `return`, `break`, or exception.

```java
try {
    int[] arr = new int[2];
    arr[5] = 100;
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Index error");
} finally {
    System.out.println("This always runs!");
}
```

> 🔧 Used for resource cleanup: closing files, DB connections, etc.

---

## 🔹 4. `throw` Keyword

Used to manually **throw an exception object**.

```java
throw new ArithmeticException("Manual throw");
```

> Must be an object of `Throwable` or its subclass.

---

## 🔹 5. `throws` Keyword

Used to **declare** that a method might throw an exception.

```java
void readFile() throws IOException {
    FileReader f = new FileReader("file.txt");
}
```

> Let the **caller** handle the exception.

---

## 💣 Checked vs Unchecked Exceptions

| Type        | Description                            | Examples                                      |
| ----------- | -------------------------------------- | --------------------------------------------- |
| ✅ Checked   | Must be declared or handled            | `IOException`, `SQLException`                 |
| ❌ Unchecked | Runtime exceptions, optional to handle | `NullPointerException`, `ArithmeticException` |

---

### ✅ Checked Example:

```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("abc.txt");
}
```

### ❌ Unchecked Example:

```java
int x = 10 / 0;  // Runtime: ArithmeticException
```

---

## 🔄 Multi-Catch

```java
try {
    // risky code
} catch (IOException | SQLException e) {
    System.out.println("Multiple exceptions");
}
```

> Java 7+ feature. All exceptions must be unrelated.

---

## 🧠 Best Practices

| Practice                            | Why it matters                        |
| ----------------------------------- | ------------------------------------- |
| Catch most specific exception first | Order matters                         |
| Use `finally` for cleanup           | Ensures resource release              |
| Never catch `Exception` blindly     | Hides real problems                   |
| Avoid empty catch blocks            | Silently fails code                   |
| Use custom exceptions for clarity   | Domain-specific errors help debugging |

---

## 👨‍💻 Custom Exception

```java
class InvalidAgeException extends Exception {
    public InvalidAgeException(String msg) {
        super(msg);
    }
}

class Test {
    void validate(int age) throws InvalidAgeException {
        if (age < 18)
            throw new InvalidAgeException("Not eligible to vote");
    }
}
```

---

## 💥 Real-Life Example: ATM Simulation

```java
class ATM {
    void withdraw(double amount) throws Exception {
        if (amount > 10000) {
            throw new Exception("Exceeds limit!");
        }
        System.out.println("Withdraw successful");
    }

    public static void main(String[] args) {
        try {
            new ATM().withdraw(15000);
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        } finally {
            System.out.println("Thank you for using ATM");
        }
    }
}
```

---

## 🧪 Tricky Interview Questions

1. Can `finally` block override return in `try` block?
   ✅ Yes. If both `try` and `finally` return, `finally` wins.

2. Can we have `try` without `catch`?
   ✅ Yes, if `finally` is present.

3. What if exception is thrown in `finally` block?
   ❌ It suppresses any previous exception.

4. Can we catch multiple exceptions in one block?
   ✅ Java 7+ allows multi-catch with `|`.

---

## 📊 Exception Flow Chart

```
try {
   risk
}
catch (...) {
   handle
}
finally {
   always do this
}
↓
Next Statement
```

---

## 🧷 Summary Table

| Keyword   | Role                       |
| --------- | -------------------------- |
| `try`     | Wraps risky code           |
| `catch`   | Handles specific exception |
| `finally` | Runs always (cleanup)      |
| `throw`   | Manually throw exception   |
| `throws`  | Declare possible exception |

---

## 🧪 Want More?

🔹 Need 100 real-world Java exception handling problems?
🔹 Want quiz flashcards to drill your knowledge?
🔹 Want real exceptions from Java libraries explained?



Let's master `throw` vs `throws` like a **Java professional** – with **clear rules**, **deep concepts**, **code examples**, and **real-world use**.

---

# 🧨 `throw` vs `throws` in Java – Pro to Mastery Level

---

## 🔁 Quick Difference Table

| Keyword | `throw`                                    | `throws`                                              |
| ------- | ------------------------------------------ | ----------------------------------------------------- |
| Purpose | Actually **throws** an exception           | **Declares** an exception in method signature         |
| Used In | Inside method or block                     | In method declaration                                 |
| Object  | Followed by an **exception object**        | Followed by one or more **exception class names**     |
| Count   | Can throw **only one** exception at a time | Can declare **multiple** exceptions (comma-separated) |
| Syntax  | `throw new Exception("msg");`              | `void method() throws IOException, SQLException`      |
| Timing  | Runtime (actual throw)                     | Compile-time (tells compiler it **might throw**)      |

---

# 🔥 `throw` Keyword — **ACTUAL Throw**

### ➤ Used to **manually throw** an exception.

```java
throw new ArithmeticException("Cannot divide by zero");
```

### ⚙️ Syntax:

```java
throw new ExceptionType("Custom message");
```

### ✅ Example 1: Manual Throw

```java
public class ThrowExample {
    public static void main(String[] args) {
        int age = 15;
        if (age < 18) {
            throw new ArithmeticException("You are underage");
        }
        System.out.println("Eligible to vote");
    }
}
```

### 🔎 Explanation:

* The `throw` keyword throws the **exception object** at runtime.
* Program stops unless it's caught using `try-catch`.

---

### ✅ Example 2: Throw inside `try`

```java
try {
    throw new NullPointerException("Null found");
} catch (NullPointerException e) {
    System.out.println("Caught: " + e.getMessage());
}
```

> ⚠️ Note: You can only throw **one exception** at a time using `throw`.

---

# 🧾 `throws` Keyword — **DECLARE it MAY throw**

### ➤ Used in **method signatures** to declare exceptions the method might throw.

```java
void readFile() throws IOException
```

> ✅ Used with **checked exceptions**.

---

### ✅ Example 1: Checked Exception

```java
import java.io.*;

public class ThrowsExample {
    void readFile() throws IOException {
        FileReader fr = new FileReader("data.txt");  // checked exception
        fr.read();
        fr.close();
    }

    public static void main(String[] args) {
        ThrowsExample obj = new ThrowsExample();
        try {
            obj.readFile();
        } catch (IOException e) {
            System.out.println("File error: " + e.getMessage());
        }
    }
}
```

### 🔎 Explanation:

* Method `readFile()` **declares** it might throw `IOException` using `throws`.
* So, whoever **calls this method must handle or declare** it too.

---

### ✅ Example 2: Multiple exceptions with `throws`

```java
void process() throws IOException, SQLException {
    // ...
}
```

> ✅ You can separate multiple exceptions with commas.

---

### ✅ Example 3: Propagate Exception Upward

```java
public class Propagation {
    void level1() throws Exception {
        throw new Exception("Crash!");
    }

    void level2() throws Exception {
        level1(); // doesn't handle, rethrows
    }

    public static void main(String[] args) {
        try {
            new Propagation().level2();
        } catch (Exception e) {
            System.out.println("Caught in main: " + e.getMessage());
        }
    }
}
```

> 🔁 The exception propagates up until it is caught.

---

# 🔬 Deep Concepts: throw vs throws

| Feature               | `throw`                   | `throws`                          |
| --------------------- | ------------------------- | --------------------------------- |
| Used for              | Actual exception throwing | Declaring possible exception      |
| Followed by           | Exception **object**      | Exception **class(es)**           |
| Location              | Inside method body        | In method signature               |
| Compilation required? | ❌ Runtime only            | ✅ Compile-time enforced           |
| Exception type        | Any subclass of Throwable | Mostly for **checked exceptions** |
| Quantity              | One exception at a time   | Multiple possible exceptions      |

---

## 🛑 Can we throw multiple exceptions with `throw`?

**No.** Only one exception object at a time:

```java
throw new IOException();         ✅ OK
throw new IOException(), new SQLException();   ❌ Error
```

---

## 💡 When to use `throw` and when to use `throws`?

| When you want to...                     | Use      |
| --------------------------------------- | -------- |
| Actually throw an exception object      | `throw`  |
| Inform caller that a method might throw | `throws` |
| Handle custom rules inside method       | `throw`  |
| Propagate checked exceptions to caller  | `throws` |

---

## 💡 Real-World Use Case: Age Validation

```java
class AgeValidator {
    void validate(int age) throws Exception {
        if (age < 18) {
            throw new Exception("Not eligible");
        }
        System.out.println("Eligible");
    }

    public static void main(String[] args) {
        try {
            new AgeValidator().validate(16);
        } catch (Exception e) {
            System.out.println("Caught: " + e.getMessage());
        }
    }
}
```

---

## 🧠 Interview Questions (with answers)

| Question                                        | Answer                                                           |
| ----------------------------------------------- | ---------------------------------------------------------------- |
| Can `throw` throw multiple exceptions?          | ❌ No, only one object                                            |
| Can `throws` be used with unchecked exceptions? | ✅ Yes, but not required                                          |
| Can `main` method use `throws`?                 | ✅ Yes: `public static void main(String[] args) throws Exception` |
| Can we write `throw` without `new` keyword?     | ❌ No, must throw object                                          |
| Does `throws` handle the exception?             | ❌ No, just declares it                                           |

---

## ✅ Summary

| `throw`                         | `throws`                          |
| ------------------------------- | --------------------------------- |
| Used to **actually throw**      | Used to **declare** in method     |
| Inside method body              | In method signature               |
| Must be followed by object      | Must be followed by class name(s) |
| Only one exception at a time    | Can declare multiple exceptions   |
| Used for custom/manual throwing | Used for propagation              |

---

## 🚀 Want to Practice?


* 100+ tricky MCQs on `throw` vs `throws`
* Real-world problems (file I/O, validation, etc.)
* Challenges to build your own exception hierarchy




Let’s master **Packages** in Java – from **beginner to pro to mastery level**, with **real examples**, **deep explanations**, and usage patterns seen in **enterprise development**.

---

# 📂 19. Java Packages – Pro to Mastery Level Guide

---

## 🧠 What is a Package?

A **package** in Java is a **namespace** that organizes classes and interfaces in a logical manner.

> 🔹 Think of a package like a **folder** in your computer, containing related `.java` files (classes/interfaces).

---

## ✅ Benefits of Using Packages

| Feature              | Benefit                                                         |
| -------------------- | --------------------------------------------------------------- |
| Modularity           | Code organization & grouping                                    |
| Namespace management | Avoids class name **conflicts**                                 |
| Access protection    | Controlled visibility via **access modifiers**                  |
| Reusability          | Classes grouped can be easily **imported and reused** elsewhere |
| Maintenance          | Easy to maintain in large-scale projects                        |

---

## 🏗️ Types of Packages

| Type             | Description           | Example                      |
| ---------------- | --------------------- | ---------------------------- |
| **Built-in**     | Provided by Java      | `java.util`, `java.io`, etc. |
| **User-defined** | Created by developers | `package mypack;`            |

---

## 🔧 Syntax Overview

```java
package mypack;            // define at top of the file
import java.util.*;        // import built-in package
```

> ✅ **Package declaration must be the first line** in your `.java` file.

---

## 🧪 Example 1: Creating a User-defined Package

### Step 1: Create a package `mypack` with a class

**File: `MyClass.java`**

```java
package mypack; // ① define package

public class MyClass {
    public void showMessage() {
        System.out.println("Hello from MyClass in mypack!");
    }
}
```

> ✅ Save this in a folder named `mypack`.

---

### Step 2: Use the class from another file

**File: `MainApp.java`**

```java
import mypack.MyClass;  // ② import your package

public class MainApp {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.showMessage();
    }
}
```

> ✅ Keep `MainApp.java` **outside** `mypack` folder.

---

### Step 3: Compile and Run

```bash
javac mypack/MyClass.java
javac -cp . MainApp.java
java MainApp
```

✅ **Output:**

```
Hello from MyClass in mypack!
```

---

## 🧠 How Package System Works in Java

| Concept            | Meaning                                                    |
| ------------------ | ---------------------------------------------------------- |
| `package mypack;`  | Defines which folder/class path it belongs to              |
| `import mypack.*;` | Lets you access all classes from that package              |
| Folder structure   | Folder names must **match package names** (case-sensitive) |
| Compilation        | Compiler puts `.class` files in the correct folder         |

---

## 📦 Built-in Package Examples

| Package     | Purpose                | Common Classes                             |
| ----------- | ---------------------- | ------------------------------------------ |
| `java.lang` | Core language features | `String`, `Math`, `Object` (auto imported) |
| `java.util` | Collections, utilities | `ArrayList`, `HashMap`, `Scanner`          |
| `java.io`   | Input/output           | `File`, `BufferedReader`, `PrintWriter`    |
| `java.sql`  | JDBC (Database)        | `Connection`, `Statement`, `ResultSet`     |

---

## 🎯 Access Modifiers and Packages

| Modifier    | Same Class | Same Package | Subclass (other pkg) | Other Package |
| ----------- | ---------- | ------------ | -------------------- | ------------- |
| `public`    | ✅          | ✅            | ✅                    | ✅             |
| `protected` | ✅          | ✅            | ✅                    | ❌             |
| (default)   | ✅          | ✅            | ❌                    | ❌             |
| `private`   | ✅          | ❌            | ❌                    | ❌             |

---

## 📁 Example: Folder Structure

```
project/
│
├── mypack/
│   └── MyClass.java      (package mypack)
│
└── MainApp.java          (import mypack.MyClass)
```

---

## 📂 Example 2: Multiple Classes in One Package

```java
// File: mypack/Addition.java
package mypack;
public class Addition {
    public int add(int a, int b) {
        return a + b;
    }
}
```

```java
// File: mypack/Subtraction.java
package mypack;
public class Subtraction {
    public int sub(int a, int b) {
        return a - b;
    }
}
```

```java
// File: TestMath.java
import mypack.*;

public class TestMath {
    public static void main(String[] args) {
        Addition a = new Addition();
        Subtraction s = new Subtraction();
        System.out.println("Sum: " + a.add(10, 5));
        System.out.println("Diff: " + s.sub(10, 5));
    }
}
```

> ✅ This is how **large projects** are organized in the real world.

---

## 🧠 Pro-Level Tips

* Use `package com.company.module;` for real-world apps.
* Use `javac -d . ClassName.java` to auto-place `.class` files in correct folders.
* You can create nested packages: `package com.mybank.accounts;`
* Use `static import` to import static members:
  `import static java.lang.Math.*;`

---

## 🏢 Mastery-Level Practice Ideas

| Task                                                        | Skill Tested                 |
| ----------------------------------------------------------- | ---------------------------- |
| Create a package with 5 classes (banking, user, loan, etc.) | Multi-class package creation |
| Use multiple custom packages in one app                     | Package-to-package imports   |
| Reorganize a large project using packages                   | Modularization               |
| Use `protected` and default access in packages              | Access control understanding |
| Compile with `javac -d .` and run                           | CLI-level mastery            |

---

## 🔥 Interview Questions

| Question                                        | Answer                                                          |
| ----------------------------------------------- | --------------------------------------------------------------- |
| Can we have multiple packages in one Java file? | ❌ Only one `package` per file (first line)                      |
| Is `java.lang` auto-imported?                   | ✅ Yes                                                           |
| Can packages be nested?                         | ✅ Yes: `package com.mycompany.module;`                          |
| What if you don't use `import`?                 | You must use **fully qualified names** like `java.util.Scanner` |
| Can we create a package inside another?         | ✅ Yes, it’s called a **sub-package**                            |

---

## ✅ Summary Table

| Feature        | Description                               |
| -------------- | ----------------------------------------- |
| `package`      | Declares the folder/group                 |
| `import`       | Imports a class or whole package          |
| `javac -d .`   | Compiles and places files in correct dirs |
| `public class` | Needed to access outside the package      |
| `protected`    | Accessible in same package + subclasses   |

---

## 🚀 Want Practice or Projects?



* ⚔️ 50+ package-based MCQs
* 📁 Mini-project with packages (`school → student + teacher`)
* 🔄 Organizing an ecommerce app in multiple packages



Here’s a **mastery-level** explanation of the **`static` keyword** in Java, including deep concepts, uses, limitations, and examples:

---

## 🛠 **`static` Keyword in Java – Deep Explanation**

In Java, the `static` keyword is used to indicate that a particular member belongs **to the class rather than instances (objects) of the class**.

> ✅ **Key Idea**: A `static` member is shared by all objects of the class.

---

### 🔷 Where `static` Can Be Used:

| Element          | Static Allowed? | Description                         |
| ---------------- | --------------- | ----------------------------------- |
| Variables        | ✅               | Shared across all instances         |
| Methods          | ✅               | Can be called without object        |
| Blocks           | ✅               | Runs only once when class is loaded |
| Classes (nested) | ✅               | For creating static nested classes  |

---

## 1️⃣ **Static Variable (Class-level variable)**

A static variable is shared among all objects. It’s created once per class, not per object.

```java
class Student {
    int rollNo;
    static String college = "IIT";  // shared by all

    Student(int roll) {
        rollNo = roll;
    }

    void display() {
        System.out.println(rollNo + " " + college);
    }
}

public class TestStaticVar {
    public static void main(String[] args) {
        Student s1 = new Student(101);
        Student s2 = new Student(102);

        s1.display();  // 101 IIT
        s2.display();  // 102 IIT
    }
}
```

📌 `college` is the same for all `Student` objects.

---

## 2️⃣ **Static Method**

A static method can be called without creating an object. It can only access static data.

```java
class Calculator {
    static int square(int x) {
        return x * x;
    }
}

public class TestStaticMethod {
    public static void main(String[] args) {
        int result = Calculator.square(5); // no object needed
        System.out.println(result); // 25
    }
}
```

❗ **Restrictions** on `static` methods:

* Can only access other static methods or variables.
* Cannot access instance variables/methods directly.
* Cannot use `this` or `super` keywords.

---

## 3️⃣ **Static Block**

A static block is executed **once** when the class is loaded into memory. Ideal for static initialization.

```java
class Demo {
    static {
        System.out.println("Static block executed");
    }

    public static void main(String[] args) {
        System.out.println("Main method");
    }
}
```

🧠 Output:

```
Static block executed
Main method
```

---

## 4️⃣ **Static Class (Nested only)**

You can’t declare a top-level class as static, but you can create static **nested classes**.

```java
class Outer {
    static class Inner {
        void show() {
            System.out.println("Static nested class");
        }
    }
}

public class TestNested {
    public static void main(String[] args) {
        Outer.Inner obj = new Outer.Inner(); // no Outer object needed
        obj.show();
    }
}
```

---

## ✅ **Why and When to Use `static`**

| Use Case                   | Benefit                                  |
| -------------------------- | ---------------------------------------- |
| Constants (`static final`) | Shareable and immutable                  |
| Utility methods            | Like `Math.max()`, `Arrays.sort()`       |
| Shared counters/config     | One value for all objects                |
| Static block               | Load configurations or DB drivers        |
| Entry point                | `public static void main(String[] args)` |

---

## ❗ Limitations of Static

* Static methods can’t override instance methods.
* `this` and `super` not allowed in static context.
* Static methods can't access instance data directly.
* Memory remains until class is unloaded (longer lifecycle).

---

## 📘 Master-Level Example: Static vs Non-Static

```java
class Bank {
    String name = "SBI";
    static String country = "India";

    void showDetails() {
        System.out.println("Bank: " + name + " Country: " + country);
    }

    static void showCountry() {
        // System.out.println(name); ❌ ERROR
        System.out.println("All banks belong to: " + country);
    }
}
```

Usage:

```java
Bank.showCountry(); // static method call without object

Bank b = new Bank();
b.showDetails();    // non-static method call with object
```

---

## 🧠 Real-Life Analogy

* **Static**: Like your **Aadhaar number issuing authority** – same for everyone.
* **Non-Static**: Like your **bank balance** – unique per individual.

---

## 🧩 Best Practices

* Use `static final` for constants (e.g., `PI`, tax rate).
* Use `static` utility methods for helper classes.
* Avoid using too many static variables (tight coupling, memory retention).
* Use static nested classes only when they logically belong to the outer class.

---



Absolutely! Let’s dive deep into **Wrapper Classes in Java**—understanding **what they are, why they exist**, and **how they work**—with clear **professional-level to mastery-level explanations and examples**.

---

## 🧮 **22. Wrapper Classes**

### ✅ **Definition**:

Wrapper classes are **object representations of primitive types**. They allow **primitive data** (like `int`, `char`, `boolean`) to be treated as **objects**.

| Primitive | Wrapper Class |
| --------- | ------------- |
| `int`     | `Integer`     |
| `byte`    | `Byte`        |
| `short`   | `Short`       |
| `long`    | `Long`        |
| `float`   | `Float`       |
| `double`  | `Double`      |
| `char`    | `Character`   |
| `boolean` | `Boolean`     |

---

### 🎯 **Why Wrapper Classes?**

1. **Collections** (like `ArrayList`, `HashMap`) work with objects—not primitives.
2. **Object-oriented programming** needs everything as an object.
3. **Utility methods** (e.g., `Integer.parseInt()`, `Character.isDigit()`) come from wrapper classes.
4. **Nullability**: Wrapper classes can be `null`, primitive types can’t.

---

### 🔁 **Autoboxing and Unboxing**

Java automatically converts:

* Primitive → Wrapper (`Autoboxing`)
* Wrapper → Primitive (`Unboxing`)

✅ **Autoboxing**:

```java
int a = 10;
Integer b = a;  // auto-converted to Integer.valueOf(a)
```

✅ **Unboxing**:

```java
Integer b = 20;
int a = b;  // auto-converted to b.intValue()
```

---

### 🧪 **Full Working Example**

```java
import java.util.*;

public class WrapperExample {
    public static void main(String[] args) {
        int a = 10;

        // Manual Boxing
        Integer boxed = Integer.valueOf(a); // Explicit
        System.out.println("Boxed (manual): " + boxed);

        // Autoboxing
        Integer autoBoxed = a;
        System.out.println("AutoBoxed: " + autoBoxed);

        // Manual Unboxing
        int unBoxed = boxed.intValue(); // Explicit
        System.out.println("UnBoxed (manual): " + unBoxed);

        // Auto unboxing
        int autoUnBoxed = autoBoxed;
        System.out.println("Auto Unboxed: " + autoUnBoxed);

        // Using Wrapper with Collections
        ArrayList<Integer> list = new ArrayList<>();
        list.add(100); // autoboxing happens
        list.add(200);
        System.out.println("From List: " + list);
    }
}
```

---

### 🔍 **Common Methods in Wrapper Classes**

| Wrapper Class | Common Methods                                         |
| ------------- | ------------------------------------------------------ |
| `Integer`     | `parseInt()`, `toString()`, `compareTo()`, `valueOf()` |
| `Double`      | `parseDouble()`, `isNaN()`, `compareTo()`              |
| `Character`   | `isDigit()`, `isLetter()`, `isUpperCase()`             |
| `Boolean`     | `parseBoolean()`, `booleanValue()`                     |

#### ✅ Example:

```java
int num = Integer.parseInt("123");  // "123" → 123
String str = Integer.toString(123); // 123 → "123"
boolean flag = Boolean.parseBoolean("true"); // "true" → true
```

---

### 🧠 **Difference between Primitive and Wrapper**

| Feature         | Primitive    | Wrapper Class             |
| --------------- | ------------ | ------------------------- |
| Memory          | Lightweight  | Heavier (object overhead) |
| Null values     | Not allowed  | Allowed (`null`)          |
| Collections use | Not allowed  | Allowed                   |
| Utility Methods | No           | Yes (`parseInt`, etc.)    |
| Inheritance     | Not possible | Inherits from `Object`    |

---

### 🚨 **Caution: Wrapper Pitfalls**

#### 1. `==` vs `.equals()` (Important Interview Concept)

```java
Integer a = 127;
Integer b = 127;

System.out.println(a == b);      // true (within -128 to 127 cache range)
System.out.println(a.equals(b)); // true

Integer x = 128;
Integer y = 128;

System.out.println(x == y);      // false (not cached)
System.out.println(x.equals(y)); // true
```

* Java **caches Integer objects from -128 to 127**.
* Always use `.equals()` to compare values of wrapper objects.

---

### 🧠 **Best Practices (Mastery Tips)**

✅ Always prefer primitives when:

* You don’t need `null`
* You don’t need object features
* For performance-critical code (like in loops)

✅ Use Wrapper classes when:

* Working with collections
* You need to represent **nullable** values
* You need utility functions (`parseInt()`, `compareTo()`)

---

### 💡 Summary:

| Concept          | Description                                    |
| ---------------- | ---------------------------------------------- |
| Wrapper Classes  | Object versions of primitives                  |
| Autoboxing       | Automatic conversion from primitive to wrapper |
| Unboxing         | Automatic conversion from wrapper to primitive |
| Utility Methods  | Helpful functions like parsing, conversion     |
| Collection Usage | Needed to store primitives in collections      |

---



Absolutely! Let’s go **deep into Java String Handling** — covering every essential and advanced topic like **immutability**, **memory structure (String pool)**, **common methods**, **performance tips**, and **real interview-level mastery** with full examples.

---

## 🔤 **23. String Handling in Java**

### 🔹 What is a `String` in Java?

A `String` in Java is an **object** that represents a **sequence of characters**. It's part of the `java.lang` package and is **immutable**.

```java
String s = "Hello";
```

> Internally, a `String` is a `char[]` (character array), but once created, the content **cannot be changed**.

---

## 🔒 Immutability

### ❓ What does **immutable** mean?

* Once a `String` object is created, **you can't change its value**.
* Any modification (like `concat`, `replace`, etc.) **creates a new object**.

### ✅ Example:

```java
String s = "Hello";
s.concat(" World");

System.out.println(s); // Output: Hello
```

> Why? Because `s.concat(" World")` returns a new string `"Hello World"`, but `s` still points to `"Hello"`.

---

### 🧠 Why is String Immutable?

1. **Security**: URLs, database credentials (passed as strings) are safe.
2. **HashCode Consistency**: Needed for HashMap keys.
3. **Thread Safety**: Immutable objects are automatically thread-safe.
4. **String Pool**: Saves memory via reuse of strings.

---

## 🔄 String Pool (Heap vs SCP)

Java uses a special **memory area called the String Constant Pool** to store string literals.

```java
String s1 = "Java";
String s2 = "Java";

System.out.println(s1 == s2);  // true (points to same literal in pool)
```

But with `new String()`:

```java
String s3 = new String("Java");
System.out.println(s1 == s3);  // false (s3 is in heap)
```

Use `.equals()` to compare **values**, not references:

```java
System.out.println(s1.equals(s3)); // true
```

---

## 🔧 Common String Methods (Pro Level Use)

| Method                            | Purpose                           |
| --------------------------------- | --------------------------------- |
| `length()`                        | Returns number of characters      |
| `charAt(index)`                   | Returns char at position          |
| `substring(start, end)`           | Extracts part of string           |
| `equals()`                        | Compares values                   |
| `equalsIgnoreCase()`              | Compares without case sensitivity |
| `toUpperCase()` / `toLowerCase()` | Case conversion                   |
| `trim()`                          | Removes leading/trailing spaces   |
| `replace(old, new)`               | Replaces characters               |
| `split(regex)`                    | Splits string by regex            |
| `indexOf(char)`                   | Returns index of char             |
| `contains("str")`                 | Checks if substring exists        |
| `startsWith()` / `endsWith()`     | Checks prefix/suffix              |

### ✅ Example: Full Methods Demo

```java
public class StringMethods {
    public static void main(String[] args) {
        String s = "  Java Master  ";

        System.out.println("Length: " + s.length()); // 15
        System.out.println("Char At 2: " + s.charAt(2)); // 'v'
        System.out.println("Substring: " + s.substring(2, 6)); // "va M"
        System.out.println("Trimmed: '" + s.trim() + "'"); // "Java Master"
        System.out.println("Uppercase: " + s.toUpperCase());
        System.out.println("Replaced: " + s.replace("Master", "Pro"));
        System.out.println("Starts With: " + s.startsWith("  J")); // true
        System.out.println("Ends With: " + s.endsWith("r  ")); // true
        System.out.println("Contains: " + s.contains("Java")); // true
    }
}
```

---

## 🎯 Comparison: `==` vs `.equals()`

```java
String a = "Code";
String b = "Code";
String c = new String("Code");

System.out.println(a == b);      // true (same pool reference)
System.out.println(a == c);      // false (different memory)
System.out.println(a.equals(c)); // true (value same)
```

---

## 🚀 String Concatenation

* Use `+` operator or `concat()`.

```java
String s1 = "Hello";
String s2 = s1 + " World";  // new object
```

For performance:

* Use `StringBuilder` or `StringBuffer` for repeated concatenations (in loops).

---

## 🔄 Mutable Alternatives

### 1. `StringBuilder` (Faster, not thread-safe)

### 2. `StringBuffer` (Slower, thread-safe)

```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
System.out.println(sb);  // "Hello World"
```

---

## 📂 Real-World Example: Username Validator

```java
public class UserValidation {
    public static void main(String[] args) {
        String username = "Admin";
        if (username.equalsIgnoreCase("admin")) {
            System.out.println("Access Granted");
        } else {
            System.out.println("Access Denied");
        }
    }
}
```

---

## ❓ Interview-Level String Questions

### Q1: What is the output?

```java
String x = "abc";
String y = "abc";
System.out.println(x == y);         // true
System.out.println(x.equals(y));    // true

String z = new String("abc");
System.out.println(x == z);         // false
System.out.println(x.equals(z));    // true
```

---

### Q2: Which is better in loops?

```java
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i; // Inefficient, creates 1000+ new objects
}
```

✅ Use:

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);
}
```

---

## 🧠 Summary Table

| Feature             | Description                                              |
| ------------------- | -------------------------------------------------------- |
| Immutable           | Cannot change once created                               |
| String Pool         | Memory optimization for literals                         |
| `==` vs `.equals()` | `==`: reference, `.equals()`: value                      |
| `StringBuilder`     | Mutable, efficient                                       |
| Common Methods      | `length()`, `charAt()`, `substring()`, `replace()`, etc. |

---

## ✅ Mastery Tip:

Use `StringBuilder` when:

* Concatenating strings inside loops
* You need performance
* You don't need thread safety

Use `String` when:

* You don’t need to modify the string
* You want to store constants or messages

---

Would you like:

* ✨ Advanced string pattern interview questions?
* 🧪 String memory diagrams?
* 📦 Projects using heavy String manipulation?



Here’s a **deep, professional-to-mastery level explanation** of the **Java Collections Framework** (JCF), with detailed theory and examples:

---

## 📚 **24. Java Collections Framework**

### 🔰 **What is the Collections Framework?**

The **Java Collections Framework (JCF)** is a **unified architecture** for representing and manipulating collections (groups of objects) such as:

* Lists
* Sets
* Queues
* Maps

It is part of `java.util.*` package and contains:

* Interfaces
* Implementations (classes like `ArrayList`, `HashSet`, `HashMap`)
* Algorithms (like sorting, searching)
* Utilities (like `Collections`, `Arrays`)

---

### 🔧 **Why Collections Instead of Arrays?**

| Arrays                       | Collections                              |
| ---------------------------- | ---------------------------------------- |
| Fixed size                   | Dynamic size (can grow/shrink)           |
| No inbuilt sorting/searching | Rich utility methods (sort, search, etc) |
| Can store only same type     | Can use generics for type safety         |
| Less flexible                | More powerful & extensible               |

---

## 🏗 **Main Collection Interfaces**

### 1. **Collection (Root Interface)**

* Superinterface of **List**, **Set**, **Queue**

### 2. **List** (Ordered, allows duplicates)

* **Implementations**: `ArrayList`, `LinkedList`, `Vector`, `Stack`

```java
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");
System.out.println(names);  // [Alice, Bob]
```

### 3. **Set** (No duplicates, unordered)

* **Implementations**: `HashSet`, `LinkedHashSet`, `TreeSet`

```java
Set<Integer> ids = new HashSet<>();
ids.add(101);
ids.add(102);
ids.add(101);  // duplicate ignored
System.out.println(ids);   // [101, 102]
```

### 4. **Queue** (FIFO - First In First Out)

* **Implementations**: `LinkedList`, `PriorityQueue`

```java
Queue<String> q = new LinkedList<>();
q.offer("first");
q.offer("second");
System.out.println(q.poll());  // first
```

### 5. **Map** (Key-Value pairs)

* **Not a part of Collection interface**, but very important
* **Implementations**: `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`

```java
Map<String, Integer> scores = new HashMap<>();
scores.put("Math", 95);
scores.put("Science", 90);
System.out.println(scores.get("Math"));  // 95
```

---

## 📌 **Popular Classes**

### ✅ ArrayList

* Ordered, index-based, resizable array

```java
ArrayList<String> list = new ArrayList<>();
list.add("A");
list.add("B");
System.out.println(list.get(1));  // B
```

### ✅ LinkedList

* Doubly linked list, efficient insertion/deletion

```java
LinkedList<Integer> ll = new LinkedList<>();
ll.addFirst(10);
ll.addLast(20);
System.out.println(ll);  // [10, 20]
```

### ✅ HashSet

* Unordered, no duplicates

```java
HashSet<String> set = new HashSet<>();
set.add("Java");
set.add("Java");  // duplicate ignored
System.out.println(set);  // [Java]
```

### ✅ TreeSet

* Sorted set, no duplicates

```java
TreeSet<Integer> ts = new TreeSet<>();
ts.add(30);
ts.add(10);
ts.add(20);
System.out.println(ts);  // [10, 20, 30]
```

### ✅ HashMap

* Key-value storage, keys unique

```java
HashMap<Integer, String> map = new HashMap<>();
map.put(1, "One");
map.put(2, "Two");
System.out.println(map.get(2));  // Two
```

---

## ⚙️ **Utilities & Algorithms**

### `Collections` Class (Helper methods)

```java
List<Integer> nums = Arrays.asList(10, 5, 20);
Collections.sort(nums);  // [5, 10, 20]
Collections.reverse(nums);  // [20, 10, 5]
```

### `Arrays` Class (For arrays)

```java
int[] arr = {3, 1, 2};
Arrays.sort(arr);  // [1, 2, 3]
```

---

## 🔐 **Generics in Collections**

Generics provide **type safety** and eliminate need for type casting.

```java
List<String> names = new ArrayList<>();
names.add("Alice");  // ✅
names.add(10);       // ❌ Compile Error
```

Without Generics:

```java
List list = new ArrayList();
list.add("Text");
String s = (String) list.get(0);  // Need casting
```

---

## 🔍 **Iterator vs Enhanced For Loop**

### Using Iterator

```java
Iterator<String> it = names.iterator();
while(it.hasNext()) {
    System.out.println(it.next());
}
```

### Enhanced for-loop (foreach)

```java
for(String name : names) {
    System.out.println(name);
}
```

---

## 🧠 **Important Notes (Mastery Level)**

| Feature           | ArrayList        | HashSet | HashMap                     |
| ----------------- | ---------------- | ------- | --------------------------- |
| Allows duplicates | ✅                | ❌       | ✅ (values only)             |
| Maintains order   | ✅                | ❌       | ❌ (LinkedHashMap: ✅)        |
| Allows null       | ✅ (many)         | ✅ (one) | ✅ (1 null key, many values) |
| Synchronized      | ❌ (use `Vector`) | ❌       | ❌ (use `Hashtable`)         |
| Thread-safe       | ❌                | ❌       | ❌                           |

---

## ✅ **Best Practices**

* Always use **generics** to avoid runtime errors.
* Prefer `List` or `Set` **interface** as reference type, not implementation (`ArrayList` or `HashSet`).

  ```java
  List<String> list = new ArrayList<>();  // ✅
  ```
* For sorting objects, implement `Comparable` or use `Comparator`.
* Use `Map` when key-value relation is important.
* For thread-safe collections, consider using:

  * `Collections.synchronizedList()`
  * `ConcurrentHashMap` (modern concurrent use)

---



Absolutely! Here's a **deep professional-to-mastery level explanation** of the **core interfaces of Java Collections Framework**:

---

# ✅ Mastery Guide: Java Collections Framework Interfaces

---

## 🔑 What are Interfaces in JCF?

Java Collections Framework (JCF) is built on **abstract interfaces** like `List`, `Set`, `Map`, and `Queue`. These interfaces define **behavioral contracts**—not how data is stored or accessed, but **what operations are supported**.

Each interface has **multiple implementations** tailored for performance, ordering, synchronization, uniqueness, or sorting.

---

# 🔸 1. `List` Interface — Ordered & Indexed

### ✅ Characteristics:

* Maintains **insertion order**.
* Allows **duplicate elements**.
* Provides **positional access** via index.
* Allows **null** elements.

### ✅ Implementations:

* `ArrayList` – Fast random access, resizing array.
* `LinkedList` – Doubly linked list (good for frequent inserts/removes).
* `Vector` – Synchronized version of ArrayList.
* `Stack` – LIFO structure (extends `Vector`).

### 🧪 Example:

```java
List<String> fruits = new ArrayList<>();
fruits.add("Apple");
fruits.add("Banana");
fruits.add("Apple");  // Duplicate allowed
System.out.println(fruits.get(1));  // Banana
```

### 🔍 Methods:

| Method            | Description           |
| ----------------- | --------------------- |
| `add(E e)`        | Add element           |
| `add(int, E)`     | Add at specific index |
| `get(int)`        | Get element by index  |
| `remove(int)`     | Remove by index       |
| `set(int, E)`     | Replace element       |
| `indexOf(Object)` | Index of element      |

---

# 🔸 2. `Set` Interface — Unordered, Unique Elements

### ✅ Characteristics:

* **No duplicates** allowed.
* Does **not maintain insertion order** (unless using `LinkedHashSet`).
* At most **one null** allowed.

### ✅ Implementations:

* `HashSet` – Unordered, backed by HashMap.
* `LinkedHashSet` – Maintains insertion order.
* `TreeSet` – Sorted set using natural/comparator order.

### 🧪 Example:

```java
Set<String> countries = new HashSet<>();
countries.add("India");
countries.add("USA");
countries.add("India"); // Ignored
System.out.println(countries);  // Order not guaranteed
```

### 🔍 Methods:

| Method             | Description                 |
| ------------------ | --------------------------- |
| `add(E e)`         | Adds element if not present |
| `contains(Object)` | Check if element exists     |
| `remove(Object)`   | Remove element              |
| `clear()`          | Remove all elements         |
| `size()`           | Total number of elements    |

---

# 🔸 3. `Map` Interface — Key-Value Pairs

### ✅ Characteristics:

* Stores **(key, value)** pairs.
* Keys must be **unique**.
* Values can be **duplicated**.
* Allows **1 null key**, many null values (in `HashMap`).

### ✅ Implementations:

* `HashMap` – Unordered key-value store.
* `LinkedHashMap` – Maintains insertion order.
* `TreeMap` – Sorted by keys.
* `Hashtable` – Thread-safe, legacy.

### 🧪 Example:

```java
Map<String, Integer> marks = new HashMap<>();
marks.put("Math", 90);
marks.put("Physics", 80);
System.out.println(marks.get("Math"));  // 90
```

### 🔍 Methods:

| Method               | Description                   |
| -------------------- | ----------------------------- |
| `put(K, V)`          | Insert or update value by key |
| `get(Object key)`    | Get value for key             |
| `remove(Object key)` | Remove entry                  |
| `containsKey(K)`     | Check if key exists           |
| `keySet()`           | All keys                      |
| `values()`           | All values                    |
| `entrySet()`         | Set of key-value pairs        |

---

# 🔸 4. `Queue` Interface — FIFO Structure

### ✅ Characteristics:

* Designed for **FIFO (First In First Out)** access.
* Supports **polling**, **peeking**, **inserting**.
* Some queues also implement **Deque**, **BlockingQueue**, etc.

### ✅ Implementations:

* `LinkedList` – Can be used as Queue.
* `PriorityQueue` – Sorted queue based on comparator or natural order.
* `ArrayDeque` – For fast double-ended queue operations.

### 🧪 Example:

```java
Queue<String> q = new LinkedList<>();
q.offer("Task1");
q.offer("Task2");
System.out.println(q.poll());  // Task1 (removes)
System.out.println(q.peek());  // Task2 (doesn't remove)
```

### 🔍 Methods:

| Method       | Description                        |
| ------------ | ---------------------------------- |
| `offer(E e)` | Adds element to queue              |
| `poll()`     | Retrieves and removes head element |
| `peek()`     | Retrieves head without removing    |
| `remove()`   | Removes and throws if empty        |

---

## 🧠 Master-Level Comparison Table:

| Feature          | List         | Set           | Map                              | Queue               |
| ---------------- | ------------ | ------------- | -------------------------------- | ------------------- |
| Order maintained | ✅ (List)     | ❌ (`HashSet`) | ❌ (`HashMap`)                    | ✅ (`LinkedList`)    |
| Duplicates       | ✅            | ❌             | ✅ (on values only)               | ✅                   |
| Null allowed     | ✅            | ✅ (1 null)    | ✅ (1 null key, many null values) | ✅                   |
| Access by index  | ✅            | ❌             | ✅ (by key)                       | ❌                   |
| Sorted           | ❌            | ✅ (`TreeSet`) | ✅ (`TreeMap`)                    | ✅ (`PriorityQueue`) |
| Use Case         | Ordered list | Unique items  | Key-Value lookup                 | Job/task queue      |

---

## 🛠 Use Case Examples

### 🔸 Use `List`:

* When order matters (e.g., product list, playlist)
* When duplicates are allowed

### 🔸 Use `Set`:

* When uniqueness is required (e.g., user IDs, tags)

### 🔸 Use `Map`:

* When lookup by key is required (e.g., studentId → marks)

### 🔸 Use `Queue`:

* For **task processing**, **scheduler**, **message queue**

---

## ✅ Summary

| Interface | Ordered  | Duplicate  | Key/Value | Use for      |
| --------- | -------- | ---------- | --------- | ------------ |
| `List`    | ✅        | ✅          | ❌         | Indexed data |
| `Set`     | ❌        | ❌          | ❌         | Unique data  |
| `Map`     | ❌        | ✅ (values) | ✅         | Lookup data  |
| `Queue`   | ✅ (FIFO) | ✅          | ❌         | Task flow    |

---

## 🔄 Real-Time Interview Practice:

**Q1:** Why is `HashSet` faster than `TreeSet`?
➡️ `HashSet` uses hash codes for O(1) access; `TreeSet` maintains sorted order, leading to O(log n) complexity.

**Q2:** Can you use `Map` in a `for-each` loop?
➡️ Yes, via `entrySet()`:

```java
for(Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```

---



Let's deeply explore the **Java Collections Framework Classes** — `ArrayList`, `LinkedList`, `HashSet`, `HashMap`, `TreeSet` — with detailed, professional-to-mastery level explanations and examples:

---

## 🔍 **Overview: Why These Classes Matter**

Each class in the Java Collections Framework is designed for specific use-cases, offering trade-offs between:

* Time complexity (speed of access, insertion, deletion)
* Ordering
* Duplicates allowed or not
* Thread-safety

---

## 📦 **1. `ArrayList`**

> A **resizable array**. Fast for **index-based access**, slow for **insert/delete** in the middle.

### ✅ Key Points:

* Maintains **insertion order**
* Allows **duplicates**
* Uses a **dynamic array** internally
* Implements `List` interface

### 🔧 Example:

```java
import java.util.*;

public class ArrayListDemo {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Alice"); // duplicates allowed

        System.out.println("Index 1: " + names.get(1)); // Bob
        System.out.println("All Names: " + names);     // [Alice, Bob, Alice]
    }
}
```

### ⏱ Time Complexity:

| Operation           | Time   |
| ------------------- | ------ |
| get(index)          | O(1)   |
| add/remove() middle | O(n)   |
| add at end          | O(1)\* |

---

## 🔁 **2. `LinkedList`**

> A **doubly-linked list**. Fast insert/delete in middle, slower access by index.

### ✅ Key Points:

* Maintains **insertion order**
* Allows **duplicates**
* Efficient **insertion/removal**
* Implements both `List` and `Deque`

### 🔧 Example:

```java
import java.util.*;

public class LinkedListDemo {
    public static void main(String[] args) {
        LinkedList<String> queue = new LinkedList<>();
        queue.add("Task1");
        queue.add("Task2");
        queue.addFirst("UrgentTask");

        System.out.println("Tasks: " + queue);         // [UrgentTask, Task1, Task2]
        System.out.println("First Task: " + queue.peek()); // UrgentTask
    }
}
```

### ⏱ Time Complexity:

| Operation               | Time |
| ----------------------- | ---- |
| get(index)              | O(n) |
| add/remove at head/tail | O(1) |

---

## 🔁 **3. `HashSet`**

> A **set** backed by a **HashMap**. No duplicates, no specific order.

### ✅ Key Points:

* **No duplicates**
* **No guaranteed order**
* Based on **hashing**
* Implements `Set` interface

### 🔧 Example:

```java
import java.util.*;

public class HashSetDemo {
    public static void main(String[] args) {
        Set<String> items = new HashSet<>();
        items.add("Pen");
        items.add("Book");
        items.add("Pen"); // ignored

        System.out.println("Items: " + items); // [Pen, Book] (unordered)
    }
}
```

### ⏱ Time Complexity:

| Operation           | Time         |
| ------------------- | ------------ |
| add/remove/contains | O(1) average |

---

## 🗺️ **4. `HashMap`**

> Stores **key-value pairs**. Keys are unique, values can be duplicate.

### ✅ Key Points:

* **No duplicates in keys**
* **Allows null** key and values
* **Unordered**
* Implements `Map`

### 🔧 Example:

```java
import java.util.*;

public class HashMapDemo {
    public static void main(String[] args) {
        Map<String, Integer> marks = new HashMap<>();
        marks.put("Math", 90);
        marks.put("Science", 80);
        marks.put("Math", 95); // replaces value

        System.out.println("Math marks: " + marks.get("Math")); // 95
        System.out.println("All marks: " + marks);
    }
}
```

### ⏱ Time Complexity:

| Operation      | Time         |
| -------------- | ------------ |
| get/put/remove | O(1) average |

---

## 🌳 **5. `TreeSet`**

> A **sorted set** (Red-Black tree). No duplicates. Elements are **sorted**.

### ✅ Key Points:

* **Sorted in natural order** or by custom comparator
* **No duplicates**
* **Slower than HashSet**

### 🔧 Example:

```java
import java.util.*;

public class TreeSetDemo {
    public static void main(String[] args) {
        Set<String> cities = new TreeSet<>();
        cities.add("Mumbai");
        cities.add("Delhi");
        cities.add("Bangalore");

        System.out.println("Cities: " + cities); // [Bangalore, Delhi, Mumbai]
    }
}
```

### ⏱ Time Complexity:

| Operation           | Time     |
| ------------------- | -------- |
| add/remove/contains | O(log n) |

---

## 🧪 ✅ Use-Case Summary Table

| Class      | Order     | Duplicates | Nulls                | Best For                  |
| ---------- | --------- | ---------- | -------------------- | ------------------------- |
| ArrayList  | Yes       | Yes        | Yes                  | Fast random access        |
| LinkedList | Yes       | Yes        | Yes                  | Frequent insert/delete    |
| HashSet    | No        | No         | One                  | Unique items, fast lookup |
| TreeSet    | Sorted    | No         | ❌                    | Sorted unique values      |
| HashMap    | No (keys) | Keys: No   | One key, many values | Fast key-value storage    |

---

## ✅ Pro Tips

* Prefer `ArrayList` for most `List` needs unless frequent insertions/removals in middle.
* Use `HashMap` or `HashSet` when **performance** is key and **ordering** isn't important.
* Use `TreeSet` or `TreeMap` when **sorted order** is needed.
* `LinkedList` should only be used where index-based access isn't required often.

---




Great! Let’s dive deep into **Java File Handling** — topic 25 — and explore everything at a **pro-to-mastery level** with detailed explanations and real examples. 💡

---

## 💽 **25. File Handling in Java**

Java provides the `java.io` and `java.nio.file` packages for file operations like creating, reading, writing, updating, and deleting files.

---

## 🔧 Key Classes in File Handling:

| Class            | Purpose                                |
| ---------------- | -------------------------------------- |
| `File`           | Represent a file or directory path     |
| `FileWriter`     | Write character data to a file         |
| `FileReader`     | Read character data from a file        |
| `BufferedWriter` | Efficient writing of characters        |
| `BufferedReader` | Efficient reading of characters        |
| `PrintWriter`    | Write formatted text to a file         |
| `Scanner`        | Read file line-by-line or word-by-word |
| `Files` (NIO)    | High-level operations on files         |

---

### ✅ 1. **Creating a File using `File`**

```java
import java.io.File;
import java.io.IOException;

public class CreateFile {
    public static void main(String[] args) {
        File file = new File("myfile.txt");

        try {
            if (file.createNewFile()) {
                System.out.println("✅ File created: " + file.getName());
            } else {
                System.out.println("ℹ️ File already exists.");
            }
        } catch (IOException e) {
            System.out.println("❌ An error occurred.");
            e.printStackTrace();
        }
    }
}
```

> 💡 `createNewFile()` returns `true` only if the file didn't exist.

---

### ✍️ 2. **Writing to File using `FileWriter`**

```java
import java.io.FileWriter;
import java.io.IOException;

public class WriteFile {
    public static void main(String[] args) {
        try {
            FileWriter writer = new FileWriter("myfile.txt");
            writer.write("Java File Handling is powerful!\nWelcome to mastery.");
            writer.close();
            System.out.println("✅ Successfully wrote to file.");
        } catch (IOException e) {
            System.out.println("❌ Write error.");
            e.printStackTrace();
        }
    }
}
```

---

### 📖 3. **Reading from File using `FileReader`**

```java
import java.io.FileReader;
import java.io.IOException;

public class ReadFile {
    public static void main(String[] args) {
        try {
            FileReader reader = new FileReader("myfile.txt");
            int character;
            while ((character = reader.read()) != -1) {
                System.out.print((char) character);
            }
            reader.close();
        } catch (IOException e) {
            System.out.println("❌ Read error.");
            e.printStackTrace();
        }
    }
}
```

---

### 📚 4. **Using `BufferedReader` for Line-by-Line Reading**

```java
import java.io.*;

public class BufferedRead {
    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader("myfile.txt"));
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println("📄 " + line);
            }
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

### 🖨 5. **Using `PrintWriter` for Formatted Output**

```java
import java.io.PrintWriter;
import java.io.IOException;

public class PrintWriterExample {
    public static void main(String[] args) {
        try {
            PrintWriter pw = new PrintWriter("formatted.txt");
            pw.println("Name: John");
            pw.printf("Balance: %.2f", 1500.75);
            pw.close();
            System.out.println("✅ Written with formatting");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

### 🔍 6. **Reading using `Scanner` (Simpler Line/Word Read)**

```java
import java.io.File;
import java.util.Scanner;

public class ScannerRead {
    public static void main(String[] args) {
        try {
            File f = new File("myfile.txt");
            Scanner sc = new Scanner(f);
            while (sc.hasNextLine()) {
                System.out.println("➡ " + sc.nextLine());
            }
            sc.close();
        } catch (Exception e) {
            System.out.println("❌ File not found");
        }
    }
}
```

---

### 🗑 7. **Delete File**

```java
File file = new File("myfile.txt");
if (file.delete()) {
    System.out.println("🗑 File deleted: " + file.getName());
} else {
    System.out.println("❌ Deletion failed.");
}
```

---

### 📂 8. **File Methods (Useful Utilities)**

```java
File file = new File("myfile.txt");
System.out.println("📁 File name: " + file.getName());
System.out.println("📏 Length: " + file.length());
System.out.println("🛣 Absolute Path: " + file.getAbsolutePath());
System.out.println("✏ Writable: " + file.canWrite());
System.out.println("👓 Readable: " + file.canRead());
```

---

## 🧪 Best Practices

| Best Practice                  | Description                                     |
| ------------------------------ | ----------------------------------------------- |
| Always close files             | Prevents memory leaks and ensures data is saved |
| Use `try-with-resources`       | Auto closes streams                             |
| Prefer `BufferedWriter/Reader` | More efficient than basic writer/reader         |
| Handle exceptions properly     | Never ignore `IOException`                      |
| Use `Files` API for NIO2       | Newer, flexible, and supports streams and paths |

---

### ✅ Mastery Tip: Try-With-Resources

```java
try (BufferedWriter bw = new BufferedWriter(new FileWriter("data.txt"))) {
    bw.write("Master level Java");
} catch (IOException e) {
    e.printStackTrace();
}
```

✔ Automatically closes `BufferedWriter`, even if an exception occurs.

---




Let's dive deep into **Multithreading** in Java — a crucial concept for building high-performance applications.

---

## ⏱ **26. Multithreading – Mastery-Level Explanation**

Multithreading allows concurrent execution of two or more parts (threads) of a program for maximum CPU utilization. Java provides built-in support through the `Thread` class and `Runnable` interface.

---

### 🔧 **Key Concepts:**

| Concept               | Description                                            |
| --------------------- | ------------------------------------------------------ |
| **Thread**            | A lightweight subprocess, smallest unit of execution   |
| **Multithreading**    | Ability to run multiple threads simultaneously         |
| **Concurrency**       | Tasks appear to run at the same time                   |
| **Parallelism**       | Tasks actually run at the same time on multi-core CPUs |
| **Context Switching** | CPU switches between threads rapidly                   |

---

## ✅ Ways to Create Threads

### ➤ **1. By Extending Thread Class**

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        t1.start(); // Don't use t1.run()
        t2.start();
    }
}
```

📌 **Why use `start()` not `run()`?**

* `start()` creates a new thread and calls `run()`.
* `run()` only behaves like a normal method call.

---

### ➤ **2. By Implementing Runnable Interface**

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable thread: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        Thread t2 = new Thread(new MyRunnable());
        t1.start();
        t2.start();
    }
}
```

✅ Prefer `Runnable` when you want to extend another class, since Java doesn't support multiple inheritance.

---

## 🔄 **Thread Lifecycle**

| State          | Method Example             |
| -------------- | -------------------------- |
| **New**        | `Thread t = new Thread();` |
| **Runnable**   | `t.start();`               |
| **Running**    | CPU picks the thread       |
| **Blocked**    | Waiting for resource       |
| **Waiting**    | `join()`, `sleep()`        |
| **Terminated** | run() method ends          |

---

## ⚙️ **Important Thread Methods**

| Method          | Purpose                          |
| --------------- | -------------------------------- |
| `start()`       | Starts the thread                |
| `run()`         | Contains the logic               |
| `sleep(ms)`     | Pauses thread                    |
| `join()`        | Waits for other thread to finish |
| `isAlive()`     | Checks if thread is running      |
| `yield()`       | Allows other threads to execute  |
| `setPriority()` | Sets thread priority (1 to 10)   |

---

### ➤ Example: `sleep()`, `join()`

```java
class SleepJoinDemo extends Thread {
    public void run() {
        for(int i = 1; i <= 3; i++) {
            try { Thread.sleep(500); } 
            catch (InterruptedException e) { System.out.println(e); }
            System.out.println(i);
        }
    }

    public static void main(String args[]) throws InterruptedException {
        SleepJoinDemo t1 = new SleepJoinDemo();
        SleepJoinDemo t2 = new SleepJoinDemo();
        t1.start();
        t1.join();  // Main thread waits for t1 to finish
        t2.start();
    }
}
```

---

## 🔐 **Thread Synchronization (Avoiding Race Condition)**

When multiple threads access the same resource, data inconsistency can occur. Java provides:

### ➤ `synchronized` keyword

```java
class Counter {
    int count = 0;

    public synchronized void increment() {
        count++;
    }
}

class SyncDemo extends Thread {
    Counter c;

    SyncDemo(Counter c) {
        this.c = c;
    }

    public void run() {
        for (int i = 0; i < 1000; i++)
            c.increment();
    }

    public static void main(String[] args) throws Exception {
        Counter c = new Counter();
        SyncDemo t1 = new SyncDemo(c);
        SyncDemo t2 = new SyncDemo(c);
        t1.start(); t2.start();
        t1.join(); t2.join();
        System.out.println("Final Count: " + c.count);
    }
}
```

📌 Without `synchronized`, result may be inconsistent due to race conditions.

---

## 🛠 Thread Priorities

```java
Thread t1 = new Thread(() -> System.out.println("Running"));
t1.setPriority(Thread.MAX_PRIORITY); // 10
```

⚠️ Thread priority is **not guaranteed** to affect thread scheduling.

---

## 💡 Thread Grouping

```java
ThreadGroup group = new ThreadGroup("MyGroup");
Thread t1 = new Thread(group, new MyRunnable());
System.out.println(group.getName()); // MyGroup
```

---

## ✅ Advantages of Multithreading

* Efficient CPU utilization
* Better resource sharing
* Improved performance for I/O-bound operations
* Simpler asynchronous programming

---

## 🚫 Disadvantages

* Complex debugging
* Risk of deadlocks
* Data inconsistency if not synchronized

---

## 🧠 Pro-Level Tips

* Always prefer `Runnable` over `Thread` inheritance.
* Use `Executors` for thread pooling.
* Prefer `Atomic` classes or `ReentrantLock` for complex synchronization.
* Minimize shared mutable state between threads.

---

Would you like to go deeper into:

* 🔄 `ExecutorService` and Thread Pools?
* 🧵 `synchronized` blocks vs `Lock` interface?
* 🕸 Real-world multithreading use cases like Web Servers, Chat Apps?




Let's now dive *deeply and professionally* into the **core methods of Java Multithreading** – to truly master `start()`, `run()`, `sleep()`, `join()`, and `synchronized`. Each method is essential for managing thread behavior and controlling execution order and synchronization.

---

## ✅ **1. `start()` Method** – *Start a New Thread*

### 🔷 Purpose:

* Initiates a **new thread** of execution.
* Internally calls the `run()` method **on a new call stack**.

### ⚠️ Common Mistake:

Calling `run()` directly does **not** start a new thread – it runs like a normal method.

### ✅ Syntax:

```java
Thread t = new MyThread();
t.start(); // Correct
```

### ❌ Incorrect:

```java
t.run(); // Runs on main thread - NOT multithreading
```

### ✅ Example:

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Running on thread: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // creates a new thread
        System.out.println("Main thread: " + Thread.currentThread().getName());
    }
}
```

---

## ✅ **2. `run()` Method** – *Thread Logic Body*

### 🔷 Purpose:

* Contains the **task to be executed** by the thread.
* Called **indirectly** when `start()` is used.

### ✅ Example:

```java
public void run() {
    System.out.println("Thread task");
}
```

### 🔥 Expert Tip:

* Override `run()` for custom logic.
* Never call `run()` manually unless for unit testing or sequential logic.

---

## ✅ **3. `sleep()` Method** – *Pause Thread Temporarily*

### 🔷 Purpose:

* Pauses **current thread execution** for a specified time.
* Thread remains **Alive** but **Not Runnable**.

### ✅ Syntax:

```java
Thread.sleep(milliseconds);
```

### ⚠️ Throws:

* `InterruptedException` → must use `try-catch`.

### ✅ Example:

```java
class SleepExample extends Thread {
    public void run() {
        for (int i = 1; i <= 3; i++) {
            try {
                System.out.println("Sleeping: " + i);
                Thread.sleep(1000); // sleep 1 second
            } catch (InterruptedException e) {
                System.out.println("Interrupted");
            }
        }
    }

    public static void main(String[] args) {
        SleepExample t = new SleepExample();
        t.start();
    }
}
```

---

## ✅ **4. `join()` Method** – *Wait for Thread to Finish*

### 🔷 Purpose:

* **Pauses current thread** until the specified thread completes.
* Ensures ordered execution.

### ✅ Syntax:

```java
thread.join(); // Main thread waits for this thread
```

### 🔥 Use Case:

* When one thread’s result is required before continuing execution.

### ✅ Example:

```java
class JoinExample extends Thread {
    public void run() {
        for (int i = 1; i <= 3; i++) {
            try {
                Thread.sleep(500);
                System.out.println("Child thread: " + i);
            } catch (Exception e) { }
        }
    }

    public static void main(String args[]) throws InterruptedException {
        JoinExample t1 = new JoinExample();
        JoinExample t2 = new JoinExample();
        t1.start();
        t1.join(); // Main waits until t1 completes
        t2.start();
    }
}
```

---

## ✅ **5. `synchronized` Keyword** – *Prevent Race Conditions*

### 🔷 Purpose:

* Ensures **mutual exclusion**: only one thread accesses a block of code or method at a time.
* Used when multiple threads **share a resource**.

---

### 🔹 Two Forms of Synchronization:

#### ➤ A. **Synchronized Method**

Locks the **object** (`this`) for all synchronized methods.

```java
class Shared {
    synchronized void printCount() {
        for (int i = 1; i <= 3; i++) {
            System.out.println(Thread.currentThread().getName() + " - Count: " + i);
        }
    }
}
```

---

#### ➤ B. **Synchronized Block**

Locks only a **portion** of the code with a specific object lock.

```java
class Shared {
    void printData() {
        synchronized(this) {
            System.out.println(Thread.currentThread().getName() + " is running...");
        }
    }
}
```

---

### 🔥 Real-World Example of `synchronized`:

```java
class Counter {
    int count = 0;

    public synchronized void increment() {
        count++;
    }
}

class SyncDemo extends Thread {
    Counter c;

    SyncDemo(Counter c) {
        this.c = c;
    }

    public void run() {
        for (int i = 0; i < 1000; i++) {
            c.increment();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Counter c = new Counter();
        SyncDemo t1 = new SyncDemo(c);
        SyncDemo t2 = new SyncDemo(c);

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Final count: " + c.count);
    }
}
```

✅ Without `synchronized`, final count may be incorrect due to **race condition**.

---

## 🔐 Pro Tip: Static Synchronization

```java
synchronized static void display() {
    // locks on the class object, not instance
}
```

---

## 💎 Summary Table

| Method         | Role                     | Throws Exception?        | Use Case               |
| -------------- | ------------------------ | ------------------------ | ---------------------- |
| `start()`      | Starts a new thread      | ❌                        | Begin thread execution |
| `run()`        | Contains thread logic    | ❌                        | Thread task logic      |
| `sleep(ms)`    | Pause thread temporarily | ✅ `InterruptedException` | Timer, Delays          |
| `join()`       | Wait for another thread  | ✅ `InterruptedException` | Ordered execution      |
| `synchronized` | Locks code/resource      | ❌                        | Avoid race condition   |

---



Here's a **deep, pro-level to mastery-level explanation** of **Java 8 Features**, focusing on:

---

## 🖥 **27. Java 8 Features**

---

### ✅ 1. **Lambda Expressions**

**Purpose**: Provide a clear and concise way to represent a method interface using an expression.

#### 🔹 Syntax:

```java
(parameters) -> expression
```

#### 🔹 Example:

```java
@FunctionalInterface
interface Operation {
    int operate(int a, int b);
}

public class LambdaExample {
    public static void main(String[] args) {
        Operation add = (a, b) -> a + b;
        Operation mul = (a, b) -> a * b;

        System.out.println("Addition: " + add.operate(10, 5));
        System.out.println("Multiplication: " + mul.operate(10, 5));
    }
}
```

**🧠 Mastery Insight**:

* Lambdas eliminate anonymous inner classes.
* Great for **event handling**, **threading**, and **stream operations**.
* Can be used anywhere functional interfaces are accepted.

---

### ✅ 2. **Functional Interfaces**

**Definition**: An interface with exactly **one abstract method**.

```java
@FunctionalInterface
interface Printer {
    void print(String msg);
}
```

**Java provides built-in ones:**

* `Predicate<T>`
* `Function<T,R>`
* `Supplier<T>`
* `Consumer<T>`
* `Runnable`, `Callable`

#### 🔹 Example:

```java
import java.util.function.Predicate;

public class FunctionalDemo {
    public static void main(String[] args) {
        Predicate<String> isLong = s -> s.length() > 5;
        System.out.println(isLong.test("Mastery")); // true
    }
}
```

**🧠 Mastery Insight**:

* Annotate with `@FunctionalInterface` to enforce functional contract.
* Enables **lambda usage**, **method references**, and **stream processing**.

---

### ✅ 3. **Stream API**

**Purpose**: Process collections **in a functional style** (filter, map, reduce, etc.).

#### 🔹 Example:

```java
import java.util.*;
import java.util.stream.*;

public class StreamDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Jaya", "Alice", "Ajay");

        List<String> result = names.stream()
            .filter(n -> n.startsWith("J"))
            .map(String::toUpperCase)
            .sorted()
            .collect(Collectors.toList());

        System.out.println(result); // [JAYA, JOHN]
    }
}
```

#### 🔹 Common Stream Ops:

* `filter()`
* `map()`
* `sorted()`
* `collect()`
* `forEach()`
* `reduce()`

#### 🔹 Parallel Streams:

```java
list.parallelStream().forEach(...);
```

**🧠 Mastery Insight**:

* Streams are **lazy**, efficient, and do **not mutate source**.
* Prefer **parallelStream()** for CPU-intensive tasks on large data.

---

### ✅ 4. **Default & Static Methods in Interface**

Before Java 8, interfaces could **only declare abstract methods**.

#### 🔹 Java 8 introduces:

* `default` methods with implementation.
* `static` methods inside interfaces.

```java
interface Shape {
    void draw();

    default void message() {
        System.out.println("Drawing a shape");
    }

    static void staticUtil() {
        System.out.println("Static method in interface");
    }
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Shape s = new Circle();
        s.draw();
        s.message();
        Shape.staticUtil();
    }
}
```

**🧠 Mastery Insight**:

* `default` helps evolve interfaces **without breaking existing code**.
* `static` utility methods in interface reduce need for utility classes.

---

## 🧠 Final Mastery Notes:

| Feature              | Key Use Case                               |
| -------------------- | ------------------------------------------ |
| Lambda               | Functional logic, sorting, event handling  |
| Functional Interface | Enables lambda & stream use                |
| Stream API           | Functional processing of collections       |
| Default Method       | Backward compatibility with implementation |
| Static Method        | Interface-level utilities                  |

---



Let's now deeply explore and **master** the next advanced Java topic:

---

## 📊 **28. Functional Programming in Java 8**

Java 8 introduced **functional programming** features like lambdas, method references, and the powerful **Stream API**, enabling a more declarative coding style.

We'll break this down **step by step** into all **key concepts**, with **deep explanations** and **pro-level examples**:

---

### ✅ 1. **What is Functional Programming (FP)?**

Functional programming is a style where **functions are treated as first-class citizens**:

* Can be passed as parameters
* Returned from other functions
* Assigned to variables

FP focuses on:

* **Immutability**
* **Stateless behavior**
* **Pure functions** (no side effects)
* **Declarative code** (what to do, not how)

---

### ✅ 2. **Functional Interfaces**

**Definition**: A functional interface has **only one abstract method**.

💡 *It’s the foundation of lambda expressions.*

#### ✅ Example:

```java
@FunctionalInterface
interface Greeting {
    void sayHello();
}
```

You can implement it using:

```java
Greeting g = () -> System.out.println("Hello, Java!");
g.sayHello();
```

**💎 Pro Tip**: You can also pass it like a method parameter (see Section 5).

---

### ✅ 3. **Lambda Expressions Recap**

```java
(parameters) -> expression
```

#### 🔹 Examples:

```java
// No parameter
Runnable r = () -> System.out.println("Running");

// One parameter
Consumer<String> printer = s -> System.out.println(s);

// Two parameters
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
```

🧠 **Lambdas can replace anonymous classes**, reduce boilerplate, and increase code readability.

---

### ✅ 4. **Built-in Functional Interfaces (java.util.function)**

| Interface       | Method      | Use Case                        |
| --------------- | ----------- | ------------------------------- |
| `Predicate<T>`  | `test(T)`   | Condition checking              |
| `Consumer<T>`   | `accept(T)` | Consumes input, returns nothing |
| `Function<T,R>` | `apply(T)`  | Transforms input to output      |
| `Supplier<T>`   | `get()`     | Supplies value, takes no input  |

#### 🔹 Examples:

```java
Predicate<String> isLong = s -> s.length() > 5;
System.out.println(isLong.test("Mastery")); // true

Consumer<String> display = s -> System.out.println(">> " + s);
display.accept("Hello");

Function<String, Integer> strLen = s -> s.length();
System.out.println(strLen.apply("Java")); // 4

Supplier<Double> random = () -> Math.random();
System.out.println(random.get());
```

---

### ✅ 5. **Passing Functions as Parameters**

Using functional interfaces as method arguments:

```java
@FunctionalInterface
interface Calculator {
    int operate(int a, int b);
}

public class MathUtil {
    static int compute(int a, int b, Calculator op) {
        return op.operate(a, b);
    }

    public static void main(String[] args) {
        System.out.println(compute(10, 5, (x, y) -> x + y)); // 15
        System.out.println(compute(10, 5, (x, y) -> x * y)); // 50
    }
}
```

**🧠 Mastery Insight**:
This is how Java achieves **functional-style composition** similar to JavaScript, Kotlin, or Scala.

---

### ✅ 6. **Method References**

A **shorthand** for lambda expressions when a method already exists.

```java
String::toUpperCase
System.out::println
```

#### 🔹 Example:

```java
List<String> names = Arrays.asList("ajay", "vijay");
names.forEach(System.out::println); // Instead of n -> System.out.println(n)
```

#### Types of Method References:

* **Static Method**: `ClassName::staticMethod`
* **Instance Method of Object**: `obj::instanceMethod`
* **Instance Method of Class**: `ClassName::instanceMethod`
* **Constructor Reference**: `ClassName::new`

#### 🔹 Example with Constructor Reference:

```java
Supplier<List<String>> listSupplier = ArrayList::new;
List<String> list = listSupplier.get(); // New ArrayList
```

---

### ✅ 7. **Composition with `andThen`, `compose`, etc.**

You can **chain functions**:

```java
Function<String, String> trim = s -> s.trim();
Function<String, String> toUpper = s -> s.toUpperCase();

Function<String, String> combined = trim.andThen(toUpper);

System.out.println(combined.apply("   java8  ")); // JAVA8
```

---

### ✅ 8. **Functional Programming with Streams**

Streams allow **functional processing** of collections.

```java
List<String> names = Arrays.asList("Ravi", "Ajay", "Rakesh");

names.stream()
     .filter(n -> n.startsWith("R"))
     .map(String::toUpperCase)
     .forEach(System.out::println);
```

Output:

```
RAVI
RAKESH
```

🧠 **Declarative, readable, and efficient!**

---

### ✅ 9. **Pure Functions and Immutability**

```java
int add(int a, int b) {
    return a + b; // No side-effects, input → output
}
```

In FP:

* No shared mutable state
* Avoid modifying variables or objects (use copies or final)

---

### ✅ 10. **Custom Functional Interface with Streams**

```java
@FunctionalInterface
interface WordFilter {
    boolean isValid(String word);
}

public class App {
    static void printFiltered(List<String> words, WordFilter filter) {
        words.stream().filter(filter::isValid).forEach(System.out::println);
    }

    public static void main(String[] args) {
        List<String> list = List.of("Java", "Python", "Node", "C++");

        printFiltered(list, word -> word.length() > 4);
    }
}
```

---

## 🧠 Mastery Summary Table

| Concept              | Mastery Insight                                            |
| -------------------- | ---------------------------------------------------------- |
| Functional Interface | Enables lambdas & stream-like processing                   |
| Lambda Expressions   | Inline, concise function logic                             |
| Method References    | Shorthand for calling existing methods                     |
| Built-in Interfaces  | Use `Predicate`, `Function`, etc. for common FP needs      |
| Stream API           | Declarative, composable data processing pipeline           |
| Immutability         | Prevent bugs from shared/mutable state                     |
| Pure Functions       | Same input → same output, no side-effects                  |
| Composition          | Build powerful logic chains using `andThen()`, `compose()` |
| Reusability          | Logic as parameters enables cleaner and DRY design         |

---

### 💡 Final Pro Tip:

Functional programming in Java isn't just about syntax—it's about writing **clear, reusable, testable code**. It's **faster to write**, **easier to debug**, and **scales better** in modern systems (microservices, streams, async logic).

---



Here is a **deep, pro-level to mastery-level explanation** of the **Stream API** in Java 8:

---

## 🔄 **29. Stream API (Java 8)**

The **Stream API** in Java 8 provides a modern, declarative approach for processing sequences of data such as collections. It allows developers to **write clean, readable, functional-style** code using **pipelines** of transformations.

---

### ✅ **Why Stream API?**

Before Java 8:

```java
List<String> list = Arrays.asList("apple", "banana", "orange");
for(String s : list){
    if(s.startsWith("a")){
        System.out.println(s);
    }
}
```

With Java 8 Stream:

```java
list.stream().filter(s -> s.startsWith("a")).forEach(System.out::println);
```

✅ **Less code**, more **readability** and **parallelization** support.

---

### 🔧 **Key Concepts**

| Stream Term          | Description                                                                      |
| -------------------- | -------------------------------------------------------------------------------- |
| **Source**           | Data to operate on (e.g. `List`, `Set`, `Map`)                                   |
| **Intermediate Ops** | Returns another stream (e.g. `filter()`, `map()`, `sorted()`)                    |
| **Terminal Ops**     | Ends the stream and produces a result (e.g. `forEach()`, `collect()`, `count()`) |

---

### 🔁 Stream Pipeline Structure

```java
Collection.stream() → Intermediate operations → Terminal operation
```

Example:

```java
list.stream()
    .filter(x -> x > 5)
    .map(x -> x * 2)
    .forEach(System.out::println);
```

---

## ⚙️ Common Stream Methods (Mastery Level)

### 1. `filter(Predicate<T>)` – Filters elements based on a condition

```java
List<Integer> list = Arrays.asList(1, 4, 5, 8);
list.stream().filter(n -> n > 4).forEach(System.out::println);
// Output: 5, 8
```

---

### 2. `map(Function<T, R>)` – Transforms each element

```java
list.stream().map(n -> n * n).forEach(System.out::println);
// Output: 1, 16, 25, 64
```

---

### 3. `sorted()` – Sorts the stream (natural or custom order)

```java
list.stream().sorted().forEach(System.out::println); // Ascending

list.stream()
    .sorted((a, b) -> b - a)
    .forEach(System.out::println); // Descending
```

---

### 4. `distinct()` – Removes duplicates

```java
Stream.of(1, 2, 2, 3, 3).distinct().forEach(System.out::println);
```

---

### 5. `limit(n)` and `skip(n)`

```java
list.stream().limit(3).forEach(System.out::println); // First 3
list.stream().skip(2).forEach(System.out::println);  // Skip first 2
```

---

### 6. `collect()` – Collect results into List, Set, Map etc.

```java
List<Integer> evens = list.stream()
                          .filter(n -> n % 2 == 0)
                          .collect(Collectors.toList());
```

---

### 7. `count()`, `min()`, `max()`, `reduce()`

```java
long c = list.stream().count();
int max = list.stream().max(Integer::compare).get();

int sum = list.stream().reduce(0, (a, b) -> a + b);
```

---

### 🔄 Full Example with Chaining

```java
List<String> names = Arrays.asList("Ram", "Shyam", "Ravi", "Raj");

List<String> result = names.stream()
    .filter(name -> name.startsWith("R"))
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());

System.out.println(result); // [RAJ, RAM, RAVI]
```

---

## 🧠 Advanced Mastery: Parallel Streams

```java
list.parallelStream()
    .filter(n -> n > 100)
    .map(n -> n * 2)
    .forEach(System.out::println);
```

* Used for performance on large data sets
* Splits work across CPU cores using **Fork/Join framework**

---

## 💎 Real-World Mastery Use Case

### Employee Filtering:

```java
class Employee {
    String name;
    int salary;
    Employee(String name, int salary) {
        this.name = name; this.salary = salary;
    }
}

List<Employee> emps = Arrays.asList(
    new Employee("Ram", 40000),
    new Employee("Shyam", 50000),
    new Employee("Ravi", 60000)
);

emps.stream()
    .filter(e -> e.salary > 45000)
    .map(e -> e.name)
    .forEach(System.out::println);

// Output: Shyam, Ravi
```

---

## ✅ Summary Table (For Revision)

| Operation Type    | Methods                                                |
| ----------------- | ------------------------------------------------------ |
| Intermediate      | `filter`, `map`, `sorted`, `distinct`, `limit`, `skip` |
| Terminal          | `forEach`, `collect`, `count`, `reduce`, `anyMatch`    |
| Collection Output | `collect(Collectors.toList())`, etc.                   |
| Parallel Support  | `parallelStream()`                                     |

---



Absolutely! Here's a **deep, professional-to-mastery-level explanation** of **JDBC (Java Database Connectivity)** with **complete breakdown**, **examples**, and **best practices**.

---

## 🌐 **30. JDBC (Java Database Connectivity)**

**JDBC** is the **standard Java API** used to **connect Java applications to relational databases** like MySQL, Oracle, PostgreSQL, etc.

---

### ✅ Why Use JDBC?

* Communicate with databases using SQL from Java
* Perform **CRUD operations** (Create, Read, Update, Delete)
* Secure data using **Prepared Statements**
* Works with all relational databases using appropriate **JDBC drivers**

---

## 🔧 JDBC Architecture

```text
Java App → JDBC API → JDBC Driver → Database
```

---

## 🔑 JDBC Key Classes / Interfaces

| JDBC Class/Interface | Purpose                                          |
| -------------------- | ------------------------------------------------ |
| `DriverManager`      | Manages the database drivers                     |
| `Connection`         | Connects to the database                         |
| `Statement`          | Executes SQL queries                             |
| `PreparedStatement`  | Executes **parameterized** queries (more secure) |
| `ResultSet`          | Stores query results                             |
| `SQLException`       | Handles DB-related exceptions                    |

---

## 🛠 JDBC Step-by-Step Process

### ✅ Step 1: Import JDBC Package

```java
import java.sql.*;
```

---

### ✅ Step 2: Load JDBC Driver (Optional for JDBC 4.0+)

```java
Class.forName("com.mysql.cj.jdbc.Driver"); // Optional in newer versions
```

---

### ✅ Step 3: Establish Connection

```java
String url = "jdbc:mysql://localhost:3306/mydb";
String user = "root";
String pass = "password";

Connection con = DriverManager.getConnection(url, user, pass);
```

---

### ✅ Step 4: Create Statement / PreparedStatement

#### Using `Statement`:

```java
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```

#### Using `PreparedStatement`:

```java
String sql = "SELECT * FROM users WHERE id = ?";
PreparedStatement ps = con.prepareStatement(sql);
ps.setInt(1, 101);
ResultSet rs = ps.executeQuery();
```

---

### ✅ Step 5: Process ResultSet

```java
while (rs.next()) {
    int id = rs.getInt("id");
    String name = rs.getString("name");
    System.out.println(id + ": " + name);
}
```

---

### ✅ Step 6: Close Resources

```java
rs.close();
stmt.close();
con.close();
```

---

## 🧪 Complete Example – JDBC `SELECT`

```java
import java.sql.*;

public class DBSelect {
    public static void main(String[] args) {
        try {
            String url = "jdbc:mysql://localhost:3306/mydb";
            String user = "root";
            String pass = "password";

            Connection con = DriverManager.getConnection(url, user, pass);
            Statement stmt = con.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT * FROM users");

            while (rs.next()) {
                System.out.println(rs.getInt("id") + " - " + rs.getString("name"));
            }

            rs.close();
            stmt.close();
            con.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

---

## 🔐 Example – JDBC `INSERT` using `PreparedStatement`

```java
String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
PreparedStatement ps = con.prepareStatement(sql);
ps.setString(1, "Ravi");
ps.setString(2, "ravi@gmail.com");
int rows = ps.executeUpdate();
System.out.println(rows + " row(s) inserted.");
```

---

## 🧰 JDBC Best Practices (Pro-Level)

| Practice                                            | Description                               |
| --------------------------------------------------- | ----------------------------------------- |
| Use `PreparedStatement`                             | Prevents **SQL Injection**                |
| Always close `Connection`, `Statement`, `ResultSet` | Avoid memory leaks                        |
| Use `try-with-resources`                            | Auto close JDBC objects                   |
| Use `Batch Processing`                              | Improves performance for bulk inserts     |
| Handle `SQLException` properly                      | Print SQL error codes and messages        |
| Avoid hard-coded credentials                        | Use config files or environment variables |

---

## 🔄 try-with-resources Version

```java
try (Connection con = DriverManager.getConnection(url, user, pass);
     PreparedStatement ps = con.prepareStatement("SELECT * FROM users")) {

    ResultSet rs = ps.executeQuery();
    while (rs.next()) {
        System.out.println(rs.getString("name"));
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

---

## 🔥 Advanced Pro Features

### ✅ 1. Batch Processing

```java
PreparedStatement ps = con.prepareStatement("INSERT INTO students(name) VALUES(?)");
for (int i = 0; i < 100; i++) {
    ps.setString(1, "Student_" + i);
    ps.addBatch();
}
ps.executeBatch();
```

---

### ✅ 2. Transaction Management

```java
con.setAutoCommit(false);

try {
    // multiple DB operations
    con.commit(); // all succeed
} catch (Exception e) {
    con.rollback(); // revert all changes
}
```

---

### ✅ 3. CallableStatement (Stored Procedure)

```java
CallableStatement cs = con.prepareCall("{call getUser(?)}");
cs.setInt(1, 101);
ResultSet rs = cs.executeQuery();
```

---

## 🧠 Summary Table

| JDBC Component      | Use                          |
| ------------------- | ---------------------------- |
| `Connection`        | Connect to DB                |
| `Statement`         | Run static queries           |
| `PreparedStatement` | Run dynamic queries securely |
| `ResultSet`         | Hold results of `SELECT`     |
| `CallableStatement` | Call stored procedures       |
| `SQLException`      | Handle DB errors             |
| `Batch Processing`  | Fast inserts/updates         |
| `Transactions`      | Maintain data integrity      |

---



You're asking for a **mastery-level explanation** of Java’s **Inner Classes** – one of the most conceptually rich and powerful features of Java's OOP model.

---

## 🧱 **31. Inner Classes in Java**

> An **inner class** is a class declared **inside another class**. It logically groups classes that are only used in one place, enhancing **encapsulation** and **readability**.

---

### 🧠 Why Use Inner Classes?

* To logically group helper classes used only by the outer class.
* To **access private members** of the outer class.
* To **encapsulate behaviors** tightly coupled with the enclosing class.
* To implement **callbacks**, **event listeners**, **short-lived logic**, etc.

---

## 🔥 Types of Inner Classes in Java

| Type                 | Declared In                       | Can Access Outer Instance?             | static Allowed? |
| -------------------- | --------------------------------- | -------------------------------------- | --------------- |
| **Non-static inner** | Inside a class                    | ✅ Yes                                  | ❌ No            |
| **Static nested**    | Inside a class                    | ❌ No (unless outer instance is passed) | ✅ Yes           |
| **Local inner**      | Inside a method/block/constructor | ✅ Yes                                  | ❌ No            |
| **Anonymous inner**  | Inside a method or as argument    | ✅ Yes                                  | ❌ No            |

---

## 🔎 1. **Non-static Inner Class (Member Inner Class)**

### 📘 Definition:

Declared inside a class without the `static` modifier. It has access to **all members** (including `private`) of the outer class.

### ✅ Example:

```java
class Outer {
    private String outerField = "Outer";

    class Inner {
        void display() {
            System.out.println("Access: " + outerField);
        }
    }
}

public class Test {
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner(); // create inner via outer
        inner.display();
    }
}
```

### 📌 Use Case:

* Access private members of the outer class.
* Used when the **inner class is closely associated** with outer logic.

---

## 🧊 2. **Static Nested Class**

### 📘 Definition:

Declared inside a class **with the `static` keyword**. Cannot access non-static members of the outer class directly.

### ✅ Example:

```java
class Outer {
    static int data = 50;

    static class StaticInner {
        void show() {
            System.out.println("Data is: " + data);
        }
    }
}

public class Test {
    public static void main(String[] args) {
        Outer.StaticInner obj = new Outer.StaticInner(); // direct access
        obj.show();
    }
}
```

### 📌 Use Case:

* When the inner class **doesn't need access** to instance variables/methods.
* Makes your program more **memory-efficient**.

---

## 🌐 3. **Local Inner Class**

### 📘 Definition:

Defined **within a method, constructor, or block**. Scope is **limited to that block**. It **can access final or effectively final variables** of the enclosing method.

### ✅ Example:

```java
class Outer {
    void outerMethod() {
        int num = 10; // must be effectively final

        class LocalInner {
            void show() {
                System.out.println("Number is: " + num);
            }
        }

        LocalInner li = new LocalInner();
        li.show();
    }
}

public class Test {
    public static void main(String[] args) {
        new Outer().outerMethod();
    }
}
```

### 📌 Use Case:

* For **one-time logic** tightly coupled with a method.
* Used in **event-driven** or **multi-threaded** logic.

---

## 👻 4. **Anonymous Inner Class**

### 📘 Definition:

A **class without a name**, declared and instantiated in a **single statement**. Usually used to **override methods** of interface/abstract class for **one-time use**.

### ✅ Example with Interface:

```java
interface Animal {
    void sound();
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Animal() {
            public void sound() {
                System.out.println("Meow");
            }
        };
        a.sound();
    }
}
```

### ✅ Example with Abstract Class:

```java
abstract class Shape {
    abstract void draw();
}

public class Test {
    public static void main(String[] args) {
        Shape s = new Shape() {
            void draw() {
                System.out.println("Drawing Circle");
            }
        };
        s.draw();
    }
}
```

### 📌 Use Case:

* For **short-lived implementations** like event listeners, threads.
* For **Strategy Pattern**, callbacks, or when using **Functional Interfaces** before Java 8.

---

## 🛠 Practical Use Case: Event Listener

```java
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("Clicked!");
    }
});
```

> This is an **anonymous inner class** passed directly where it's needed.

---

## 🎯 Inner Class Mastery Summary Table

| Inner Class Type     | Needs Outer Object | Access Outer Instance Vars | Scope             | Typical Use                  |
| -------------------- | ------------------ | -------------------------- | ----------------- | ---------------------------- |
| **Non-static Inner** | ✅ Yes              | ✅ Yes                      | Whole outer class | Utility/helper logic         |
| **Static Nested**    | ❌ No               | ❌ No                       | Whole outer class | Utility container, constants |
| **Local Inner**      | ✅ Yes              | ✅ Yes                      | Method/block only | Threading, encapsulated task |
| **Anonymous Inner**  | ✅ Yes              | ✅ Yes                      | One-time use      | Event listeners, tasks       |

---

## 🧠 Best Practices (Pro-Level)

* **Prefer static nested classes** when you don’t need access to instance data (to save memory).
* **Use anonymous inner classes** for one-time implementations or event handlers.
* Use **lambda expressions** where possible in Java 8+ for functional-style anonymous classes.

---




Let’s explore **Java Enums** in **mastery-level detail**, with complete explanations, variations, and deep practical examples. Enums in Java are much more powerful than in many other languages — they can have fields, constructors, and methods.

---

## 🧠 **32. Enum in Java – Mastery Level**

### ✅ What is an `enum`?

`enum` is a **special data type** that enables a variable to be a set of predefined constants. It’s commonly used when a variable (like days of the week, months, status, direction) can only take one out of a small set of possible values.

```java
enum Day { MON, TUE, WED }
```

Here, `Day` can only hold `MON`, `TUE`, or `WED`.

---

## 🔍 Why Enums?

* Enums provide **type safety**: you can’t assign invalid values.
* Enums are **objects**, not simple constants.
* Enums can have:

  * Fields
  * Constructors
  * Methods
  * Implement Interfaces

---

## 🧪 1. **Basic Enum Usage**

```java
enum Direction {
    NORTH, SOUTH, EAST, WEST
}

public class Test {
    public static void main(String[] args) {
        Direction dir = Direction.NORTH;
        System.out.println(dir); // Output: NORTH
    }
}
```

---

## 🔁 2. **Enum with `switch` Statement**

```java
enum Status {
    SUCCESS, FAILURE, PENDING
}

public class App {
    public static void main(String[] args) {
        Status s = Status.PENDING;

        switch (s) {
            case SUCCESS -> System.out.println("Operation succeeded");
            case FAILURE -> System.out.println("Operation failed");
            case PENDING -> System.out.println("Operation pending");
        }
    }
}
```

---

## 🧱 3. **Enum with Fields, Constructor, Methods**

Enums are full classes! You can add:

* Instance variables
* A constructor (called automatically for each constant)
* Getter methods

```java
enum Planet {
    MERCURY(3.303e+23, 2.4397e6),
    EARTH(5.976e+24, 6.37814e6);

    private final double mass;   // in kilograms
    private final double radius; // in meters

    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }

    double surfaceGravity() {
        final double G = 6.67300E-11;
        return G * mass / (radius * radius);
    }

    public double mass() { return mass; }
    public double radius() { return radius; }
}
```

### 🌍 Usage:

```java
public class TestPlanet {
    public static void main(String[] args) {
        for (Planet p : Planet.values()) {
            System.out.println(p + ": Gravity = " + p.surfaceGravity());
        }
    }
}
```

---

## 🧩 4. **Enum with Interface**

Enums can implement interfaces (not extend classes).

```java
interface Printable {
    void print();
}

enum Color implements Printable {
    RED {
        public void print() { System.out.println("Red Color"); }
    },
    BLUE {
        public void print() { System.out.println("Blue Color"); }
    }
}

public class Demo {
    public static void main(String[] args) {
        Color.RED.print();   // Red Color
        Color.BLUE.print();  // Blue Color
    }
}
```

---

## 🔄 5. **Enum Methods: `.values()`, `.valueOf()`, `.ordinal()`**

| Method      | Purpose                                 |
| ----------- | --------------------------------------- |
| `values()`  | Returns all constants of the enum       |
| `valueOf()` | Returns enum constant of specified name |
| `ordinal()` | Returns index of the constant (0-based) |

```java
public class TestEnumMethods {
    public static void main(String[] args) {
        for (Day d : Day.values()) {
            System.out.println(d + " at position " + d.ordinal());
        }

        Day today = Day.valueOf("MON");
        System.out.println("Today is: " + today);
    }
}
```

---

## 🔐 6. **Enum inside a Class**

```java
public class Car {
    enum Type { PETROL, DIESEL, ELECTRIC }
}

public class Main {
    public static void main(String[] args) {
        Car.Type t = Car.Type.ELECTRIC;
        System.out.println(t);
    }
}
```

---

## ❗ 7. **Enum vs Constants (`static final`)**

| Feature                 | `enum` | `static final` constants      |
| ----------------------- | ------ | ----------------------------- |
| Type Safe               | ✅      | ❌ (can assign any string/int) |
| Namespace Control       | ✅      | ❌                             |
| Can have methods/fields | ✅      | ❌                             |
| Suitable for switch()   | ✅      | ✅                             |

---

## 🚀 Summary

| Feature                     | Enum                               |
| --------------------------- | ---------------------------------- |
| Type                        | Class (extends `java.lang.Enum`)   |
| Inherits                    | Implicitly inherits from `Enum<T>` |
| Constructor                 | Private (implicit)                 |
| Can have fields and methods | ✅ Yes                              |
| Can override methods        | ✅ Yes                              |
| Can use in `switch`         | ✅ Yes                              |
| Implements interfaces       | ✅ Yes                              |

---

## 🧠 Real-Life Use Case

**Status Enum for API:**

```java
enum APIStatus {
    OK(200, "Success"),
    NOT_FOUND(404, "Not Found"),
    ERROR(500, "Internal Error");

    int code;
    String message;

    APIStatus(int code, String message) {
        this.code = code;
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    public int getCode() {
        return code;
    }
}
```

```java
public class APITest {
    public static void main(String[] args) {
        APIStatus status = APIStatus.NOT_FOUND;
        System.out.println("Code: " + status.getCode());
        System.out.println("Message: " + status.getMessage());
    }
}
```

---




Let’s master Java **Annotations** in-depth — including the **core built-in annotations** and how to define and use **custom annotations** like a pro. We'll explore all syntax, behind-the-scenes behavior, compiler impacts, and practical examples.

---

## 🏷 **33. Java Annotations – Deep Mastery Level Guide**

### ✅ What is an Annotation?

An **annotation** is a **special marker** in Java that provides **metadata** about your code. It does **not affect program logic directly**, but is used by:

* **Compiler** (e.g., `@Override`)
* **Tools** (e.g., documentation generators, frameworks like Spring, Hibernate)
* **Reflection-based programs** (e.g., custom annotation processors)

---

## 📌 Syntax of Annotations

```java
@AnnotationName
@AnnotationName(value)
@AnnotationName(key1 = value1, key2 = value2)
```

---

## 🔹 **1. `@Override` – Method Overriding Checker**

### ✅ Purpose:

Indicates a method is **intended to override** a method in the superclass.

```java
class A {
    void show() {
        System.out.println("A");
    }
}

class B extends A {
    @Override
    void show() {
        System.out.println("B");
    }
}
```

### ❌ Without `@Override`, mistakes go undetected:

```java
class C extends A {
    // Typo: compiles without override
    void shoo() { System.out.println("Error!"); }
}
```

✅ With `@Override`, compile-time error will be thrown.

---

## 🔹 **2. `@Deprecated` – Marks Element as Old**

### ✅ Purpose:

Marks method/class/field as **discouraged** for use, meaning it may be removed in future.

```java
class OldCode {
    @Deprecated
    void oldMethod() {
        System.out.println("Use newMethod()");
    }

    void newMethod() {
        System.out.println("This is recommended");
    }
}

public class Demo {
    public static void main(String[] args) {
        OldCode obj = new OldCode();
        obj.oldMethod(); // Warning: Deprecated method
    }
}
```

➡️ IDE and compiler will show **warning**.

---

## 🔹 **3. `@FunctionalInterface` – One Abstract Method Rule**

### ✅ Purpose:

Ensures that the interface has **only one abstract method** (used in **Lambdas**).

```java
@FunctionalInterface
interface Greet {
    void sayHello();
    
    // void sayBye(); ❌ Compile error if uncommented
}
```

### ✅ Usage with Lambda:

```java
Greet g = () -> System.out.println("Hello");
g.sayHello();
```

➡️ Forces proper use in **functional programming** style.

---

## 🔹 **4. `@SuppressWarnings` – Ignore Specific Compiler Warnings**

### ✅ Purpose:

Suppresses specific **compiler warnings** like:

* `unchecked` (generics)
* `deprecation`
* `unused`

```java
import java.util.*;

public class SuppressDemo {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        List list = new ArrayList();  // raw type
        list.add("Hello");
        System.out.println(list.get(0));
    }
}
```

➡️ Without this, you'll see: *"unchecked or unsafe operations."*

---

## 🔰 Advanced: Custom Annotations (Pro Level)

### ✅ Step 1: Define Custom Annotation

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface MyAnnotation {
    String value();
    int count() default 1;
}
```

* `@Retention(RUNTIME)` – means annotation is available at runtime (for reflection)
* `@Target(METHOD)` – restricts usage to methods

---

### ✅ Step 2: Use Custom Annotation

```java
public class MyService {
    @MyAnnotation(value = "TestMethod", count = 3)
    public void doSomething() {
        System.out.println("Doing something...");
    }
}
```

---

### ✅ Step 3: Read Annotation via Reflection

```java
import java.lang.reflect.*;

public class AnnotationReader {
    public static void main(String[] args) throws Exception {
        Method m = MyService.class.getMethod("doSomething");
        MyAnnotation ann = m.getAnnotation(MyAnnotation.class);

        System.out.println("Value: " + ann.value());
        System.out.println("Count: " + ann.count());
    }
}
```

---

## 🧠 Built-in Meta-Annotations

These are used to **define** annotations.

| Meta-Annotation | Purpose                                                      |
| --------------- | ------------------------------------------------------------ |
| `@Retention`    | How long the annotation is retained (SOURCE, CLASS, RUNTIME) |
| `@Target`       | Where the annotation can be applied (METHOD, FIELD, etc.)    |
| `@Documented`   | Includes annotation in JavaDocs                              |
| `@Inherited`    | Allows subclass to inherit annotation                        |

### Example:

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface Entity {
    String name();
}
```

---

## ⚙ Practical Usage in Frameworks

### ✅ Spring Boot

```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String sayHello() {
        return "Hi";
    }
}
```

➡️ `@RestController`, `@GetMapping` are custom annotations with **annotation processors** behind the scenes.

---

## 🎓 Summary Table

| Annotation             | Scope      | Purpose                         |
| ---------------------- | ---------- | ------------------------------- |
| `@Override`            | Method     | Enforces method override        |
| `@Deprecated`          | Any        | Marks code as outdated          |
| `@SuppressWarnings`    | Any        | Hides compiler warnings         |
| `@FunctionalInterface` | Interface  | Ensures single abstract method  |
| `@Retention`           | Annotation | Retention policy for annotation |
| `@Target`              | Annotation | Allowed locations               |

---

## 🧪 Practice & Challenges

Would you like:

* ✅ 20 annotation-based interview questions?
* ✅ A mini project using custom annotations?
* ✅ Real-world custom annotation (like `@LoginRequired`)?





Let’s now **master** one of the most critical and interview-favorite Java topics:

# 🧊 **34. Serialization / Deserialization** — **Deep Explanation + Pro-Level Examples**

---

## 🔍 What is Serialization?

**Serialization** is the process of **converting a Java object into a byte stream**, so that it can be:

* Saved to a file
* Sent over a network
* Stored in databases
* Cached

> The opposite process — reconstructing the object from the byte stream — is called **Deserialization**.

---

## 📦 Real-Life Use Cases:

| Use Case           | Description                                          |
| ------------------ | ---------------------------------------------------- |
| File Storage       | Save application objects to disk                     |
| Network Transfer   | Send objects over TCP sockets / APIs                 |
| Caching            | Serialize objects to reduce recomputation            |
| RMI                | Remote Method Invocation in distributed apps         |
| Session Management | Storing sessions in web apps (e.g., Servlet session) |

---

## 🧪 Key Interface: `java.io.Serializable`

### ✅ To serialize an object, the class **must implement** the `Serializable` interface.

```java
import java.io.Serializable;

public class Student implements Serializable {
    int id;
    String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
```

> `Serializable` is a **marker interface** → No methods, just indicates to the JVM: *“This class is safe to serialize.”*

---

## 🔄 Serialization – Writing Object to File

```java
import java.io.*;

public class SerializeDemo {
    public static void main(String[] args) throws Exception {
        Student s = new Student(101, "Amit");

        FileOutputStream fileOut = new FileOutputStream("student.ser");
        ObjectOutputStream out = new ObjectOutputStream(fileOut);

        out.writeObject(s);
        out.close();
        fileOut.close();

        System.out.println("Object has been serialized");
    }
}
```

---

## 🔁 Deserialization – Reading Object from File

```java
import java.io.*;

public class DeserializeDemo {
    public static void main(String[] args) throws Exception {
        FileInputStream fileIn = new FileInputStream("student.ser");
        ObjectInputStream in = new ObjectInputStream(fileIn);

        Student s = (Student) in.readObject();
        in.close();
        fileIn.close();

        System.out.println("Deserialized Object:");
        System.out.println("ID: " + s.id + ", Name: " + s.name);
    }
}
```

---

## 🧠 Advanced Control Topics for Mastery

### 🔹 1. `transient` Keyword

* Used to **exclude a field from serialization**.

```java
class Employee implements Serializable {
    int id;
    transient String password; // not saved

    public Employee(int id, String password) {
        this.id = id;
        this.password = password;
    }
}
```

```java
// After deserialization, password will be null
```

---

### 🔹 2. `serialVersionUID`

* Used to **maintain version control** between serialized data and the class definition.
* If not defined, JVM auto-generates it.

```java
class User implements Serializable {
    private static final long serialVersionUID = 1L;
    int id;
    String name;
}
```

> Helps during **schema evolution**. Without `serialVersionUID`, you may face `InvalidClassException`.

---

### 🔹 3. Custom Serialization Logic

Use `writeObject()` and `readObject()` methods to customize how objects are serialized/deserialized.

```java
private void writeObject(ObjectOutputStream out) throws IOException {
    out.defaultWriteObject();
    // custom logic
}

private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();
    // custom logic
}
```

---

### 🔹 4. Inheritance and Serialization

* If superclass is `Serializable`, subclass is automatically serializable.
* If not, subclass must handle it manually using custom methods.

---

### 🔹 5. Object Graph Serialization

Serialization is **recursive**:

> If an object has references to other serializable objects, they are **also serialized**.

```java
class Address implements Serializable {
    String city;
}

class Person implements Serializable {
    String name;
    Address address;  // must also be serializable
}
```

---

## ⚠️ Common Exceptions

| Exception                  | Reason                                 |
| -------------------------- | -------------------------------------- |
| `NotSerializableException` | Class doesn't implement `Serializable` |
| `InvalidClassException`    | serialVersionUID mismatch              |
| `EOFException`             | Reading more objects than were written |
| `StreamCorruptedException` | Stream is corrupted or reused wrongly  |

---

## 🎯 Real-World Example: Send Object via Socket

```java
// On Sender Side
ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
out.writeObject(new Student(101, "Raj"));
```

```java
// On Receiver Side
ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
Student s = (Student) in.readObject();
```

---

## 🧩 Interview-Level Deep Points

| Topic                          | Explanation                                                                             |
| ------------------------------ | --------------------------------------------------------------------------------------- |
| Serializable vs Externalizable | `Externalizable` gives full control (implements `writeExternal()` and `readExternal()`) |
| serialVersionUID usage         | Always declare manually for consistency                                                 |
| Serialization vs Cloning       | Serialization can persist across JVMs; Cloning is memory-only                           |
| Java 8 & Serialization         | Functional interfaces are not serializable unless marked                                |
| Security Concern               | Serialized data can be tampered; validate before deserializing untrusted data           |

---

## 🧠 Summary

| Concept              | Explanation                               |
| -------------------- | ----------------------------------------- |
| `Serializable`       | Marker interface for object serialization |
| `ObjectOutputStream` | Used to write object                      |
| `ObjectInputStream`  | Used to read object                       |
| `transient`          | Prevents field from being serialized      |
| `serialVersionUID`   | Ensures consistent deserialization        |
| Custom Serialization | Done via `writeObject()` / `readObject()` |
| Externalizable       | Complete control of serialization logic   |

---




Let's break down each of the **Important Java Keywords** with **deep explanations** and **mastery-level examples**:

---

## ✅ `this`

Refers to the current object of a class.

### 🔸 Use Cases:

* To resolve **naming conflicts**.
* To call **current class methods or constructors**.

### 🔹 Example:

```java
class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;           // resolves variable shadowing
        this.name = name;
    }

    void show() {
        System.out.println(this.name + " - " + this.id); // calls current object’s field
    }
}
```

---

## ✅ `super`

Refers to the **parent class** (superclass) of the current object.

### 🔸 Use Cases:

* To call **parent class constructor**
* To access **parent class methods or variables**.

### 🔹 Example:

```java
class A {
    int x = 10;
    void display() { System.out.println("Class A"); }
}

class B extends A {
    int x = 20;

    void show() {
        System.out.println(super.x); // accesses A’s x
        super.display();             // calls A’s method
    }
}
```

---

## ✅ `static`

Used for **class-level** members shared among all objects.

### 🔸 Use Cases:

* Memory-efficient shared members
* Utility methods (e.g., `Math.pow()`)

### 🔹 Example:

```java
class Counter {
    static int count = 0;

    Counter() {
        count++;
        System.out.println("Object #" + count);
    }
}
```

---

## ✅ `final`

Used to create **constants**, prevent **method overriding**, and **class inheritance**.

### 🔹 Example:

```java
final int MAX = 100;           // constant
final class A {}               // cannot be extended
class B {
    final void show() {}       // cannot be overridden
}
```

---

## ✅ `new`

Used to **create new objects** or **allocate memory**.

### 🔹 Example:

```java
String s = new String("Hello");
Scanner sc = new Scanner(System.in);
```

---

## ✅ `return`

Used to return a value from a method or terminate a method early.

### 🔹 Example:

```java
int add(int a, int b) {
    return a + b;
}
```

---

## ✅ `break`

Used to **terminate a loop** or `switch` block early.

### 🔹 Example:

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) break;
    System.out.println(i);
}
```

---

## ✅ `continue`

Skips the **current iteration** and jumps to the next loop iteration.

### 🔹 Example:

```java
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) continue;
    System.out.println(i); // prints only odd numbers
}
```

---

## ✅ `instanceof`

Checks if an object is an **instance of a class** (or subclass).

### 🔹 Example:

```java
String s = "Java";
System.out.println(s instanceof String); // true
```

---

## ✅ `synchronized`

Ensures that only **one thread at a time** can execute a block/method.

### 🔹 Example:

```java
class Bank {
    synchronized void withdraw(int amt) {
        // thread-safe logic
    }
}
```

---

## ✅ `transient`

Used to **exclude fields from serialization**.

### 🔹 Example:

```java
class User implements Serializable {
    String name;
    transient String password; // won't be saved
}
```

---

## ✅ `volatile`

Tells the JVM that a variable **may be modified by multiple threads**.

### 🔹 Example:

```java
class Shared {
    volatile boolean flag = false;
}
```

---

## ✅ `assert`

Used for **debugging**: asserts that a condition is true.

### 🔹 Example:

```java
int age = -5;
assert age > 0 : "Age can't be negative!";
```

---

### ✅ Summary Table:

| Keyword        | Purpose                              |
| -------------- | ------------------------------------ |
| `this`         | Current object reference             |
| `super`        | Parent class reference               |
| `static`       | Shared class-level member            |
| `final`        | Constant, no override/inheritance    |
| `new`          | Creates object                       |
| `return`       | Returns value from method            |
| `break`        | Exits loop/switch                    |
| `continue`     | Skips iteration                      |
| `instanceof`   | Type check at runtime                |
| `synchronized` | Thread safety                        |
| `transient`    | Skip field in serialization          |
| `volatile`     | Multithread-safe variable visibility |
| `assert`       | Testing/debugging assumptions        |

---




Great! Let’s begin with **master-level explanations** for each Java interview tip topic:

---

## ✅ **1. JVM Architecture** – *How Java runs behind the scenes*

### 🔧 Components of JVM:

1. **Class Loader Subsystem**: Loads `.class` files into memory.
2. **Method Area**: Stores metadata of classes, static variables, etc.
3. **Heap**: Runtime memory for all objects (shared).
4. **Java Stack**: Stores frames for each thread method call (local vars, return address).
5. **PC Register**: Holds current executing instruction for thread.
6. **Native Method Stack**: For native (C/C++) code via JNI.
7. **Execution Engine**:

   * **Interpreter**: Line-by-line execution (slow).
   * **JIT Compiler**: Compiles hot methods to native for speed.
   * **Garbage Collector**: Reclaims memory of unreachable objects.

### 🔄 JVM Flow:

```text
Source (.java) → Compiler → Bytecode (.class) → Class Loader → JVM Memory → Execution Engine
```

---

## 📦 **2. Classloaders** – *Load classes dynamically at runtime*

### Types:

* **Bootstrap ClassLoader**: Loads core Java classes (`rt.jar`).
* **Extension ClassLoader**: Loads `lib/ext` JARs.
* **Application ClassLoader**: Loads classes from your project’s classpath.
* **Custom ClassLoaders**: For dynamic plugins or sandboxing.

### Example:

```java
Class c = Class.forName("java.util.ArrayList");
System.out.println(c.getClassLoader());  // Application ClassLoader
```

---

## ♻️ **3. Garbage Collection** – *Automatic memory management*

### 🔄 GC Phases:

* **Mark**: Identify referenced objects.
* **Sweep/Delete**: Remove unreferenced objects.
* **Compact**: Move live objects together to free up space.

### 💡 JVM GC Algorithms:

* **Serial GC**: Simple, single-threaded (small apps).
* **Parallel GC**: Multi-threaded for young gen.
* **G1 GC (Garbage-First)**: For large apps, low pause time.

### Finalization Example:

```java
protected void finalize() throws Throwable {
    System.out.println("Garbage collected");
}
```

---

## 🧵 **4. Immutable String** – *Why `String` is special in Java*

### 📌 Properties:

* Cannot be changed after creation.
* Stored in **String Constant Pool**.

### 🔒 Advantages:

* Thread-safe.
* Efficient caching (used as Map keys).
* Security (used in file/network operations).

### Example:

```java
String s1 = "Hello";
String s2 = s1;
s1 = s1 + "World";
System.out.println(s2); // Outputs: Hello (not changed)
```

---

## ⚙️ **5. Static Block** – *Runs once during class loading*

### Use cases:

* Initialize static variables
* Logging or DB config loading
* Only executed once per class (before `main()`)

### Example:

```java
class A {
    static {
        System.out.println("Static block runs before main");
    }
    public static void main(String[] args) {
        System.out.println("Main method");
    }
}
```

---

## 🔐 **6. Singleton Pattern** – *One instance only*

### 📌 Why use?

* Memory saving
* Consistent configuration or logging

### Types:

* **Eager Initialization**:

```java
class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return instance; }
}
```

* **Lazy Initialization (Thread-safe)**:

```java
class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) instance = new Singleton();
        return instance;
    }
}
```

---

## 🧵 **7. Thread Lifecycle** – *States of a thread in Java*

### 5 Core States:

1. **New** → created but not started
2. **Runnable** → ready to run
3. **Running** → executing
4. **Blocked/Waiting** → waiting for a lock or signal
5. **Terminated** → finished execution

### Example:

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Running...");
    }
}
public class Test {
    public static void main(String[] args) {
        MyThread t = new MyThread(); // New
        t.start();                   // Runnable → Running
    }
}
```

---





******InterView*******************************************************************************************************************************
Here are **more Java interview and practice questions** with answers — ranging from basic to tricky and advanced concepts:

---

## ✅ **Java Interview Questions with Answers**

### 🔹 1. **What is the difference between `==` and `.equals()` in Java?**

**Answer:**

* `==` compares **references (memory addresses)**.
* `.equals()` compares **object content**.

```java
String a = new String("Hello");
String b = new String("Hello");
System.out.println(a == b);       // false (different references)
System.out.println(a.equals(b));  // true (same content)
```

---

### 🔹 2. **What is the output of this code?**

```java
int a = 5;
System.out.println(a++ + ++a);
```

**Answer:**

* `a++` = 5 (post-increment, uses then increments)
* `++a` = 7 (a was 6, now pre-incremented to 7)
* `5 + 7 = 12`

✅ Output: `12`

---

### 🔹 3. **Can we override a private method in Java?**

**Answer:**
No. Private methods are not visible to subclasses and are not inherited, hence **not overridable**.

---

### 🔹 4. **Why is Java String immutable?**

**Answer:**

* Security (e.g., classpath manipulation)
* Thread-safety
* Caching (interning)
* Prevents accidental modification

---

### 🔹 5. **What will be the output?**

```java
String s1 = "abc";
String s2 = "a" + "b" + "c";
System.out.println(s1 == s2);
```

**Answer:**
✅ Output: `true`

* Because both are **compile-time constants**, stored in the same pool.

---

### 🔹 6. **What is the use of `transient` keyword?**

**Answer:**
Marks a field **not to be serialized**.

```java
transient int password; // won't be saved during serialization
```

---

### 🔹 7. **Explain final, finally, and finalize.**

| Keyword    | Purpose                                 |
| ---------- | --------------------------------------- |
| `final`    | Makes variable/method/class constant    |
| `finally`  | Block always executed in `try` block    |
| `finalize` | Method called before GC destroys object |

---

### 🔹 8. **What is the default value of a boolean variable?**

**Answer:** `false`

---

### 🔹 9. **Can constructor be overridden?**

**Answer:** No, because constructors are not inherited.

---

### 🔹 10. **What is the output?**

```java
List<Integer> list = Arrays.asList(1, 2, 3);
list.set(1, 10);
System.out.println(list);
```

**Answer:** `[1, 10, 3]`
`.set()` replaces element at index.

---

## 💡 **Practice Tricky Output Questions**

### 🔹 11. **Integer Caching**

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b); // true

Integer c = 128;
Integer d = 128;
System.out.println(c == d); // false
```

📌 Java caches `Integer` values from -128 to 127.

---

### 🔹 12. **StringBuilder vs String**

```java
StringBuilder sb = new StringBuilder("A");
sb.append("B");
System.out.println(sb); // AB
```

* `StringBuilder` is **mutable** (String is not).

---

### 🔹 13. **Thread Life Cycle**

**States:**

* New
* Runnable
* Running
* Blocked/Waiting
* Terminated

---

### 🔹 14. **Can we call `run()` directly on Thread?**

**Answer:**
Yes, but it won’t start a new thread — it runs in the **same thread**.

```java
Thread t = new Thread(() -> System.out.println("Run"));
t.run();  // Not a new thread
t.start(); // New thread
```

---

### 🔹 15. **What is the result of this loop?**

```java
for (int i = 0; i < 3; i++) {
    System.out.print(i + " ");
    i++;
}
```

✅ Output: `0 2`

* i increments by 1 in loop and again in `i++` in body.

---
Great! Here's the **next set** of **Java Interview and Practice Questions with Answers** – deeply explained for **pro to mastery level** understanding.

---

## ✅ **Java Interview Questions – Set 2 (Advanced + Tricky)**

---

### 🔹 16. **What is the output?**

```java
public class Test {
    public static void main(String[] args) {
        String s = null;
        System.out.println(s + 10 + 20);
    }
}
```

**Answer:**
✅ Output: `null1020`
**Why?**

* Left-to-right evaluation:

  * `s + 10` → `"null10"` (string)
  * `"null10" + 20` → `"null1020"`

---

### 🔹 17. **Difference between `ArrayList` and `LinkedList`?**

| Feature            | ArrayList               | LinkedList            |
| ------------------ | ----------------------- | --------------------- |
| Data Structure     | Dynamic Array           | Doubly Linked List    |
| Access Time        | Fast (O(1)) via index   | Slow (O(n))           |
| Insertion/Deletion | Slow (shifting)         | Fast (no shifting)    |
| Memory             | Less (contiguous array) | More (node + pointer) |

---

### 🔹 18. **What is `hashCode()` and `equals()` contract?**

If two objects are **equal (`equals()` returns true)**, then:

* Their `hashCode()` **must be same**.

But if two objects have **same `hashCode()`**, they **may or may not be equal**.

---

### 🔹 19. **Explain the output:**

```java
Set<String> set = new HashSet<>();
set.add("one");
set.add("two");
set.add("one");
System.out.println(set.size());
```

✅ Output: `2`

* Duplicate "one" is ignored by `HashSet` (only unique values allowed).

---

### 🔹 20. **What is the output?**

```java
int i = 1;
System.out.println(i++ + ++i + i++);
```

**Steps:**

* `i++` → 1, then i becomes 2
* `++i` → 3
* `i++` → 3 (prints 3), then i becomes 4

✅ Answer: `1 + 3 + 3 = 7`

---

### 🔹 21. **What is method overloading and overriding?**

| Feature         | Overloading                        | Overriding                         |
| --------------- | ---------------------------------- | ---------------------------------- |
| Definition      | Same method name, different params | Child class modifies parent method |
| Return Type     | Can change                         | Must be same or covariant          |
| Access Modifier | Any                                | Cannot reduce visibility           |
| Static?         | Yes                                | No (only instance methods)         |

---

### 🔹 22. **Checked vs Unchecked Exception**

| Type               | Checked                   | Unchecked                                     |
| ------------------ | ------------------------- | --------------------------------------------- |
| Package            | `java.io`, `SQLException` | `NullPointerException`, `ArithmeticException` |
| Compile-time Check | Required                  | Not required                                  |

---

### 🔹 23. **What will be the output?**

```java
try {
    System.out.println("Try");
    return;
} finally {
    System.out.println("Finally");
}
```

✅ Output:

```
Try  
Finally
```

**Note:** `finally` always executes, **even after return**.

---

### 🔹 24. **Can static method be overridden?**

**Answer:**
No, static methods are **class-level**, not object-level.
They can be **hidden** (method hiding), not overridden.

---

### 🔹 25. **What is the output?**

```java
public class Test {
    public static void main(String[] args) {
        int a = 10;
        if (a = 5) {
            System.out.println("Hello");
        }
    }
}
```

❌ Compilation Error:
**Reason:** `a = 5` is an assignment, not a boolean expression.
✔ Fix: use `a == 5`

---

### 🔹 26. **How to prevent inheritance?**

**Answer:** Use `final` keyword before class.

```java
final class Vehicle { }
class Car extends Vehicle { } // ❌ Error
```

---

### 🔹 27. **What is the result?**

```java
int x = 10;
int y = x++ * 2 + ++x;
System.out.println(y);
```

**Evaluation:**

* `x++` → 10, x becomes 11
* `++x` → 12
* `10 * 2 + 12 = 20 + 12 = 32`

✅ Output: `32`

---

### 🔹 28. **Why use `interface` if we have `abstract class`?**

* Java supports **multiple interfaces**, but not multiple inheritance.
* Interface is for **contract**, abstract class is for **partial implementation**.
* Interfaces have **default**, **static**, and **private** methods since Java 8.

---

### 🔹 29. **Can interface have constructor?**

**Answer:**
❌ No. Interfaces can't have constructors because they can't be instantiated.

---

### 🔹 30. **What is marker interface?**

An interface with **no methods or fields**.

```java
public interface Serializable { }
```

Used to **mark** a class as having a property (like serializability).

---

Absolutely! Here's the **next set** of **Java Interview and Practice Questions with Answers – Set 3**, explained deeply for **pro to mastery level** understanding.

---

## ✅ **Java Interview Questions – Set 3 (Advanced, MCQ, Logic)**

---

### 🔹 **31. What is the output?**

```java
int x = 5;
int y = 10;
System.out.println(x > y ? x : y);
```

✅ **Output:** `10`

* Ternary operator: condition is false → returns `y`.

---

### 🔹 **32. Can we override a private method in Java?**

❌ **No.**
Private methods are **not inherited**, so cannot be overridden.
They are scoped to the **class only**, not subclasses.

---

### 🔹 **33. What will be the output?**

```java
public class Test {
    static {
        System.out.println("Static block");
    }

    public static void main(String[] args) {
        System.out.println("Main method");
    }
}
```

✅ **Output:**

```
Static block  
Main method
```

* `static block` executes **once when class is loaded**.
* Then the `main()` method runs.

---

### 🔹 **34. What does `==` compare for objects?**

It compares **references**, not values.

```java
String a = new String("hello");
String b = new String("hello");
System.out.println(a == b);      // false (different references)
System.out.println(a.equals(b)); // true (same value)
```

---

### 🔹 **35. What is the output of the following?**

```java
String s = "abc";
s.concat("def");
System.out.println(s);
```

✅ **Output:** `abc`

* Strings are **immutable**.
* `s.concat("def")` creates a **new string**, but original `s` remains unchanged.

---

### 🔹 **36. Difference between `throw` and `throws`?**

| Feature  | `throw`                            | `throws`                          |
| -------- | ---------------------------------- | --------------------------------- |
| Use      | To **actually throw** an exception | To **declare** possible exception |
| Location | Inside method body                 | In method signature               |
| Syntax   | `throw new IOException();`         | `void read() throws IOException`  |

---

### 🔹 **37. Can an interface extend a class?**

❌ **No.**
An interface can only extend **another interface**.

```java
interface A { }
class B { }
interface C extends A { }      // ✅ OK
interface D extends B { }      // ❌ Not allowed
```

---

### 🔹 **38. What is output of this loop?**

```java
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 2; j++) {
        System.out.print(i + "" + j + " ");
    }
}
```

✅ **Output:**

```
00 01 10 11 20 21 
```

* Nested loop generates all combinations.

---

### 🔹 **39. What does `volatile` keyword do?**

It tells JVM:

* Variable is **shared between threads**
* Always **read/write from main memory**, not from thread-local cache

```java
volatile boolean flag = true;
```

Ensures **visibility of changes** to all threads.

---

### 🔹 **40. Predict the output**

```java
int a = 3;
System.out.println(a++ + ++a);
```

✅ Output:

* `a++` → 3 (then a=4)
* `++a` → 5
* `3 + 5 = 8`

---

### 🔹 **41. Can we make constructor `final`?**

❌ **No.**

* Constructor cannot be `final`, `static`, or `abstract`.
* Because constructors are **not inherited**, there's nothing to prevent overriding.

---

### 🔹 **42. Explain `instanceof` keyword with example.**

Checks if an object **is of a certain type**.

```java
String s = "test";
System.out.println(s instanceof String);  // true
System.out.println(s instanceof Object);  // true
```

If `s == null`, then `s instanceof String` → `false`

---

### 🔹 **43. What is the difference between `==` and `equals()` in wrapper classes?**

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);         // true (cached between -128 to 127)
System.out.println(a.equals(b));    // true

Integer x = 200;
Integer y = 200;
System.out.println(x == y);         // false
System.out.println(x.equals(y));    // true
```

---

### 🔹 **44. Final variable inside method: can we assign it?**

✅ Yes. But only once.

```java
void show() {
    final int a;
    a = 10;      // allowed
    // a = 20;   // ❌ error: already assigned
}
```

---

### 🔹 **45. Can we inherit a constructor?**

❌ No. Constructors are **not inherited** in Java.

But we can use `super()` to call **parent constructor** explicitly.

---

### 🔹 **46. What’s the output?**

```java
String str = "abc";
str = str.toUpperCase();
System.out.println(str);
```

✅ Output: `ABC`

Because `String` is immutable, `toUpperCase()` returns a **new String**.

---

### 🔹 **47. Difference between `ArrayList` and `Vector`**

| Feature     | ArrayList | Vector               |
| ----------- | --------- | -------------------- |
| Thread Safe | ❌ No      | ✅ Yes (synchronized) |
| Performance | Faster    | Slower               |
| Introduced  | Java 1.2  | Java 1.0             |

---

### 🔹 **48. What is default size of ArrayList?**

* Initial capacity is **10**.
* Automatically grows as elements are added.

---

### 🔹 **49. Can interface have static methods?**

✅ **Yes**, since Java 8.

```java
interface A {
    static void hello() {
        System.out.println("Hello from interface");
    }
}
```

Call via interface: `A.hello();`

---

### 🔹 **50. What is output?**

```java
int x = 5;
System.out.println(++x + x++);
```

* `++x` → 6
* `x++` → 6 (x becomes 7)
* Output: `6 + 6 = 12`

---

Great! Here's your **Java Interview & Practice Questions – Set 4**, packed with tricky, concept-based, and real-world questions — with answers and detailed explanations.

---

## ✅ **Java Interview Questions – Set 4 (Advanced Tricky + OOP + Keywords)**

---

### 🔹 **51. Can an abstract class have a constructor?**

✅ **Yes**, abstract classes can have constructors.
They are used to **initialize common data** for subclasses.

```java
abstract class Animal {
    Animal() {
        System.out.println("Animal constructor");
    }
}

class Dog extends Animal {
    Dog() {
        System.out.println("Dog constructor");
    }
}
```

Output:

```
Animal constructor  
Dog constructor
```

---

### 🔹 **52. What is the output?**

```java
int a = 5;
System.out.println(a++ * --a);
```

Step-by-step:

* `a++` → 5 (then a becomes 6)
* `--a` → 5
* `5 * 5 = 25`

✅ **Output: `25`**

---

### 🔹 **53. Explain difference between `final`, `finally`, and `finalize()`**

| Keyword      | Description                                                                   |
| ------------ | ----------------------------------------------------------------------------- |
| `final`      | Prevents inheritance (class), overriding (method), or reassignment (variable) |
| `finally`    | Block that always executes after `try-catch`, used for cleanup                |
| `finalize()` | Method called by GC before object is collected (deprecated now)               |

---

### 🔹 **54. What is the output?**

```java
String s1 = "Java";
String s2 = "Java";
System.out.println(s1 == s2);       // true
System.out.println(s1.equals(s2));  // true
```

* Both point to same **string pool object**
  ✅ **Output: true true**

---

### 🔹 **55. What is marker interface in Java?**

An interface with **no methods or fields**.
Used to **mark** a class for special behavior.

Example:

* `Serializable`
* `Cloneable`
* `Remote`

```java
class MyClass implements Serializable {
    // JVM uses reflection to check this marker
}
```

---

### 🔹 **56. What’s the output?**

```java
int i = 10;
int j = 20;
int result = i+++j;
System.out.println(result);
```

✅ Output: `30`

Explanation: `i+++j` is interpreted as `(i++) + j`

---

### 🔹 **57. Can a class implement two interfaces with same method signature?**

✅ Yes. The method must be implemented **once**.

```java
interface A { void show(); }
interface B { void show(); }

class My implements A, B {
    public void show() {
        System.out.println("Show");
    }
}
```

---

### 🔹 **58. Can we create an object of interface?**

❌ No. But we can create:

* Anonymous class object
* Lambda expression (for functional interface)

```java
Runnable r = new Runnable() {
    public void run() {
        System.out.println("Runnable running");
    }
};
```

---

### 🔹 **59. What is covariant return type?**

A method in a subclass **overrides** a method from superclass, and can return a **subtype**.

```java
class Animal { }
class Dog extends Animal { }

class A {
    Animal getAnimal() { return new Animal(); }
}
class B extends A {
    Dog getAnimal() { return new Dog(); }  // ✅ Covariant return
}
```

---

### 🔹 **60. What’s the output?**

```java
int[] arr = new int[5];
System.out.println(arr[0]);
```

✅ Output: `0`

* Default int array values are 0.

---

### 🔹 **61. Can we declare constructor as final, static, or abstract?**

❌ No. Constructors:

* Cannot be **`final`** – not inherited
* Cannot be **`static`** – not tied to class
* Cannot be **`abstract`** – must be implemented

---

### 🔹 **62. What is `this` keyword?**

Refers to **current object**. Used to:

* Access instance variables
* Call another constructor
* Pass current object as parameter

```java
class A {
    int x;
    A(int x) {
        this.x = x;
    }
}
```

---

### 🔹 **63. What is `super` keyword?**

Refers to **parent class**. Used to:

* Call parent constructor
* Access parent’s method/variable

```java
class Parent {
    int a = 10;
}
class Child extends Parent {
    void show() {
        System.out.println(super.a);
    }
}
```

---

### 🔹 **64. What is object slicing in Java?**

✅ Java avoids object slicing, unlike C++.
But it may occur in serialization/deserialization scenarios if subclass fields are not preserved.

---

### 🔹 **65. Is String a data type in Java?**

✅ **No**, it’s a **class** from `java.lang`.

```java
String s = "hello";  // Class object, not primitive
```

---

### 🔹 **66. What does `new` keyword do?**

Creates a **new object** in heap and returns its reference.

```java
Student s = new Student();
```

---

### 🔹 **67. What is default value of `boolean`, `char`, and `float`?**

| Type    | Default              |
| ------- | -------------------- |
| boolean | `false`              |
| char    | `\u0000` (null char) |
| float   | `0.0f`               |

---

### 🔹 **68. Can we overload static methods?**

✅ **Yes**, but overloading is resolved **at compile time**.

```java
class A {
    static void show(int x) { }
    static void show(double x) { }  // overloaded
}
```

---

### 🔹 **69. Can we override static methods?**

❌ No.
Static methods belong to **class**, not instance.
If subclass defines same method, it’s **method hiding**, not overriding.

---

### 🔹 **70. What is method reference in Java 8?**

Shortcut to call a method using `::` operator.

```java
public class Test {
    static void sayHello() {
        System.out.println("Hello");
    }
    public static void main(String[] args) {
        Runnable r = Test::sayHello; // method reference
        r.run();
    }
}
```

---
Awesome! Here's your **Java Interview & Practice Questions – Set 5**
This set includes deep questions on **Threads**, **Exception Handling**, **File I/O**, and more — with answers and clear explanations.

---

## ✅ **Java Interview Questions – Set 5 (Threads, Exceptions, File IO)**

---

### 🔹 **71. What is the difference between `start()` and `run()` in Threads?**

| Method    | Purpose                                     |
| --------- | ------------------------------------------- |
| `start()` | Creates a new thread and then calls `run()` |
| `run()`   | Just a normal method call (no new thread)   |

```java
Thread t = new Thread(() -> System.out.println("Running"));
t.start(); // ✅ New thread
t.run();   // ❌ Runs on main thread
```

---

### 🔹 **72. What is the output of the following?**

```java
class A extends Thread {
    public void run() {
        System.out.println("Thread running");
    }
}
public class Test {
    public static void main(String[] args) {
        A a = new A();
        a.start();
    }
}
```

✅ **Output:** `"Thread running"`
✅ **Explanation:** `start()` calls `run()` in a new thread.

---

### 🔹 **73. Checked vs Unchecked Exceptions?**

| Type      | Example                                       | Must handle?         |
| --------- | --------------------------------------------- | -------------------- |
| Checked   | `IOException`, `SQLException`                 | ✅ Yes (compile-time) |
| Unchecked | `NullPointerException`, `ArithmeticException` | ❌ No (runtime)       |

---

### 🔹 **74. Can we override `finalize()` method?**

✅ Yes. But it's **deprecated** since Java 9.

```java
protected void finalize() {
    System.out.println("Cleaning up");
}
```

---

### 🔹 **75. What is `throws` vs `throw`?**

| Keyword  | Purpose                                 |
| -------- | --------------------------------------- |
| `throw`  | Used to explicitly throw an exception   |
| `throws` | Declares exception a method might throw |

```java
void m() throws IOException {
    throw new IOException("Error!");
}
```

---

### 🔹 **76. Difference between `FileReader` and `BufferedReader`?**

| Class            | Purpose                       |
| ---------------- | ----------------------------- |
| `FileReader`     | Reads characters from file    |
| `BufferedReader` | Adds buffering and efficiency |

```java
BufferedReader br = new BufferedReader(new FileReader("file.txt"));
String line = br.readLine();
```

---

### 🔹 **77. What is `try-with-resources` in Java 7+?**

Automatically closes resources:

```java
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    System.out.println(br.readLine());
}
```

✅ No need for `finally { br.close(); }`

---

### 🔹 **78. What is `InterruptedException`?**

Thrown when a **thread is blocked** and another thread interrupts it.

```java
Thread.sleep(1000); // throws InterruptedException
```

---

### 🔹 **79. How to create a thread using `Runnable` interface?**

```java
class MyTask implements Runnable {
    public void run() {
        System.out.println("Runnable running");
    }
}

Thread t = new Thread(new MyTask());
t.start();
```

---

### 🔹 **80. Can we call `sleep()` without try-catch?**

❌ No.
`Thread.sleep()` throws `InterruptedException`, so must be handled.

---

### 🔹 **81. What does `join()` do in threads?**

Makes the current thread **wait** for another thread to finish.

```java
Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) System.out.print(i + " ");
});
t.start();
t.join(); // Waits for t to finish
```

---

### 🔹 **82. Can constructor throw exceptions?**

✅ Yes. Constructors can declare and throw exceptions.

```java
class A {
    A() throws IOException {
        throw new IOException();
    }
}
```

---

### 🔹 **83. What is the default priority of a thread?**

Default is `5` (Thread.NORM\_PRIORITY)
Min = 1, Max = 10

```java
Thread t = new Thread();
System.out.println(t.getPriority()); // 5
```

---

### 🔹 **84. What is synchronization in threads?**

Used to **prevent race condition** when multiple threads access shared resource.

```java
synchronized void print() {
    // only one thread can execute this
}
```

---

### 🔹 **85. What’s the output?**

```java
try {
    System.out.println(1/0);
} catch (ArithmeticException e) {
    System.out.println("Error");
} finally {
    System.out.println("Done");
}
```

✅ Output:

```
Error  
Done
```

---

### 🔹 **86. Can we write multiple catch blocks?**

✅ Yes, Java allows multiple `catch` blocks:

```java
try {
    int a = 10/0;
} catch (ArithmeticException e) {
    System.out.println("Math error");
} catch (Exception e) {
    System.out.println("Generic");
}
```

---

### 🔹 **87. Can an interface extend a class?**

❌ No. Interface can **only extend other interfaces**.

```java
interface A {}
interface B extends A {}  // ✅
```

---

### 🔹 **88. What is the difference between `==` and `equals()`?**

| Operator | Checks for               |
| -------- | ------------------------ |
| `==`     | Reference equality       |
| `equals` | Logical/content equality |

```java
String a = new String("Test");
String b = new String("Test");

System.out.println(a == b);        // false
System.out.println(a.equals(b));   // true
```

---

### 🔹 **89. Can `finally` block be skipped?**

✅ Only if:

* `System.exit()` is called
* JVM crashes

---

### 🔹 **90. What is deadlock?**

Two threads are **waiting on each other** forever — resource lock never released.

```java
// Thread A locks obj1, waits for obj2
// Thread B locks obj2, waits for obj1
```

---

Great! Here's your **Java Interview & Practice Questions – Set 6**
This set focuses on **Advanced Java** topics like **Collections**, **Lambda Expressions**, **Stream API**, and **Functional Interfaces** — with pro-level clarity and examples.

---

## ✅ **Java Interview Questions – Set 6 (Collections, Lambda, Streams, Functional)**

---

### 🔹 **91. Difference between List, Set, and Map?**

| Collection | Allows Duplicates | Ordered?                          | Key-Value? |
| ---------- | ----------------- | --------------------------------- | ---------- |
| List       | ✅ Yes             | ✅ Yes                             | ❌ No       |
| Set        | ❌ No              | ❌ No (HashSet), ✅ (LinkedHashSet) | ❌ No       |
| Map        | Keys ❌, Values ✅  | ❌ No (HashMap), ✅ (LinkedHashMap) | ✅ Yes      |

---

### 🔹 **92. What is the difference between ArrayList and LinkedList?**

| Feature        | ArrayList              | LinkedList            |
| -------------- | ---------------------- | --------------------- |
| Memory         | Continuous block       | Nodes                 |
| Access Speed   | Fast (index-based)     | Slow (traverse nodes) |
| Insertion/Del. | Slow (shifting needed) | Fast (no shift)       |

---

### 🔹 **93. Write a Lambda to sum 2 numbers.**

```java
@FunctionalInterface
interface Add {
    int sum(int a, int b);
}

Add add = (a, b) -> a + b;
System.out.println(add.sum(10, 20));  // 30
```

---

### 🔹 **94. What is a functional interface?**

An interface with **only one abstract method** (Java 8 feature).

Examples:

* `Runnable`
* `Callable`
* `Comparator`

Use `@FunctionalInterface` annotation to enforce it.

---

### 🔹 **95. What is the use of `Predicate<T>`?**

It checks a condition and returns a boolean:

```java
Predicate<Integer> isEven = x -> x % 2 == 0;
System.out.println(isEven.test(10)); // true
```

---

### 🔹 **96. What is Stream API?**

A Java 8 feature for **functional-style operations on collections**.

---

### 🔹 **97. Stream API Example: Filter even numbers**

```java
List<Integer> list = List.of(1,2,3,4,5,6);
list.stream()
    .filter(n -> n % 2 == 0)
    .forEach(System.out::println); // 2 4 6
```

---

### 🔹 **98. Map vs FlatMap?**

* `map()` transforms elements
* `flatMap()` flattens nested streams

```java
List<List<String>> data = List.of(
    List.of("A", "B"), 
    List.of("C", "D")
);

data.stream()
    .flatMap(List::stream)
    .forEach(System.out::print);  // ABCD
```

---

### 🔹 **99. What does `collect(Collectors.toList())` do?**

Converts a **stream back to a list**.

```java
List<String> names = list.stream()
                         .filter(n -> n.startsWith("A"))
                         .collect(Collectors.toList());
```

---

### 🔹 **100. What’s the output of this code?**

```java
List<String> names = List.of("Amit", "Anu", "Ravi");
long count = names.stream().filter(n -> n.startsWith("A")).count();
System.out.println(count);
```

✅ **Output:** `2`

---

### 🔹 **101. Use `sorted()` with Streams.**

```java
List<Integer> nums = List.of(5, 1, 3);
nums.stream()
    .sorted()
    .forEach(System.out::println);  // 1 3 5
```

---

### 🔹 **102. Difference between `HashMap` and `TreeMap`?**

| Feature   | HashMap        | TreeMap               |
| --------- | -------------- | --------------------- |
| Order     | ❌ No order     | ✅ Sorted by key       |
| Null keys | ✅ One null key | ❌ No null key allowed |

---

### 🔹 **103. What is `Optional<T>` in Java 8?**

Avoids `NullPointerException` by wrapping a value that **may or may not be present**.

```java
Optional<String> name = Optional.ofNullable(null);
System.out.println(name.orElse("Default")); // Default
```

---

### 🔹 **104. What is the use of `Consumer<T>`?**

It takes input and **does something**, returns nothing.

```java
Consumer<String> printer = x -> System.out.println(x.toUpperCase());
printer.accept("java"); // JAVA
```

---

### 🔹 **105. Difference: `peek()` vs `map()` in Stream?**

* `peek()` is for **debugging/logging**
* `map()` is for **transformation**

```java
list.stream()
    .peek(System.out::println)
    .map(x -> x * 2);
```

---

### 🔹 **106. Use Lambda to sort names by length.**

```java
List<String> names = List.of("John", "Alok", "Alexander");

names.stream()
     .sorted((a, b) -> a.length() - b.length())
     .forEach(System.out::println);
```

---

### 🔹 **107. Use method reference in stream.**

```java
List<String> names = List.of("Ram", "Shyam");
names.forEach(System.out::println);
```

---

### 🔹 **108. What is `Comparator` in Java?**

Used to sort objects by custom logic:

```java
Comparator<String> byLength = (a, b) -> a.length() - b.length();
```

---

### 🔹 **109. Stream terminal vs intermediate operations?**

| Operation Type | Examples                            |
| -------------- | ----------------------------------- |
| Intermediate   | `filter()`, `map()`                 |
| Terminal       | `collect()`, `forEach()`, `count()` |

---

### 🔹 **110. What is identity in `reduce()`?**

`reduce(identity, accumulator)` – combines elements with a seed value.

```java
List<Integer> nums = List.of(1, 2, 3, 4);
int sum = nums.stream().reduce(0, (a, b) -> a + b); // 10
```

---

Here is your **Java Interview & Practice Questions – Set 7**, focused on **Java 8+, Multithreading, and Design Patterns**, with **answers and real examples**.

---

## ✅ **Java Interview Questions – Set 7 (Multithreading + Design Patterns + Java 8 Pro)**

---

### 🔹 **111. What is a thread in Java?**

A **thread** is a lightweight subprocess — smallest unit of execution.

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running...");
    }
}

new MyThread().start();
```

---

### 🔹 **112. Difference between `start()` and `run()`?**

| Method    | Behavior                                                |
| --------- | ------------------------------------------------------- |
| `start()` | Starts a new thread (calls `run()` on a new call stack) |
| `run()`   | Runs on **current thread** (like a normal method)       |

---

### 🔹 **113. How to implement threads?**

✔️ Two ways:

1. Extend `Thread`
2. Implement `Runnable`

```java
Runnable task = () -> System.out.println("Runnable running...");
new Thread(task).start();
```

---

### 🔹 **114. What is thread lifecycle?**

🔁 **NEW → RUNNABLE → RUNNING → BLOCKED/WAITING → TERMINATED**

---

### 🔹 **115. What is synchronization?**

Used to prevent **thread interference** and maintain **thread safety**.

```java
synchronized void printData() {
    // critical section
}
```

---

### 🔹 **116. What is a deadlock?**

When two or more threads are waiting on each other to release resources — and none proceeds.

```java
// Classic case: Thread A locks obj1, waits for obj2; Thread B locks obj2, waits for obj1.
```

---

### 🔹 **117. What is `volatile` keyword?**

Ensures a variable’s **value is always read from main memory**, not CPU cache.

```java
volatile boolean running = true;
```

---

### 🔹 **118. What is a daemon thread?**

Runs in background, dies when main thread finishes.

```java
Thread t = new Thread(() -> {});
t.setDaemon(true);
```

---

### 🔹 **119. What’s the use of `ExecutorService`?**

Manages thread pools efficiently.

```java
ExecutorService service = Executors.newFixedThreadPool(2);
service.submit(() -> System.out.println("Task"));
service.shutdown();
```

---

### 🔹 **120. What is `Callable` vs `Runnable`?**

| Interface | Returns | Throws Exception |
| --------- | ------- | ---------------- |
| Runnable  | ❌ No    | ❌ No             |
| Callable  | ✅ Yes   | ✅ Yes            |

```java
Callable<Integer> task = () -> 5 + 10;
```

---

## ☑️ **Java Design Patterns**

---

### 🔹 **121. Singleton Pattern (Only one object globally)**

```java
class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

---

### 🔹 **122. Factory Pattern (Object creation logic)**

```java
interface Shape { void draw(); }

class Circle implements Shape { public void draw() { System.out.println("Circle"); } }
class Square implements Shape { public void draw() { System.out.println("Square"); } }

class ShapeFactory {
    Shape getShape(String type) {
        if (type.equals("circle")) return new Circle();
        if (type.equals("square")) return new Square();
        return null;
    }
}
```

---

### 🔹 **123. Observer Pattern (Subscribe/Publish)**

Used in Event systems, GUI, Chat systems

```java
interface Observer {
    void update(String msg);
}

class Subscriber implements Observer {
    public void update(String msg) {
        System.out.println("Received: " + msg);
    }
}
```

---

## ✅ **Java 8+ More Functional Questions**

---

### 🔹 **124. What is method reference?**

Shortcut to call a method using `::`

```java
List<String> list = List.of("A", "B");
list.forEach(System.out::println); // instead of x -> System.out.println(x)
```

---

### 🔹 **125. Group list by a key using `Collectors.groupingBy()`**

```java
Map<Integer, List<String>> grouped = List.of("a", "aa", "bbb")
    .stream()
    .collect(Collectors.groupingBy(String::length));

System.out.println(grouped); // {1=[a], 2=[aa], 3=[bbb]}
```

---

### 🔹 **126. Convert a List<String> to a single comma-separated String**

```java
List<String> names = List.of("Ram", "Shyam");
String result = names.stream().collect(Collectors.joining(", "));
System.out.println(result); // Ram, Shyam
```

---

### 🔹 **127. What’s the use of `Optional` with `map()` and `filter()`?**

```java
Optional<String> name = Optional.of("John");
name.filter(n -> n.startsWith("J"))
    .map(String::toUpperCase)
    .ifPresent(System.out::println); // JOHN
```

---

### 🔹 **128. How to parallelize a stream?**

```java
List<Integer> nums = List.of(1,2,3,4,5);
nums.parallelStream()
    .forEach(System.out::println);
```

---

### 🔹 **129. What is the difference between Stream and ParallelStream?**

| Type           | Executes        | Performance           |
| -------------- | --------------- | --------------------- |
| Stream         | Single-threaded | Safe and ordered      |
| ParallelStream | Multi-threaded  | Faster (for big data) |

---

### 🔹 **130. Find the first even number in a list**

```java
List<Integer> list = List.of(3, 7, 10, 15);
Optional<Integer> firstEven = list.stream()
                                  .filter(n -> n % 2 == 0)
                                  .findFirst();
System.out.println(firstEven.get()); // 10
```

---
Here is your **Java Interview & Practice Questions – Set 8**, focused on **Real-Time Errors, Debugging, and Common Mistakes**, with **answers, explanations, and corrections**.

---

## ✅ **Java Interview Questions – Set 8 (Error Handling & Debugging)**

---

### 🔹 **131. What is `NullPointerException`? How to avoid it?**

Occurs when accessing a method or field on a `null` object.

❌ Error:

```java
String name = null;
System.out.println(name.length()); // NPE
```

✅ Fix:

```java
if (name != null) {
    System.out.println(name.length());
}
```

---

### 🔹 **132. What causes `ArrayIndexOutOfBoundsException`?**

Occurs when accessing an array with an invalid index.

❌ Error:

```java
int[] a = {1, 2, 3};
System.out.println(a[3]); // Index 3 is out of bounds
```

✅ Fix:

```java
if (index >= 0 && index < a.length) {
    System.out.println(a[index]);
}
```

---

### 🔹 **133. What causes `ClassCastException`?**

Happens when casting an object to an incompatible type.

❌ Error:

```java
Object obj = "Hello";
Integer i = (Integer) obj; // Error
```

✅ Fix:

```java
if (obj instanceof Integer) {
    Integer i = (Integer) obj;
}
```

---

### 🔹 **134. What causes `NumberFormatException`?**

Occurs when converting invalid string to number.

❌ Error:

```java
String str = "abc";
int i = Integer.parseInt(str); // Error
```

✅ Fix:

```java
try {
    int i = Integer.parseInt(str);
} catch (NumberFormatException e) {
    System.out.println("Invalid number");
}
```

---

### 🔹 **135. How to handle `IOException` in file operations?**

Always wrap file I/O with `try-catch` or use `throws`.

✅ Example:

```java
try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    String line = br.readLine();
    System.out.println(line);
} catch (IOException e) {
    e.printStackTrace();
}
```

---

### 🔹 **136. What’s the correct way to override `equals()` and `hashCode()`?**

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Student)) return false;
    Student s = (Student) o;
    return id == s.id;
}

@Override
public int hashCode() {
    return Objects.hash(id);
}
```

---

### 🔹 **137. What’s the output? Why?**

```java
String a = "Hello";
String b = "Hello";
String c = new String("Hello");

System.out.println(a == b); // true (same literal pool)
System.out.println(a == c); // false (new object)
System.out.println(a.equals(c)); // true
```

---

### 🔹 **138. Which loop will run infinitely?**

```java
for (int i = 0; i >= 0; i++) {
    // Infinite loop (i never < 0)
}
```

---

### 🔹 **139. Fix the bug: Compilation error in method overloading**

```java
// ❌ Compile Error: Same erasure
public void display(List<String> list) {}
public void display(List<Integer> list) {}
```

✅ Fix:
Use different method names or parameter types not erased to the same type.

---

### 🔹 **140. Why does this code cause StackOverflowError?**

```java
public int recursive(int x) {
    return recursive(x + 1);
}
```

✅ Fix:
Always add a **base condition** to recursion.

```java
public int recursive(int x) {
    if (x == 1000) return x;
    return recursive(x + 1);
}
```

---

## 🛠 Real-Time Debugging Scenarios

---

### 🔹 **141. Why is output missing in multithreading?**

```java
Runnable r = () -> {
    try { Thread.sleep(1000); } catch (Exception e) {}
    System.out.println("Done");
};

Thread t = new Thread(r);
t.start();
// Missing join() causes main to finish before thread
```

✅ Fix:

```java
t.join(); // Ensures thread completes before main exits
```

---

### 🔹 **142. Why does sorting fail with `null` values?**

```java
List<String> list = Arrays.asList("B", null, "A");
Collections.sort(list); // ❌ Throws NullPointerException
```

✅ Fix:

```java
list.sort(Comparator.nullsLast(Comparator.naturalOrder()));
```

---

### 🔹 **143. Why doesn't List remove element as expected?**

```java
List<Integer> list = List.of(1, 2, 3); // Immutable
list.remove(1); // UnsupportedOperationException
```

✅ Fix:

```java
List<Integer> list = new ArrayList<>(List.of(1, 2, 3));
list.remove(1);
```

---

### 🔹 **144. Why is this `HashMap` key not updating value?**

```java
Map<Employee, String> map = new HashMap<>();
map.put(new Employee(101), "A");
map.put(new Employee(101), "B"); // Adds new entry
```

✅ Fix:
Override `equals()` and `hashCode()` in `Employee`.

---

### 🔹 **145. Why is integer comparison failing?**

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b); // true

Integer x = 128;
Integer y = 128;
System.out.println(x == y); // false
```

✅ Reason: Integers between -128 to 127 are cached by JVM.

✅ Fix: Use `equals()` instead of `==` for object comparison.

---

Here is your **Java Interview & Practice Questions – Set 9**, focused on **Puzzles, Brain Teasers, Tricky Logic, and Deep Output Understanding**, with **answers, full explanations, and behavior insights**.

---

## ✅ **Java Interview Questions – Set 9 (Puzzles & Tricky Logic)**

---

### 🔹 **146. What is the output? Why?**

```java
int a = 10;
a = a++ + ++a;
System.out.println(a);
```

🧠 **Explanation**:

* `a++` → use 10, then a becomes 11
* `++a` → increment to 12, use 12
* So: `a = 10 + 12 = 22`

✅ **Output**: `22`

---

### 🔹 **147. What will this print?**

```java
int i = 0;
i = i++ - --i + ++i;
System.out.println(i);
```

🧠 **Explanation**:

* `i++` → use 0, i becomes 1
* `--i` → i becomes 0
* `++i` → i becomes 1
  So:

```
i = 0 - 0 + 1 = 1
```

✅ **Output**: `1`

---

### 🔹 **148. What happens here?**

```java
int x = 5 * 2 >> 1;
System.out.println(x);
```

🧠 **Explanation**:

* `5 * 2 = 10`
* `10 >> 1 = 5` (bitwise right shift)

✅ **Output**: `5`

---

### 🔹 **149. What’s the output?**

```java
System.out.println(10 + 20 + "30" + 40 + 50);
```

🧠 **Explanation**:

* `10 + 20 = 30`
* `"30" + 40` → "3040"
* `"3040" + 50` → "304050"

✅ **Output**: `304050`

---

### 🔹 **150. Can we write:**

```java
final int x;
x = 100;
System.out.println(x);
```

✅ **Yes**, it's legal as long as `final` variable is assigned **once before use**.

✅ **Output**: `100`

---

### 🔹 **151. What’s the result of this loop?**

```java
for (int i = 0; i < 3; i++) {
    System.out.print(i + " ");
    i++;
}
```

🧠 Loop steps:

* i = 0 → print 0 → i++ = 1 (in loop) → i++ = 2 (from for loop)
* i = 2 → print 2 → i++ = 3 → exit

✅ **Output**: `0 2`

---

### 🔹 **152. Can a constructor be `final`, `static`, or `synchronized`?**

🟥 **No.**

* `final`: constructors can't be overridden.
* `static`: constructors belong to objects, not class.
* `synchronized`: allowed indirectly inside constructor body.

---

### 🔹 **153. What is wrong here?**

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(args[0]);
    }
}
```

🟥 **Error** if you run without arguments:
`ArrayIndexOutOfBoundsException`

✅ Fix:

```java
if (args.length > 0)
    System.out.println(args[0]);
```

---

### 🔹 **154. What’s the output?**

```java
System.out.println("one" + 2 + 3);
System.out.println(1 + 2 + "three");
```

✅ **Output**:

```
one23
3three
```

🧠 Left-to-right evaluation.

---

### 🔹 **155. What happens here?**

```java
String s1 = "hello";
String s2 = "he" + "llo";
String s3 = new String("hello");

System.out.println(s1 == s2); // true
System.out.println(s1 == s3); // false
System.out.println(s1.equals(s3)); // true
```

🧠 String pool and memory reference

---

### 🔹 **156. Predict the output:**

```java
int a = 2;
int b = 3;
a ^= b ^= a ^= b;

System.out.println(a + " " + b);
```

🧠 XOR Swap

✅ Output: `3 2`

---

### 🔹 **157. Can we overload `main()` method?**

✅ **Yes**, but only this is entry point:

```java
public static void main(String[] args)
```

Other overloads won't run automatically.

---

### 🔹 **158. What does this print?**

```java
System.out.println(10 + 20 + "Hello" + 10 + 20);
```

✅ Output: `30Hello1020`

---

### 🔹 **159. Can we use switch with strings?**

✅ Yes, since Java 7.

```java
String s = "admin";
switch (s) {
  case "admin": System.out.println("Admin!"); break;
}
```

---

### 🔹 **160. Can a class be declared as `private`?**

🟥 No, **top-level classes** can only be `public` or package-private.

✅ Nested classes can be `private`.

---

Here is your **Java Interview & Practice Questions – Set 10**, focused on **Real-World Coding Scenarios**, **Interview Rounds**, and **Advanced Practice** – each with **answers, explanations, and real use cases**.

---

## ✅ **Java Interview Questions – Set 10 (Real Coding + Logic Practice)**

---

### 🔹 **161. Swap two variables without using third variable**

```java
int a = 10, b = 20;
a = a + b;  // 30
b = a - b;  // 10
a = a - b;  // 20
System.out.println(a + " " + b);
```

✅ Output: `20 10`

---

### 🔹 **162. Reverse a string in Java**

```java
String input = "Hello";
String reversed = new StringBuilder(input).reverse().toString();
System.out.println(reversed);
```

✅ Output: `olleH`

---

### 🔹 **163. Check if a number is prime**

```java
boolean isPrime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i <= Math.sqrt(n); i++)
    if (n % i == 0) return false;
  return true;
}
```

✅ Efficient for large numbers

---

### 🔹 **164. Find duplicate characters in a string**

```java
String str = "programming";
Map<Character, Integer> map = new HashMap<>();

for (char c : str.toCharArray())
  map.put(c, map.getOrDefault(c, 0) + 1);

for (Map.Entry<Character, Integer> entry : map.entrySet())
  if (entry.getValue() > 1)
    System.out.println(entry.getKey() + " = " + entry.getValue());
```

✅ Output:

```
r = 2
g = 2
m = 2
```

---

### 🔹 **165. Fibonacci series using recursion**

```java
int fib(int n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
```

🔁 **Note**: Use memoization for large `n`.

---

### 🔹 **166. Reverse a number**

```java
int n = 12345, rev = 0;
while (n != 0) {
  rev = rev * 10 + n % 10;
  n /= 10;
}
System.out.println(rev); // 54321
```

---

### 🔹 **167. Palindrome check for string**

```java
String str = "madam";
boolean isPal = str.equals(new StringBuilder(str).reverse().toString());
System.out.println(isPal); // true
```

---

### 🔹 **168. Check Armstrong Number (e.g., 153)**

```java
int num = 153, sum = 0, temp = num;
while (temp != 0) {
  int digit = temp % 10;
  sum += digit * digit * digit;
  temp /= 10;
}
System.out.println(sum == num); // true
```

---

### 🔹 **169. Count vowels and consonants in a string**

```java
String s = "Hello World";
int v = 0, c = 0;
s = s.toLowerCase();

for (char ch : s.toCharArray()) {
  if ("aeiou".indexOf(ch) != -1) v++;
  else if (Character.isLetter(ch)) c++;
}

System.out.println("Vowels: " + v + ", Consonants: " + c);
```

✅ Output: `Vowels: 3, Consonants: 7`

---

### 🔹 **170. Print pattern: Right Triangle**

```java
for (int i = 1; i <= 5; i++) {
  for (int j = 1; j <= i; j++)
    System.out.print("*");
  System.out.println();
}
```

✅ Output:

```
*
**
***
****
*****
```

---

### 🔹 **171. Remove whitespaces from string**

```java
String s = " Java is  cool ";
String result = s.replaceAll("\\s+", "");
System.out.println(result); // "Javaiscool"
```

---

### 🔹 **172. Factorial using recursion**

```java
long fact(int n) {
  return (n <= 1) ? 1 : n * fact(n - 1);
}
```

---

### 🔹 **173. Find Largest of Three Numbers**

```java
int a = 5, b = 10, c = 7;
int max = Math.max(a, Math.max(b, c));
System.out.println("Max: " + max); // Max: 10
```

---

### 🔹 **174. Check Anagram**

```java
String s1 = "listen", s2 = "silent";
char[] a = s1.toCharArray(), b = s2.toCharArray();
Arrays.sort(a); Arrays.sort(b);
System.out.println(Arrays.equals(a, b)); // true
```

---

### 🔹 **175. Count words in string**

```java
String s = "Java is fast";
int count = s.trim().split("\\s+").length;
System.out.println(count); // 3
```

---

Here is your **Java Interview & Practice Questions – Set 11**, focused on **Data Structures, Collections, and Real-World Use** – with pro-level **examples and explanations**.

---

## ✅ **Java Interview Questions – Set 11: Collections & Data Structures**

---

### 🔸 **176. Difference between List, Set, and Map**

| Feature           | List  | Set            | Map              |
| ----------------- | ----- | -------------- | ---------------- |
| Allows duplicates | ✅ Yes | ❌ No           | Keys ❌, Values ✅ |
| Order preserved   | ✅ Yes | ❌ No (HashSet) | ✅ LinkedHashMap  |
| Key-Value pairs   | ❌ No  | ❌ No           | ✅ Yes            |

---

### 🔸 **177. Create and iterate a HashMap**

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 10);
map.put("B", 20);
map.put("C", 30);

for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```

✅ Output:

```
A = 10
B = 20
C = 30
```

---

### 🔸 **178. ArrayList Example – CRUD**

```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.set(1, "Kotlin");     // Update
list.remove("Java");       // Delete

System.out.println(list);  // [Kotlin]
```

---

### 🔸 **179. TreeSet – Sorted and Unique Elements**

```java
Set<Integer> set = new TreeSet<>();
set.add(30);
set.add(10);
set.add(20);
set.add(10); // duplicate

System.out.println(set);  // [10, 20, 30]
```

---

### 🔸 **180. Stack – LIFO**

```java
Stack<String> stack = new Stack<>();
stack.push("A");
stack.push("B");
System.out.println(stack.pop()); // B
```

---

### 🔸 **181. Queue – FIFO (LinkedList as Queue)**

```java
Queue<String> q = new LinkedList<>();
q.offer("first");
q.offer("second");

System.out.println(q.poll());  // first
```

---

### 🔸 **182. PriorityQueue – Sorted Queue**

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.add(50);
pq.add(10);
pq.add(30);

while (!pq.isEmpty())
    System.out.print(pq.poll() + " ");
```

✅ Output: `10 30 50`

---

### 🔸 **183. LinkedHashMap – Preserve Order**

```java
Map<String, Integer> map = new LinkedHashMap<>();
map.put("One", 1);
map.put("Two", 2);
map.put("Three", 3);

System.out.println(map); // Maintains insertion order
```

---

### 🔸 **184. Hashtable vs HashMap**

| Feature          | HashMap | Hashtable |
| ---------------- | ------- | --------- |
| Thread-safe      | ❌ No    | ✅ Yes     |
| Null keys/values | ✅ Yes   | ❌ No      |
| Faster           | ✅ Yes   | ❌ No      |

---

### 🔸 **185. Iterate a Set using Iterator**

```java
Set<String> set = new HashSet<>(Arrays.asList("Java", "C++", "Python"));
Iterator<String> it = set.iterator();

while (it.hasNext())
    System.out.println(it.next());
```

---

### 🔸 **186. Sort a List of Strings**

```java
List<String> list = Arrays.asList("Banana", "Apple", "Mango");
Collections.sort(list);
System.out.println(list);  // [Apple, Banana, Mango]
```

---

### 🔸 **187. Sort with Custom Comparator**

```java
List<Integer> nums = Arrays.asList(10, 2, 30, 1);

Collections.sort(nums, (a, b) -> b - a); // Descending
System.out.println(nums); // [30, 10, 2, 1]
```

---

### 🔸 **188. Remove Duplicates from List**

```java
List<Integer> list = Arrays.asList(1, 2, 2, 3, 3);
Set<Integer> set = new LinkedHashSet<>(list);
System.out.println(set); // [1, 2, 3]
```

---

### 🔸 **189. Convert Array to List**

```java
String[] arr = { "A", "B", "C" };
List<String> list = Arrays.asList(arr);
```

---

### 🔸 **190. Convert List to Array**

```java
List<String> list = Arrays.asList("X", "Y", "Z");
String[] arr = list.toArray(new String[0]);
```

---

### 🔸 **191. Count frequency using HashMap**

```java
String[] arr = { "a", "b", "a", "c", "b" };
Map<String, Integer> freq = new HashMap<>();

for (String s : arr)
    freq.put(s, freq.getOrDefault(s, 0) + 1);

System.out.println(freq); // {a=2, b=2, c=1}
```

---

### 🔸 **192. LinkedList add/remove**

```java
LinkedList<String> list = new LinkedList<>();
list.add("first");
list.addFirst("zero");
list.addLast("last");
list.removeFirst(); // removes "zero"
System.out.println(list);
```

---

Here is your **Java Interview & Practice Questions – Set 12**, focused on **Multithreading and Concurrency** with **pro-level examples and deep explanations**.

---

## ✅ **Java Interview Questions – Set 12: Multithreading & Concurrency**

---

### 🔸 **193. What is a Thread in Java?**

A thread is a lightweight process. Java allows multiple threads to run concurrently, enabling multitasking (like UI + background task).

---

### 🔸 **194. Creating a Thread – Two Ways**

#### 1. **Extending `Thread` class:**

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // never use run()
    }
}
```

#### 2. **Implementing `Runnable` interface:**

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable running: " + Thread.currentThread().getName());
    }
}

public class Test {
    public static void main(String[] args) {
        Thread t2 = new Thread(new MyRunnable());
        t2.start();
    }
}
```

---

### 🔸 **195. Difference: `start()` vs `run()`**

| Method    | Purpose                                                     |
| --------- | ----------------------------------------------------------- |
| `start()` | Creates a new thread, then calls `run()`                    |
| `run()`   | Just calls method in the current thread (no multithreading) |

---

### 🔸 **196. Thread Life Cycle**

| State           | Description                        |
| --------------- | ---------------------------------- |
| New             | Thread is created                  |
| Runnable        | Thread is ready to run             |
| Running         | Thread is executing                |
| Blocked/Waiting | Waiting for monitor/another thread |
| Timed Waiting   | Waiting for specified time         |
| Terminated      | Finished execution or crashed      |

---

### 🔸 **197. Thread Priority Example**

```java
Thread t = new Thread(() -> System.out.println("Running"));
t.setPriority(Thread.MAX_PRIORITY);  // 10
t.start();
```

---

### 🔸 **198. Sleep vs Wait**

| Feature       | `sleep()`            | `wait()`                      |
| ------------- | -------------------- | ----------------------------- |
| Class         | Thread               | Object                        |
| Lock released | ❌ No                 | ✅ Yes                         |
| Usage         | Pause current thread | Thread communication (notify) |

---

### 🔸 **199. Join Example – Wait for thread to finish**

```java
Thread t = new Thread(() -> {
    for (int i = 0; i < 3; i++) {
        System.out.println("Child thread");
    }
});

t.start();
t.join();  // main waits until t finishes
System.out.println("Main thread");
```

---

### 🔸 **200. Synchronization Example (Critical Section)**

```java
class Shared {
    synchronized void printCount() {
        for (int i = 1; i <= 3; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
        }
    }
}

public class Test {
    public static void main(String[] args) {
        Shared obj = new Shared();

        Thread t1 = new Thread(() -> obj.printCount());
        Thread t2 = new Thread(() -> obj.printCount());

        t1.start();
        t2.start();
    }
}
```

✅ `synchronized` ensures that only one thread enters the method at a time.

---

### 🔸 **201. Deadlock Example**

```java
class A {
    synchronized void foo(B b) {
        System.out.println("Thread A trying to call B.last()");
        b.last();
    }

    synchronized void last() {
        System.out.println("Inside A.last()");
    }
}

class B {
    synchronized void bar(A a) {
        System.out.println("Thread B trying to call A.last()");
        a.last();
    }

    synchronized void last() {
        System.out.println("Inside B.last()");
    }
}

public class DeadlockDemo {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();

        new Thread(() -> a.foo(b)).start();
        new Thread(() -> b.bar(a)).start();
    }
}
```

❌ Deadlock: both threads are waiting for each other forever.

---

### 🔸 **202. Volatile Keyword**

```java
class Demo {
    volatile boolean running = true;

    void run() {
        while (running) {
            // runs until another thread sets running = false
        }
    }
}
```

✅ Ensures changes are visible across threads (avoids caching issues).

---

### 🔸 **203. Daemon Thread Example**

```java
Thread t = new Thread(() -> {
    while (true) System.out.println("Daemon thread running...");
});
t.setDaemon(true);
t.start();
```

Daemon threads die when the main thread dies.

---

### 🔸 **204. Thread Pooling – ExecutorService**

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

executor.submit(() -> System.out.println("Task 1"));
executor.submit(() -> System.out.println("Task 2"));
executor.shutdown();
```

✅ More efficient than creating many threads manually.

---

### 🔸 **205. Callable with Future**

```java
ExecutorService ex = Executors.newSingleThreadExecutor();

Callable<String> task = () -> "Result";
Future<String> future = ex.submit(task);

System.out.println(future.get()); // Output: Result
ex.shutdown();
```

✅ `Callable` can return results or throw exceptions, unlike `Runnable`.

---
Here is your **Java Interview & Practice Questions – Set 13**, focused on **Java 8 Features: Lambda, Stream API, Functional Interfaces, Method References, Optional, and more** with **pro-level examples and mastery-level explanations**.

---

## ✅ **Java Interview Questions – Set 13: Java 8 Functional Programming**

---

### 🔸 **206. What are the major features introduced in Java 8?**

* Lambda Expressions
* Functional Interfaces
* Stream API
* Method References
* Default & Static Methods in Interfaces
* Optional Class
* Date & Time API (java.time)

---

### 🔸 **207. Lambda Expression in Java**

Lambda expressions allow treating functionality as a method argument.

**Syntax:**

```java
(parameter) -> { body }
```

**Example:**

```java
interface Addable {
    int add(int a, int b);
}

public class Test {
    public static void main(String[] args) {
        Addable add = (a, b) -> a + b;
        System.out.println(add.add(10, 20)); // 30
    }
}
```

✅ Lambdas work best with **functional interfaces** (interfaces with exactly one abstract method).

---

### 🔸 **208. Functional Interface**

An interface with **only one abstract method**.

**Examples:**

* `Runnable`
* `Comparable`
* Custom annotated with `@FunctionalInterface`

```java
@FunctionalInterface
interface Greetable {
    void greet(String name);
}
```

---

### 🔸 **209. Method Reference**

A shorthand for calling a method using `::`

```java
class Helper {
    public static void print(String msg) {
        System.out.println(msg);
    }
}

public class Test {
    public static void main(String[] args) {
        Consumer<String> c = Helper::print;
        c.accept("Hello");
    }
}
```

✅ Types:

* Static Method: `ClassName::staticMethod`
* Instance Method: `obj::instanceMethod`
* Constructor: `ClassName::new`

---

### 🔸 **210. Stream API Example**

Used to process collections in a functional style.

```java
List<String> names = Arrays.asList("Alex", "Bob", "Alice");

names.stream()
     .filter(name -> name.startsWith("A"))
     .map(String::toUpperCase)
     .forEach(System.out::println);  // Output: ALEX, ALICE
```

✅ Lazily processed, fast, parallelizable.

---

### 🔸 **211. Stream API: Common Operations**

| Operation Type | Examples                            |
| -------------- | ----------------------------------- |
| Intermediate   | `filter()`, `map()`, `sorted()`     |
| Terminal       | `forEach()`, `collect()`, `count()` |

---

### 🔸 **212. `Optional` Class – Avoid NullPointerException**

```java
Optional<String> name = Optional.of("Alice");
System.out.println(name.orElse("Default")); // Alice

Optional<String> empty = Optional.empty();
System.out.println(empty.orElse("Default")); // Default
```

✅ `Optional` helps write **null-safe** code.

---

### 🔸 **213. Default Methods in Interfaces**

```java
interface Vehicle {
    default void start() {
        System.out.println("Vehicle started");
    }
}
```

✅ Allows interface evolution without breaking existing code.

---

### 🔸 **214. Static Methods in Interfaces**

```java
interface Utility {
    static int square(int x) {
        return x * x;
    }
}
```

✅ Called using: `Utility.square(5)`

---

### 🔸 **215. `Predicate` Functional Interface**

```java
Predicate<Integer> isEven = x -> x % 2 == 0;
System.out.println(isEven.test(10)); // true
```

---

### 🔸 **216. `Function<T, R>` Functional Interface**

```java
Function<String, Integer> length = s -> s.length();
System.out.println(length.apply("Hello")); // 5
```

---

### 🔸 **217. `Consumer<T>` Functional Interface**

```java
Consumer<String> print = s -> System.out.println(s);
print.accept("Message");
```

---

### 🔸 **218. `Supplier<T>` Functional Interface**

```java
Supplier<Double> random = () -> Math.random();
System.out.println(random.get());
```

---

### 🔸 **219. Combining Predicates**

```java
Predicate<Integer> isPositive = x -> x > 0;
Predicate<Integer> isEven = x -> x % 2 == 0;

Predicate<Integer> posAndEven = isPositive.and(isEven);

System.out.println(posAndEven.test(4));  // true
```

---

### 🔸 **220. Stream Collectors Example**

```java
List<String> list = Arrays.asList("a", "bb", "ccc");

List<Integer> lengths = list.stream()
                            .map(String::length)
                            .collect(Collectors.toList());

System.out.println(lengths);  // [1, 2, 3]
```

---
Here is your **Java Interview & Practice Questions – Set 14**, focused on **Java Collections Framework (List, Set, Map, Queue, Iterator, Comparable/Comparator, Hashing, Generics)** with pro-level to mastery-level explanation and examples.

---

## ✅ **Java Interview Questions – Set 14: Collections & Generics Deep Dive**

---

### 🔸 **221. What is the Java Collections Framework?**

A **hierarchy of interfaces and classes** that support **data structures** like:

* `List`
* `Set`
* `Map`
* `Queue`
* Along with utilities (`Collections`, `Arrays`)

It provides **standardized** data manipulation techniques: storing, retrieving, searching, sorting.

---

### 🔸 **222. What is the difference between Collection and Collections?**

| Term          | Description                                                                     |
| ------------- | ------------------------------------------------------------------------------- |
| `Collection`  | Interface – base of List, Set, Queue                                            |
| `Collections` | Utility class – contains static methods like `sort()`, `reverse()`, `shuffle()` |

---

### 🔸 **223. List vs Set vs Map**

| Feature    | `List`        | `Set`            | `Map`                   |
| ---------- | ------------- | ---------------- | ----------------------- |
| Duplicates | Allowed       | Not allowed      | Only keys unique        |
| Ordered?   | Yes (Indexed) | No (Some sorted) | No (Some sorted by key) |
| Example    | `ArrayList`   | `HashSet`        | `HashMap`               |

---

### 🔸 **224. ArrayList Example**

```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list.get(0)); // Java
```

✅ Backed by an array, resizable, fast read, slower insert/delete in middle.

---

### 🔸 **225. HashSet Example**

```java
Set<String> set = new HashSet<>();
set.add("Java");
set.add("Java");  // Duplicate ignored
System.out.println(set.size()); // 1
```

✅ Uses **Hashing**, no duplicates, no ordering.

---

### 🔸 **226. HashMap Example**

```java
Map<Integer, String> map = new HashMap<>();
map.put(1, "One");
map.put(2, "Two");
System.out.println(map.get(1)); // One
```

✅ Key-value pairs, fast access via hashing.

---

### 🔸 **227. TreeSet vs HashSet**

* `HashSet`: Unordered, faster
* `TreeSet`: Sorted (uses Red-Black tree), slower

---

### 🔸 **228. TreeMap vs HashMap**

* `HashMap`: Unordered
* `TreeMap`: Sorted by keys

---

### 🔸 **229. Queue Example (FIFO)**

```java
Queue<String> queue = new LinkedList<>();
queue.add("A");
queue.add("B");
System.out.println(queue.poll()); // A
```

✅ `Queue`: FIFO – First In First Out
✅ `Deque`: Double-ended Queue

---

### 🔸 **230. PriorityQueue Example**

```java
Queue<Integer> pq = new PriorityQueue<>();
pq.add(10);
pq.add(5);
System.out.println(pq.poll()); // 5 (min first)
```

✅ Automatically sorted in natural order (min-heap).

---

### 🔸 **231. Iterator vs ListIterator**

| Feature       | `Iterator`     | `ListIterator`              |
| ------------- | -------------- | --------------------------- |
| Direction     | Forward only   | Forward & backward          |
| Supports Add? | No             | Yes                         |
| Use with      | Any Collection | Only `List` implementations |

---

### 🔸 **232. `Comparable` vs `Comparator`**

| Feature      | `Comparable`          | `Comparator`      |
| ------------ | --------------------- | ----------------- |
| Interface in | `java.lang`           | `java.util`       |
| Method       | `compareTo(Object o)` | `compare(o1, o2)` |
| Example use  | Natural sorting       | Custom sorting    |

---

### 🔸 **233. Example: Comparable**

```java
class Student implements Comparable<Student> {
    int id;
    Student(int id) { this.id = id; }

    public int compareTo(Student s) {
        return this.id - s.id;
    }
}
```

---

### 🔸 **234. Example: Comparator**

```java
Comparator<Student> byId = (a, b) -> a.id - b.id;
```

✅ Use Comparator when you want to **sort differently** than natural ordering.

---

### 🔸 **235. Generics Example**

```java
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123); // Compile error

for(String s : list) {
    System.out.println(s.toUpperCase());
}
```

✅ Generics provide **type-safety at compile time**.

---

### 🔸 **236. Bounded Type Parameters in Generics**

```java
class Box<T extends Number> {
    T value;
    void show() { System.out.println(value); }
}
```

✅ Ensures only `Number` or subclass types can be used.

---

### 🔸 **237. Wildcards in Generics**

| Syntax          | Meaning                           |
| --------------- | --------------------------------- |
| `<?>`           | Unknown type                      |
| `<? extends T>` | Upper bound (subclasses of `T`)   |
| `<? super T>`   | Lower bound (superclasses of `T`) |

```java
List<? extends Number> list = new ArrayList<Integer>();
```

---

### 🔸 **238. `Collections.sort()` vs `Arrays.sort()`**

* `Collections.sort(List)` – sorts list using natural/comparator order
* `Arrays.sort(array)` – sorts array

---

### 🔸 **239. Fail-Fast vs Fail-Safe Iterator**

| Fail-Fast                                | Fail-Safe                       |
| ---------------------------------------- | ------------------------------- |
| Throws `ConcurrentModificationException` | No Exception                    |
| Example: `ArrayList.iterator()`          | Example: `CopyOnWriteArrayList` |

---

### 🔸 **240. `HashCode()` and `equals()`**

```java
class Student {
    int id;
    public boolean equals(Object o) {
        return (o instanceof Student) && (id == ((Student)o).id);
    }
    public int hashCode() {
        return id;
    }
}
```

✅ Required for **HashMap**, **HashSet**, etc. to work properly.

---

Here is your **Java Interview & Practice Questions – Set 15**, focused on **Exception Handling**, including `try-catch`, custom exceptions, multi-catch, and advanced handling concepts.

---

## ✅ **Java Interview Questions – Set 15: Exception Handling Mastery**

---

### 🔸 **241. What is an Exception in Java?**

An **Exception** is an event that disrupts the normal flow of a program.

Java separates errors into:

* **Checked Exceptions**: Must be handled (`IOException`, `SQLException`)
* **Unchecked Exceptions**: Runtime exceptions (`NullPointerException`, `ArithmeticException`)
* **Errors**: JVM-related problems (`OutOfMemoryError`, `StackOverflowError`)

---

### 🔸 **242. Java Exception Hierarchy**

```
Object
 └── Throwable
     ├── Error         // Unrecoverable
     └── Exception
         ├── Checked   // Compile-time (IOException)
         └── Unchecked // Runtime (NullPointerException)
```

---

### 🔸 **243. Try-Catch Block Example**

```java
try {
    int a = 5 / 0;
} catch (ArithmeticException e) {
    System.out.println("Cannot divide by zero");
}
```

---

### 🔸 **244. Multiple Catch Blocks**

```java
try {
    String s = null;
    s.length();
} catch (ArithmeticException e) {
    System.out.println("Arithmetic");
} catch (NullPointerException e) {
    System.out.println("Null Pointer");
}
```

---

### 🔸 **245. Multi-catch Block (Java 7+)**

```java
try {
    int[] arr = new int[2];
    System.out.println(arr[3]);
} catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
    System.out.println("Multiple exceptions handled");
}
```

---

### 🔸 **246. Finally Block**

```java
try {
    int a = 10;
} finally {
    System.out.println("Finally always executes");
}
```

✅ Even runs when an exception occurs or `return` is called.

---

### 🔸 **247. Return in Try-Finally**

```java
public int test() {
    try {
        return 1;
    } finally {
        return 2;
    }
}
```

🧠 Output: `2`
✔️ `finally` **overrides** `try`’s return value.

---

### 🔸 **248. Throw vs Throws**

| Keyword  | Purpose                                      |
| -------- | -------------------------------------------- |
| `throw`  | Used to **explicitly throw** an exception    |
| `throws` | Declares exceptions that **might be thrown** |

```java
throw new IOException("File error");
public void read() throws IOException {}
```

---

### 🔸 **249. Custom Exception**

```java
class AgeException extends Exception {
    AgeException(String msg) {
        super(msg);
    }
}
```

```java
public void checkAge(int age) throws AgeException {
    if (age < 18)
        throw new AgeException("Too young");
}
```

---

### 🔸 **250. Checked vs Unchecked Exceptions**

| Feature              | Checked                       | Unchecked              |
| -------------------- | ----------------------------- | ---------------------- |
| Checked by Compiler? | Yes                           | No                     |
| Must be handled?     | Yes (`try-catch` or `throws`) | Optional               |
| Examples             | `IOException`, `SQLException` | `NullPointerException` |

---

### 🔸 **251. Nested Try-Catch**

```java
try {
    try {
        int x = 10 / 0;
    } catch (ArithmeticException e) {
        System.out.println("Inner catch");
    }
} catch (Exception e) {
    System.out.println("Outer catch");
}
```

✅ Nested structure is valid and useful for layered exception handling.

---

### 🔸 **252. Exception Propagation**

```java
public void a() {
    b(); // Exception propagates here
}
public void b() {
    int x = 1 / 0; // Not handled
}
```

✅ Exception moves up the call stack until caught or the program crashes.

---

### 🔸 **253. Stack Trace**

```java
try {
    int a = 10 / 0;
} catch (Exception e) {
    e.printStackTrace();  // Shows error line & stack
}
```

---

### 🔸 **254. Difference: Error vs Exception**

| `Error`            | `Exception`                           |
| ------------------ | ------------------------------------- |
| JVM issues         | Programmer logic issues               |
| Unrecoverable      | Recoverable                           |
| `OutOfMemoryError` | `IOException`, `NullPointerException` |

---

### 🔸 **255. Catch Block Order**

* Catch block must go **from specific to general**.

```java
catch (IOException e) {}  
catch (Exception e) {} // ✅ Valid

catch (Exception e) {}  
catch (IOException e) {} // ❌ Compile-time error
```

---

### 🔸 **256. Best Practices**

* Catch only those exceptions you can handle.
* Never use empty catch blocks.
* Use **custom exceptions** for domain-specific logic.
* Always close resources in `finally` or use **try-with-resources**.

---

### 🔸 **257. Try-with-resources (Java 7+)**

```java
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
```

✅ Auto-closes the resource after use. Best for file handling, DB, sockets.

---

### 🔸 **258. Suppressed Exceptions**

If `try` and `finally` both throw exceptions, the exception from `try` is suppressed.

```java
try (A a = new A()) {
    throw new RuntimeException("Main");
}
```

Use `Throwable.getSuppressed()` to retrieve suppressed exceptions.

---

### 🔸 **259. Rethrowing Exceptions**

```java
try {
    // risky
} catch (IOException e) {
    log(e);
    throw e; // Rethrow
}
```

Used when you want to **log + propagate** the exception further.

---

### 🔸 **260. Can we catch multiple exceptions in one catch block?**

Yes, using `|` operator (multi-catch):

```java
catch (IOException | SQLException e) {
    System.out.println(e.getMessage());
}
```

---

Here is your **Java Interview & Practice Questions – Set 16**, focused on **Multithreading** – including Thread Lifecycle, `Runnable`, `synchronized`, concurrency, and inter-thread communication.

---

## ✅ **Java Interview Questions – Set 16: Multithreading & Concurrency**

---

### 🔸 **261. What is Multithreading in Java?**

Multithreading allows multiple **threads to run concurrently** within a single Java process.

✅ Improves CPU utilization
✅ Ideal for I/O, background tasks, UI apps

---

### 🔸 **262. Thread vs Process**

| Thread              | Process         |
| ------------------- | --------------- |
| Lightweight         | Heavyweight     |
| Shared memory       | Isolated memory |
| Fast context switch | Slower          |

---

### 🔸 **263. Thread Lifecycle States**

```
New → Runnable → Running → Waiting/Blocked → Terminated
```

* **New** – Created but not started
* **Runnable** – Ready to run
* **Running** – Executing
* **Blocked/Waiting** – Paused or waiting
* **Terminated** – Finished or crashed

---

### 🔸 **264. Two Ways to Create Threads**

#### 1. **Extend Thread class**

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running");
    }
}
new MyThread().start();
```

#### 2. **Implement Runnable**

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable running");
    }
}
new Thread(new MyRunnable()).start();
```

✅ Runnable is preferred in real-world apps (more flexible)

---

### 🔸 **265. `start()` vs `run()`**

* `start()` → Starts a new thread, invokes `run()`
* `run()` → Just a normal method call (no thread)

```java
t.start(); // ✅ runs in new thread
t.run();   // ❌ runs in current thread
```

---

### 🔸 **266. Thread Sleep Example**

```java
for (int i = 1; i <= 5; i++) {
    System.out.println(i);
    Thread.sleep(1000); // 1 second
}
```

✅ Checked exception → must handle `InterruptedException`

---

### 🔸 **267. Thread Priority**

```java
t.setPriority(Thread.MAX_PRIORITY); // 10
t.setPriority(Thread.MIN_PRIORITY); // 1
```

🧠 JVM **may** schedule high-priority threads first (not guaranteed)

---

### 🔸 **268. `isAlive()`**

```java
Thread t = new MyThread();
t.start();
System.out.println(t.isAlive()); // true if running
```

---

### 🔸 **269. Synchronization**

Used to **prevent race conditions** when multiple threads access shared data.

```java
synchronized void increment() {
    count++;
}
```

✅ Ensures **only one thread** enters at a time

---

### 🔸 **270. Static Synchronization**

```java
synchronized static void log() {
    // class-level lock
}
```

Applies lock on the **class**, not instance.

---

### 🔸 **271. Synchronized Block**

```java
synchronized (this) {
    // critical section
}
```

✅ More efficient than syncing the whole method.

---

### 🔸 **272. Deadlock Example**

```java
Thread1 locks A then B  
Thread2 locks B then A  
→ Both wait forever
```

🛑 Avoid by:

* Lock ordering
* Using `tryLock()` (with timeout)

---

### 🔸 **273. `join()` Method**

```java
t1.start();
t1.join(); // main thread waits for t1 to finish
```

Used for **thread sequencing**.

---

### 🔸 **274. Volatile Keyword**

```java
volatile boolean flag = true;
```

✅ Tells JVM to read/write variable **directly from main memory**

Used to avoid **cache inconsistency** in multithreaded environments.

---

### 🔸 **275. Daemon Thread**

```java
Thread t = new Thread();
t.setDaemon(true);
```

✅ Background thread (e.g., garbage collector)
✅ Terminates when all user threads finish

---

### 🔸 **276. Thread Safety**

An object is thread-safe if:

* It behaves correctly when accessed by multiple threads.
* Java provides thread-safe classes: `Vector`, `Hashtable`, `AtomicInteger`.

---

### 🔸 **277. Inter-thread Communication (`wait`, `notify`)**

Used to coordinate threads.

```java
synchronized(obj) {
    obj.wait();   // thread waits
    obj.notify(); // wakes one thread
}
```

Must be inside **synchronized block**, or `IllegalMonitorStateException`

---

### 🔸 **278. `wait()` vs `sleep()`**

| Feature       | `wait()`          | `sleep()`    |
| ------------- | ----------------- | ------------ |
| Belongs to    | Object class      | Thread class |
| Releases lock | ✅ Yes             | ❌ No         |
| Used for      | Inter-thread sync | Delay        |

---

### 🔸 **279. Reentrant Lock (Java 5+)**

```java
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    // critical section
} finally {
    lock.unlock();
}
```

✅ Advanced lock with:

* Timeout
* Fairness
* Interruptibility

---

### 🔸 **280. Thread Pool (ExecutorService)**

```java
ExecutorService service = Executors.newFixedThreadPool(5);
service.execute(() -> System.out.println("Task"));
```

✅ Reuses threads → faster & memory-efficient
✅ Better than creating new threads for each task

---

Here is your **Java Interview & Practice Questions – Set 17**, continuing with **Java 8 Features** including **Lambda Expressions, Stream API, Functional Interfaces, Optional**, and related topics — all explained deeply with pro-level examples.

---

## ✅ **Java Interview & Practice Questions – Set 17: Java 8 Functional Programming Mastery**

---

### 🔸 **281. What is a Lambda Expression?**

A concise way to represent an anonymous function (a block of code as an expression).

**Syntax:**

```java
(parameters) -> expression
(parameters) -> { statements; }
```

---

### 🔸 **282. Example of Lambda Expression**

```java
Runnable r = () -> System.out.println("Running");
new Thread(r).start();
```

✅ Shorter and clearer than anonymous classes.

---

### 🔸 **283. Functional Interface**

An interface with exactly one abstract method.

**Example:**

```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}
```

---

### 🔸 **284. Using Lambda with Functional Interface**

```java
Calculator add = (a, b) -> a + b;
System.out.println(add.calculate(5, 3));  // 8
```

---

### 🔸 **285. Common Functional Interfaces**

| Interface   | Method        | Description                   |
| ----------- | ------------- | ----------------------------- |
| `Predicate` | `test(T t)`   | Returns boolean condition     |
| `Function`  | `apply(T t)`  | Returns transformed object    |
| `Consumer`  | `accept(T t)` | Performs action, returns void |
| `Supplier`  | `get()`       | Supplies a value, no input    |

---

### 🔸 **286. Example: Predicate**

```java
Predicate<String> isEmpty = s -> s.isEmpty();
System.out.println(isEmpty.test(""));  // true
```

---

### 🔸 **287. Example: Function**

```java
Function<String, Integer> length = s -> s.length();
System.out.println(length.apply("Hello"));  // 5
```

---

### 🔸 **288. Method Reference**

A shorter form of lambda when method already exists.

```java
List<String> names = Arrays.asList("John", "Jane");
names.forEach(System.out::println);
```

Types:

* Static method: `ClassName::staticMethod`
* Instance method: `instance::method`
* Constructor: `ClassName::new`

---

### 🔸 **289. Stream API Basics**

Allows processing sequences of elements with operations like filter, map, reduce.

```java
List<Integer> nums = Arrays.asList(1,2,3,4,5);
nums.stream()
    .filter(n -> n % 2 == 0)
    .forEach(System.out::println);  // 2 4
```

---

### 🔸 **290. Intermediate vs Terminal Operations**

| Operation Type | Examples                            |
| -------------- | ----------------------------------- |
| Intermediate   | `filter()`, `map()`, `sorted()`     |
| Terminal       | `forEach()`, `collect()`, `count()` |

Intermediate ops are lazy; terminal ops trigger processing.

---

### 🔸 **291. Collecting Stream Results**

```java
List<String> collected = Stream.of("a", "b", "c")
    .map(String::toUpperCase)
    .collect(Collectors.toList());

System.out.println(collected);  // [A, B, C]
```

---

### 🔸 **292. Optional Class Usage**

Avoid NullPointerExceptions by wrapping possibly null values.

```java
Optional<String> opt = Optional.ofNullable(null);
System.out.println(opt.orElse("Default"));  // Default
```

---

### 🔸 **293. Chaining Optional**

```java
Optional<String> opt = Optional.of("abc");
opt.map(String::toUpperCase)
   .filter(s -> s.startsWith("A"))
   .ifPresent(System.out::println);  // ABC
```

---

### 🔸 **294. Parallel Streams**

Enable easy parallelism.

```java
List<Integer> list = Arrays.asList(1,2,3,4,5);
list.parallelStream()
    .forEach(System.out::println);
```

---

### 🔸 **295. Default and Static Methods in Interfaces**

```java
interface Vehicle {
    default void start() {
        System.out.println("Vehicle starting");
    }
    static void stop() {
        System.out.println("Vehicle stopped");
    }
}
```

---

### 🔸 **296. Why use Functional Programming in Java?**

* Concise code
* Easier parallel processing
* More readable and declarative

---

Here is your **Java Interview & Practice Questions – Set 18**, focused on **Java Design Patterns** — including Singleton, Factory, Builder, Observer, and more, with deep explanations and pro-level examples.

---

## ✅ **Java Interview & Practice Questions – Set 18: Design Patterns Mastery**

---

### 🔸 **297. What is a Design Pattern?**

A **design pattern** is a reusable solution to a common software design problem.

Helps improve code readability, maintainability, and flexibility.

---

### 🔸 **298. Singleton Pattern**

Ensures a class has only **one instance** and provides a global point of access.

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}  // private constructor

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

✅ Thread-safe version: Use `synchronized` or **Initialization-on-demand holder idiom**.

---

### 🔸 **299. Factory Pattern**

Creates objects without exposing creation logic.

```java
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() { System.out.println("Circle"); }
}

class ShapeFactory {
    public static Shape getShape(String type) {
        if ("circle".equalsIgnoreCase(type)) return new Circle();
        // add more shapes
        return null;
    }
}
```

Usage:

```java
Shape s = ShapeFactory.getShape("circle");
s.draw();
```

---

### 🔸 **300. Builder Pattern**

Creates complex objects step-by-step.

```java
class House {
    private int windows;
    private int doors;

    private House(Builder builder) {
        this.windows = builder.windows;
        this.doors = builder.doors;
    }

    static class Builder {
        private int windows;
        private int doors;

        Builder setWindows(int windows) {
            this.windows = windows;
            return this;
        }

        Builder setDoors(int doors) {
            this.doors = doors;
            return this;
        }

        House build() {
            return new House(this);
        }
    }
}
```

Usage:

```java
House house = new House.Builder()
                .setWindows(4)
                .setDoors(2)
                .build();
```

---

### 🔸 **301. Observer Pattern**

Defines a **one-to-many dependency** so that when one object changes state, all dependents are notified.

```java
interface Observer {
    void update(String message);
}

class Subject {
    private List<Observer> observers = new ArrayList<>();
    void register(Observer o) { observers.add(o); }
    void notifyAllObservers(String msg) {
        for (Observer o : observers) o.update(msg);
    }
}
```

---

### 🔸 **302. Decorator Pattern**

Adds behavior to objects dynamically.

```java
interface Coffee {
    String getDescription();
    double cost();
}

class SimpleCoffee implements Coffee {
    public String getDescription() { return "Simple Coffee"; }
    public double cost() { return 5; }
}

class MilkDecorator implements Coffee {
    private Coffee coffee;
    MilkDecorator(Coffee coffee) { this.coffee = coffee; }

    public String getDescription() { return coffee.getDescription() + ", Milk"; }
    public double cost() { return coffee.cost() + 1; }
}
```

---

### 🔸 **303. Strategy Pattern**

Defines a family of algorithms, encapsulates each one, and makes them interchangeable.

```java
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardStrategy implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid " + amount + " with credit card.");
    }
}
```

---

### 🔸 **304. Adapter Pattern**

Allows incompatible interfaces to work together.

```java
interface MediaPlayer {
    void play(String audioType, String fileName);
}

class MediaAdapter implements MediaPlayer {
    AdvancedMediaPlayer advancedMusicPlayer;

    public MediaAdapter(String audioType){
        if(audioType.equalsIgnoreCase("vlc") ){
            advancedMusicPlayer = new VlcPlayer();
        }
        else if (audioType.equalsIgnoreCase("mp4")){
            advancedMusicPlayer = new Mp4Player();
        }
    }
    public void play(String audioType, String fileName) {
        if(audioType.equalsIgnoreCase("vlc")){
            advancedMusicPlayer.playVlc(fileName);
        }
        else if(audioType.equalsIgnoreCase("mp4")){
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}
```

---

### 🔸 **305. Advantages of Design Patterns**

* Code reuse
* Easier to understand
* Faster development
* Reduces technical debt

---

Here is your **Java Interview & Practice Questions – Set 19**, focused on **Advanced Java Concepts** like Reflection, Annotation Processing, and Dynamic Proxy — explained deeply with pro-level examples.

---

## ✅ **Java Interview & Practice Questions – Set 19: Advanced Java Concepts Mastery**

---

### 🔸 **306. What is Reflection in Java?**

Reflection allows inspection and modification of **classes, methods, fields at runtime**, even if not known at compile-time.

Useful for frameworks, libraries, debugging, testing.

---

### 🔸 **307. Basic Reflection Example**

```java
Class<?> clazz = Class.forName("java.util.ArrayList");
System.out.println("Class name: " + clazz.getName());

Method[] methods = clazz.getDeclaredMethods();
for (Method m : methods) {
    System.out.println(m.getName());
}
```

---

### 🔸 **308. Access Private Fields Using Reflection**

```java
class Person {
    private String name = "John";
}

Person p = new Person();
Field field = p.getClass().getDeclaredField("name");
field.setAccessible(true);
System.out.println(field.get(p));  // John
field.set(p, "Jane");
System.out.println(field.get(p));  // Jane
```

---

### 🔸 **309. What are Annotations?**

Metadata to provide data about program elements (classes, methods, variables).

Example: `@Override`, `@Deprecated`

---

### 🔸 **310. Custom Annotation**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
    String value() default "default";
}
```

---

### 🔸 **311. Processing Annotations via Reflection**

```java
Method m = MyClass.class.getMethod("myMethod");
if (m.isAnnotationPresent(Test.class)) {
    Test t = m.getAnnotation(Test.class);
    System.out.println(t.value());
}
```

---

### 🔸 **312. Dynamic Proxy**

Creates **proxy instances** dynamically to intercept method calls at runtime.

```java
interface Hello {
    void sayHello();
}

class HelloImpl implements Hello {
    public void sayHello() {
        System.out.println("Hello world");
    }
}

InvocationHandler handler = (proxy, method, args) -> {
    System.out.println("Before method");
    Object result = method.invoke(new HelloImpl(), args);
    System.out.println("After method");
    return result;
};

Hello proxy = (Hello) Proxy.newProxyInstance(
    Hello.class.getClassLoader(),
    new Class<?>[] {Hello.class},
    handler);

proxy.sayHello();
```

---

### 🔸 **313. Use Cases of Dynamic Proxy**

* Implement AOP (Aspect-Oriented Programming)
* Lazy loading
* Logging & auditing
* Security checks

---

### 🔸 **314. Limitations of Reflection**

* Performance overhead
* Breaks encapsulation
* Unsafe if misused

---

### 🔸 **315. Summary**

* Reflection inspects/modifies runtime behavior
* Annotations add metadata, can be custom
* Dynamic proxies allow method interception dynamically

---
Here is your **Java Interview & Practice Questions – Set 20**, focused on **Java Concurrency Utilities** — `Executors`, `Locks`, `Atomic Variables`, `CountDownLatch`, `CyclicBarrier`, and more — with deep explanations and pro-level examples.

---

## ✅ **Java Interview & Practice Questions – Set 20: Java Concurrency Utilities Mastery**

---

### 🔸 **316. What is Executor Framework?**

A higher-level replacement for creating and managing threads.

* Decouples task submission from execution
* Thread pools for resource management

---

### 🔸 **317. Creating a Fixed Thread Pool**

```java
ExecutorService executor = Executors.newFixedThreadPool(3);

for (int i = 0; i < 5; i++) {
    executor.submit(() -> {
        System.out.println("Running: " + Thread.currentThread().getName());
    });
}

executor.shutdown();
```

---

### 🔸 **318. Difference Between `submit()` and `execute()`**

| Method      | Returns    | Usage                      |
| ----------- | ---------- | -------------------------- |
| `execute()` | void       | Runnable tasks             |
| `submit()`  | Future\<?> | Runnable or Callable tasks |

`submit()` returns a `Future` for result or cancellation.

---

### 🔸 **319. Callable and Future**

Callable allows tasks to return a value or throw checked exceptions.

```java
Callable<Integer> task = () -> {
    Thread.sleep(1000);
    return 123;
};

Future<Integer> future = executor.submit(task);
System.out.println(future.get()); // Blocks until result
```

---

### 🔸 **320. ReentrantLock**

A lock with extended capabilities beyond `synchronized`.

```java
ReentrantLock lock = new ReentrantLock();

lock.lock();
try {
    // critical section
} finally {
    lock.unlock();
}
```

Supports fairness, interruptibility, and tryLock with timeout.

---

### 🔸 **321. Atomic Variables**

Classes like `AtomicInteger` provide lock-free thread-safe operations.

```java
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();
System.out.println(count.get());
```

---

### 🔸 **322. CountDownLatch**

Used to make threads wait until a set of operations complete.

```java
CountDownLatch latch = new CountDownLatch(3);

for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        System.out.println("Task done");
        latch.countDown();
    }).start();
}

latch.await();  // Main thread waits
System.out.println("All tasks completed");
```

---

### 🔸 **323. CyclicBarrier**

Makes threads wait for each other at a barrier point repeatedly.

```java
CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println("All parties reached barrier"));

for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        System.out.println("Waiting at barrier");
        barrier.await();
    }).start();
}
```

---

### 🔸 **324. Semaphore**

Controls access to a resource by multiple threads.

```java
Semaphore semaphore = new Semaphore(2);

semaphore.acquire();
try {
    // critical section
} finally {
    semaphore.release();
}
```

---

### 🔸 **325. ExecutorService Shutdown**

* `shutdown()` – no new tasks accepted, waits for running tasks
* `shutdownNow()` – attempts to cancel running tasks

---

### 🔸 **326. ThreadPoolExecutor Customization**

Allows tuning core pool size, max size, queue, and rejection policy.

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 10, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(100),
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.CallerRunsPolicy());
```

---

### 🔸 **327. Why Use Concurrency Utilities?**

* More control over threading
* Improved performance and scalability
* Better resource management

---

Here is your **Java Interview & Practice Questions – Set 21**, focused on **Real-world Concurrency Interview Problems & Solutions**, designed to sharpen your problem-solving skills with threads, synchronization, and concurrency.

---

## ✅ **Java Interview & Practice Questions – Set 21: Concurrency Problems & Solutions**

---

### 🔸 **328. Producer-Consumer Problem**

**Problem:** Two threads, Producer and Consumer, share a buffer. Producer produces data, Consumer consumes it.

**Solution: Use `wait()` and `notify()` for coordination**

```java
class Buffer {
    private int data;
    private boolean available = false;

    public synchronized void produce(int value) throws InterruptedException {
        while (available) wait();
        data = value;
        available = true;
        notify();
    }

    public synchronized int consume() throws InterruptedException {
        while (!available) wait();
        available = false;
        notify();
        return data;
    }
}
```

---

### 🔸 **329. Deadlock Explanation and Avoidance**

* **Deadlock:** Threads wait forever for each other’s locks.

**Avoidance:**

* Acquire locks in the same order
* Use `tryLock()` with timeout
* Minimize lock scope

---

### 🔸 **330. Thread-safe Singleton**

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```

---

### 🔸 **331. How to stop a thread safely?**

* Use a **volatile boolean flag**

```java
volatile boolean running = true;

public void run() {
    while (running) {
        // work
    }
}

public void stopThread() {
    running = false;
}
```

---

### 🔸 **332. Explain Thread Interruption**

* Thread interruption is cooperative; thread checks `Thread.interrupted()` flag

```java
if (Thread.interrupted()) {
    // clean up and exit
}
```

---

### 🔸 **333. Implementing Read-Write Lock**

Use `ReentrantReadWriteLock` for multiple readers or exclusive writers.

```java
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

rwLock.readLock().lock();
try {
    // read data
} finally {
    rwLock.readLock().unlock();
}

rwLock.writeLock().lock();
try {
    // write data
} finally {
    rwLock.writeLock().unlock();
}
```

---

### 🔸 **334. Thread Local Variables**

Each thread has its own copy of a variable.

```java
ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 1);
```

---

### 🔸 **335. How to avoid race conditions?**

* Use synchronization (`synchronized`, `Lock`)
* Use atomic variables (`AtomicInteger`)
* Use immutable objects

---

### 🔸 **336. Explain Fork/Join Framework**

Breaks task into smaller subtasks recursively for parallel processing.

---

### 🔸 **337. Difference between `notify()` and `notifyAll()`**

* `notify()` wakes one waiting thread
* `notifyAll()` wakes all waiting threads

Use `notifyAll()` to avoid missed signals in complex situations.

---

Here is your **Java Interview & Practice Questions – Set 22**, focused on **Java I/O and NIO Deep Dive**, covering file streams, buffers, channels, selectors, and practical examples.

---

## ✅ **Java Interview & Practice Questions – Set 22: Java I/O & NIO Mastery**

---

### 🔸 **338. What is Java I/O?**

Java I/O handles input and output operations — reading/writing data to files, console, network.

---

### 🔸 **339. Streams in Java I/O**

* **InputStream** / **OutputStream** — byte-oriented
* **Reader** / **Writer** — character-oriented

Example: Reading a file using FileInputStream

```java
FileInputStream fis = new FileInputStream("file.txt");
int data;
while ((data = fis.read()) != -1) {
    System.out.print((char) data);
}
fis.close();
```

---

### 🔸 **340. Buffered Streams**

Wrap streams with buffer to improve efficiency.

```java
BufferedReader br = new BufferedReader(new FileReader("file.txt"));
String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}
br.close();
```

---

### 🔸 **341. Java NIO Overview**

New IO (NIO) provides non-blocking, buffer-oriented, multiplexed I/O with Channels and Selectors.

---

### 🔸 **342. ByteBuffer**

Core buffer in NIO, holds bytes and supports relative and absolute read/write.

```java
ByteBuffer buffer = ByteBuffer.allocate(1024);
buffer.put((byte) 10);
buffer.flip();
System.out.println(buffer.get());
```

---

### 🔸 **343. Channel**

Represents open connection to entity (file, socket) for data transfer.

```java
FileChannel channel = new FileInputStream("file.txt").getChannel();
ByteBuffer buffer = ByteBuffer.allocate(1024);
channel.read(buffer);
```

---

### 🔸 **344. Selector**

Multiplexes multiple channels — monitors multiple channels for events.

---

### 🔸 **345. Non-blocking Mode**

Channels can be in blocking or non-blocking mode. Non-blocking allows a thread to continue while IO operation is pending.

---

### 🔸 **346. Scatter/Gather IO**

* **Scatter:** Reads data into multiple buffers
* **Gather:** Writes data from multiple buffers

---

### 🔸 **347. MappedByteBuffer**

Memory-mapped file for high-performance file access.

```java
RandomAccessFile raf = new RandomAccessFile("file.txt", "rw");
FileChannel channel = raf.getChannel();
MappedByteBuffer mbb = channel.map(FileChannel.MapMode.READ_WRITE, 0, raf.length());
```

---

### 🔸 **348. Example: Writing with FileChannel**

```java
String data = "Hello NIO";
ByteBuffer buffer = ByteBuffer.wrap(data.getBytes());
FileChannel channel = new FileOutputStream("nio.txt").getChannel();
channel.write(buffer);
channel.close();
```

---

### 🔸 **349. Advantages of NIO**

* Better scalability
* Non-blocking IO
* Efficient buffer management
* Supports multiplexing for servers

---

Here is your **Java Interview & Practice Questions – Set 23**, focused on **More Advanced Java 8+ Features and Best Practices** with deep explanations and examples.

---

## ✅ **Java Interview & Practice Questions – Set 23: Advanced Java 8+ Features Mastery**

---

### 🔸 **350. Optional Enhancements (Java 9+)**

* `Optional.or()` — supply alternative optional
* `Optional.ifPresentOrElse()` — execute action or fallback
* `Optional.stream()` — treat optional as stream

```java
Optional<String> opt = Optional.of("Java");
opt.ifPresentOrElse(
  System.out::println,
  () -> System.out.println("No value"));
```

---

### 🔸 **351. LocalDate, LocalTime, LocalDateTime**

Java 8 Date-Time API replaces old `Date`/`Calendar`.

```java
LocalDate date = LocalDate.now();
LocalTime time = LocalTime.now();
LocalDateTime dateTime = LocalDateTime.now();
```

---

### 🔸 **352. DateTime Formatting**

```java
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");
String formatted = dateTime.format(formatter);
System.out.println(formatted);
```

---

### 🔸 **353. New String Methods**

* `isBlank()` — true if empty or whitespace only
* `lines()` — returns stream of lines
* `repeat(int)` — repeat string

```java
String s = "  ";
System.out.println(s.isBlank());  // true
```

---

### 🔸 **354. Collection Factory Methods**

Immutable collections factory methods:

```java
List<String> list = List.of("a", "b", "c");
Set<Integer> set = Set.of(1, 2, 3);
```

---

### 🔸 **355. Enhanced Switch (Java 12+)**

```java
String day = "MON";
String result = switch(day) {
    case "MON", "TUE" -> "Weekday";
    case "SAT", "SUN" -> "Weekend";
    default -> "Unknown";
};
```

---

### 🔸 **356. Text Blocks (Java 13+)**

Multi-line string literals:

```java
String html = """
    <html>
        <body>
            <p>Hello</p>
        </body>
    </html>
    """;
```

---

### 🔸 **357. Records (Java 14+)**

Compact syntax for immutable data classes.

```java
record Point(int x, int y) {}
Point p = new Point(1, 2);
System.out.println(p.x());
```

---

### 🔸 **358. Sealed Classes (Java 17)**

Restrict which classes can extend/implement a class/interface.

```java
public sealed class Shape permits Circle, Square {}
final class Circle extends Shape {}
final class Square extends Shape {}
```

---

### 🔸 **359. Pattern Matching for instanceof (Java 16+)**

```java
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}
```

---

### 🔸 **360. Helpful Practices**

* Use `var` for local variable type inference (Java 10+)
* Prefer Streams over loops for clean, functional style
* Use `CompletableFuture` for async programming
* Use `Optional` to avoid null checks

---
Here is your **Java Interview & Practice Questions – Set 24**, focused on **Common Java Interview Patterns and Tricks** to help you ace your interviews with practical coding techniques and best practices.

---

## ✅ **Java Interview & Practice Questions – Set 24: Java Interview Patterns & Tricks**

---

### 🔸 **361. Check if String is Palindrome**

```java
public boolean isPalindrome(String s) {
    int i = 0, j = s.length() - 1;
    while (i < j) {
        if (s.charAt(i) != s.charAt(j)) return false;
        i++; j--;
    }
    return true;
}
```

---

### 🔸 **362. Reverse a String**

```java
public String reverse(String s) {
    return new StringBuilder(s).reverse().toString();
}
```

---

### 🔸 **363. Find Duplicate Elements in Array**

```java
public Set<Integer> findDuplicates(int[] arr) {
    Set<Integer> seen = new HashSet<>();
    Set<Integer> duplicates = new HashSet<>();
    for (int n : arr) {
        if (!seen.add(n)) duplicates.add(n);
    }
    return duplicates;
}
```

---

### 🔸 **364. Fibonacci Number (Iterative)**

```java
public int fibonacci(int n) {
    if (n <= 1) return n;
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b;
        a = b; b = c;
    }
    return b;
}
```

---

### 🔸 **365. Find Factorial (Recursive)**

```java
public long factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}
```

---

### 🔸 **366. Check Prime Number**

```java
public boolean isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i <= Math.sqrt(n); i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

---

### 🔸 **367. Swap Two Numbers Without Temp Variable**

```java
a = a + b;
b = a - b;
a = a - b;
```

---

### 🔸 **368. Find Maximum and Minimum in Array**

```java
public int[] findMinMax(int[] arr) {
    int min = arr[0], max = arr[0];
    for (int n : arr) {
        if (n < min) min = n;
        if (n > max) max = n;
    }
    return new int[]{min, max};
}
```

---

### 🔸 **369. Check Anagram Strings**

```java
public boolean isAnagram(String s1, String s2) {
    char[] a = s1.toCharArray();
    char[] b = s2.toCharArray();
    Arrays.sort(a);
    Arrays.sort(b);
    return Arrays.equals(a, b);
}
```

---

### 🔸 **370. Merge Two Sorted Arrays**

```java
public int[] mergeSorted(int[] a, int[] b) {
    int[] merged = new int[a.length + b.length];
    int i = 0, j = 0, k = 0;
    while (i < a.length && j < b.length) {
        merged[k++] = a[i] < b[j] ? a[i++] : b[j++];
    }
    while (i < a.length) merged[k++] = a[i++];
    while (j < b.length) merged[k++] = b[j++];
    return merged;
}
```

---

Here is your **Java Interview & Practice Questions – Set 25**, focused on **Java Performance Tuning, Best Practices, and Optimization Techniques**—important for senior-level or production-ready coding.

---

## ✅ **Java Interview & Practice Questions – Set 25: Java Performance & Best Practices**

---

### 🔹 **371. Use StringBuilder over String Concatenation in Loops**

```java
// ❌ Bad
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i; // creates 1000 new String objects
}

// ✅ Good
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

---

### 🔹 **372. Avoid Creating Unnecessary Objects**

```java
// ❌ Inefficient
String s = new String("hello"); // creates new object unnecessarily

// ✅ Efficient
String s = "hello"; // reuses object from String pool
```

---

### 🔹 **373. Use `equals()` and `==` Properly**

```java
String a = "hello";
String b = new String("hello");

System.out.println(a == b);       // false (different objects)
System.out.println(a.equals(b));  // true (same content)
```

---

### 🔹 **374. Use HashMap vs TreeMap**

* **HashMap** is faster (O(1) for get/put), but unordered.
* **TreeMap** is slower (O(log n)) but maintains sorted keys.

Use **HashMap** for fast access, **TreeMap** when sorted order is needed.

---

### 🔹 **375. Prefer Interfaces for References**

```java
// ✅ Better for flexibility
List<String> list = new ArrayList<>();

// ❌ Less flexible
ArrayList<String> list = new ArrayList<>();
```

---

### 🔹 **376. Mark Classes as Final When Appropriate**

```java
public final class Constants {
    public static final int MAX = 100;
}
```

Marking classes as `final` helps JVM optimization and prevents inheritance.

---

### 🔹 **377. Lazy Initialization**

```java
private static MyObject obj;

public static MyObject getInstance() {
    if (obj == null) {
        obj = new MyObject(); // Only created when needed
    }
    return obj;
}
```

---

### 🔹 **378. Use `try-with-resources`**

```java
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
// Automatically closes the reader
```

---

### 🔹 **379. Avoid Memory Leaks via Listeners**

Always remove unused listeners, especially in Swing/JavaFX or Observers.

```java
button.removeActionListener(listener);
```

---

### 🔹 **380. Use Caching**

```java
Map<Integer, String> cache = new HashMap<>();
if (!cache.containsKey(id)) {
    cache.put(id, db.fetch(id)); // Simulate expensive fetch
}
return cache.get(id);
```

---
Here is your **Java Interview & Practice Questions – Set 26**, focused on **Advanced Multithreading and Concurrency in Java**, perfect for pro-level interviews and real-world applications.

---

## 🚦 **Java Interview & Practice – Set 26: Advanced Multithreading & Concurrency**

---

### 🔹 **381. Difference Between `wait()` and `sleep()`**

| Method    | Belongs To   | Releases Lock | Used For                        |
| --------- | ------------ | ------------- | ------------------------------- |
| `wait()`  | Object class | ✅ Yes         | Thread communication (notify)   |
| `sleep()` | Thread class | ❌ No          | Delay thread (no communication) |

```java
synchronized(obj) {
    obj.wait();   // releases lock and waits
    obj.notify(); // wakes waiting thread
}
```

---

### 🔹 **382. `volatile` vs `synchronized`**

* `volatile`: Ensures visibility (not atomic).
* `synchronized`: Ensures atomicity + visibility.

```java
volatile boolean running = true;

public void run() {
    while (running) {
        // loop will see latest value of running
    }
}
```

---

### 🔹 **383. Use of `ReentrantLock`**

```java
ReentrantLock lock = new ReentrantLock();

lock.lock();
try {
    // critical section
} finally {
    lock.unlock(); // must unlock to prevent deadlocks
}
```

Benefits over `synchronized`: interruptible, timed, and fair locks.

---

### 🔹 **384. Deadlock Example**

```java
class A {
    synchronized void methodA(B b) {
        synchronized(b) {
            System.out.println("Inside A.methodA");
        }
    }
}
```

When two threads lock resources in different order, **deadlock** happens.

---

### 🔹 **385. Thread Pool with `ExecutorService`**

```java
ExecutorService pool = Executors.newFixedThreadPool(3);
pool.submit(() -> System.out.println("Running"));
pool.shutdown();
```

✅ Use thread pool to reuse threads and avoid overhead.

---

### 🔹 **386. `Callable` vs `Runnable`**

* `Runnable` – returns nothing.
* `Callable<V>` – returns result and throws checked exception.

```java
Callable<Integer> task = () -> 10 + 20;
Future<Integer> future = executor.submit(task);
System.out.println(future.get()); // prints 30
```

---

### 🔹 **387. `CountDownLatch` Example**

Used to make one thread wait for others to finish.

```java
CountDownLatch latch = new CountDownLatch(3);

Runnable r = () -> {
    // do work
    latch.countDown(); // reduce count
};

latch.await(); // wait till count = 0
```

---

### 🔹 **388. `CyclicBarrier` Example**

Used to make a group of threads wait together.

```java
CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println("All threads reached"));

Runnable r = () -> {
    // do work
    barrier.await();
};
```

---

### 🔹 **389. `Semaphore` Example**

Control number of threads accessing a resource.

```java
Semaphore semaphore = new Semaphore(2); // max 2 threads

semaphore.acquire(); // wait if limit reached
// use resource
semaphore.release();
```

---

### 🔹 **390. Producer-Consumer Using BlockingQueue**

```java
BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);

Runnable producer = () -> {
    queue.put(1); // waits if full
};

Runnable consumer = () -> {
    queue.take(); // waits if empty
};
```

✅ Avoids need for `wait()`/`notify()`

---

Here is your **Java Interview & Practice Questions – Set 27**, focused on **Java Collections – Deep Practice & Interview Set**.

---

## 📚 **Java Interview & Practice – Set 27: Java Collections Mastery**

---

### 🔹 **391. What is the difference between `ArrayList` and `LinkedList`?**

| Feature       | ArrayList              | LinkedList              |
| ------------- | ---------------------- | ----------------------- |
| Structure     | Dynamic array          | Doubly linked list      |
| Access time   | Fast (O(1))            | Slow (O(n))             |
| Insert/Delete | Slow (shifting needed) | Fast (no shifting)      |
| Memory usage  | Less (no pointers)     | More (stores next/prev) |

---

### 🔹 **392. HashMap Internal Working (Java 8+)**

* Uses array of buckets.
* Bucket is a `LinkedList` or `TreeNode` (tree if >8 entries and size >64).
* Hashing + `equals()` used for key comparison.

```java
Map<String, String> map = new HashMap<>();
map.put("key", "value"); // hashCode() -> index
```

---

### 🔹 **393. Difference Between `HashMap`, `LinkedHashMap`, `TreeMap`**

| Map Type        | Ordering                | Null Key/Value | Time Complexity |
| --------------- | ----------------------- | -------------- | --------------- |
| `HashMap`       | No order                | 1 null key     | O(1)            |
| `LinkedHashMap` | Insertion order         | 1 null key     | O(1)            |
| `TreeMap`       | Sorted (natural/custom) | No null key    | O(log n)        |

---

### 🔹 **394. Fail-Fast vs Fail-Safe**

* **Fail-Fast**: Throws `ConcurrentModificationException`
  Example: `ArrayList`, `HashMap` (iterator)

* **Fail-Safe**: No exception, works on copy
  Example: `ConcurrentHashMap`, `CopyOnWriteArrayList`

---

### 🔹 **395. How does `HashSet` work internally?**

`HashSet` = uses `HashMap` internally (key as element, value as dummy)

```java
Set<String> set = new HashSet<>();
set.add("a"); // internally: map.put("a", PRESENT);
```

---

### 🔹 **396. PriorityQueue Example**

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.add(10); pq.add(5); pq.add(20);

System.out.println(pq.poll()); // 5 (min-heap)
```

Use `Comparator` for custom sort order.

---

### 🔹 **397. Difference Between `Iterator` and `ListIterator`**

| Feature         | Iterator        | ListIterator       |
| --------------- | --------------- | ------------------ |
| Direction       | Forward only    | Forward + backward |
| Add/Set support | ❌               | ✅                  |
| Applicable on   | All collections | List only          |

---

### 🔹 **398. Stack vs Queue vs Deque**

| Type  | Insertion | Deletion | Methods       |
| ----- | --------- | -------- | ------------- |
| Stack | End       | End      | push/pop      |
| Queue | End       | Front    | add/remove    |
| Deque | Both ends | Both     | addFirst/Last |

---

### 🔹 **399. TreeSet Example (Sorted Set)**

```java
TreeSet<String> set = new TreeSet<>();
set.add("B"); set.add("A");
System.out.println(set); // [A, B]
```

✅ Sorted automatically, no duplicates, no null elements.

---

### 🔹 **400. Convert Between Collections**

```java
// List to Set
List<String> list = Arrays.asList("a", "b");
Set<String> set = new HashSet<>(list);

// Array to List
String[] arr = {"x", "y"};
List<String> list2 = Arrays.asList(arr);
```

---

Here is your **Java Interview & Practice Questions – Set 28**, focused on **Java 8, Java 17 Features & Functional Programming**.

---

## 🚀 **Java Interview & Practice – Set 28: Java 8 & Java 17 Features Mastery**

---

### 🔹 **401. What are the major Java 8 features?**

* Lambda Expressions
* Functional Interfaces
* Stream API
* Default and Static methods in interfaces
* Optional
* Method References
* New Date-Time API
* Collectors
* Nashorn JavaScript Engine

---

### 🔹 **402. Lambda Expression Example**

```java
@FunctionalInterface
interface Greet {
    void sayHello();
}

public class Test {
    public static void main(String[] args) {
        Greet g = () -> System.out.println("Hello!");
        g.sayHello();
    }
}
```

✅ Used to write concise anonymous functions.

---

### 🔹 **403. Stream API Example**

```java
List<String> names = List.of("John", "Jane", "Jack");
names.stream()
     .filter(n -> n.startsWith("J"))
     .map(String::toUpperCase)
     .forEach(System.out::println);
```

✅ Used for functional-style operations on collections.

---

### 🔹 **404. Optional Class in Java 8**

```java
Optional<String> name = Optional.ofNullable(getName());
name.ifPresent(System.out::println);
```

✅ Prevents `NullPointerException`, provides methods like `isPresent()`, `orElse()`, `map()`, `filter()`.

---

### 🔹 **405. Default & Static Methods in Interfaces**

```java
interface A {
    default void show() {
        System.out.println("Default method");
    }

    static void util() {
        System.out.println("Static method");
    }
}
```

✅ Enables interface evolution without breaking code.

---

### 🔹 **406. Method Reference Types**

* **Static method**: `ClassName::staticMethod`
* **Instance method**: `object::instanceMethod`
* **Constructor**: `ClassName::new`

```java
List<String> list = List.of("a", "b");
list.forEach(System.out::println);
```

---

### 🔹 **407. What is a Functional Interface?**

An interface with **only one abstract method**.

```java
@FunctionalInterface
interface MyFunction {
    int operate(int a, int b);
}
```

✅ Enables usage with lambda.

---

### 🔹 **408. Java 17 New Features**

* Sealed Classes
* Pattern Matching for `switch`
* Enhanced `instanceof`
* Record Classes
* JEPs (Java Enhancement Proposals): JEP 409, JEP 406

---

### 🔹 **409. Record Class in Java 17**

```java
public record Person(String name, int age) {}
```

✅ Immutable class with auto-generated constructor, getters, `toString()`, `equals()`, and `hashCode()`.

---

### 🔹 **410. Sealed Classes in Java 17**

```java
public sealed class Animal permits Dog, Cat {}

final class Dog extends Animal {}
final class Cat extends Animal {}
```

✅ Controls which classes can extend a class → better security and maintainability.

---

Here is your **Java Interview & Practice – Set 29**, focused on **Design Patterns (Core Java)** – a must-know topic for interviews and real-world mastery.

---

## 🎯 **Java Interview & Practice – Set 29: Design Patterns (Core Java)**

---

### 🔹 **411. What are Design Patterns?**

Design Patterns are **proven solutions** to common software design problems. They help:

* Improve code **reusability**
* Promote **best practices**
* Increase **maintainability**

---

### 🔹 **412. Categories of Design Patterns**

| Category   | Patterns                                      |
| ---------- | --------------------------------------------- |
| Creational | Singleton, Factory, Abstract Factory, Builder |
| Structural | Adapter, Decorator, Composite, Proxy          |
| Behavioral | Observer, Strategy, Command, Iterator, State  |

---

### 🔹 **413. Singleton Pattern (Creational)**

✅ Ensures only one instance of a class exists.

```java
class Singleton {
    private static Singleton instance = null;
    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}
```

🔍 **Use case**: Logging, Database connection

---

### 🔹 **414. Factory Pattern**

✅ Creates objects without exposing instantiation logic to the client.

```java
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() { System.out.println("Circle"); }
}

class ShapeFactory {
    public static Shape getShape(String type) {
        if (type.equals("circle")) return new Circle();
        return null;
    }
}
```

---

### 🔹 **415. Builder Pattern**

✅ Handles complex object creation step-by-step.

```java
class Car {
    private String engine;
    private int wheels;

    public static class Builder {
        private String engine;
        private int wheels;

        public Builder setEngine(String e) { this.engine = e; return this; }
        public Builder setWheels(int w) { this.wheels = w; return this; }

        public Car build() {
            Car c = new Car();
            c.engine = this.engine;
            c.wheels = this.wheels;
            return c;
        }
    }
}
```

---

### 🔹 **416. Adapter Pattern (Structural)**

✅ Converts one interface to another the client expects.

```java
interface MediaPlayer {
    void play(String filename);
}

class VLC {
    void playVLC(String filename) {
        System.out.println("Playing VLC: " + filename);
    }
}

class VLCAdapter implements MediaPlayer {
    VLC vlc = new VLC();
    public void play(String filename) {
        vlc.playVLC(filename);
    }
}
```

---

### 🔹 **417. Observer Pattern (Behavioral)**

✅ Notifies multiple objects when state changes.

```java
interface Observer {
    void update(String message);
}

class NewsAgency {
    List<Observer> observers = new ArrayList<>();
    void addObserver(Observer o) { observers.add(o); }
    void notifyObservers(String msg) {
        for (Observer o : observers) o.update(msg);
    }
}
```

---

### 🔹 **418. Strategy Pattern**

✅ Selects algorithm behavior at runtime.

```java
interface PaymentStrategy {
    void pay(int amount);
}

class PayPal implements PaymentStrategy {
    public void pay(int amount) { System.out.println("Paid via PayPal"); }
}

class CreditCard implements PaymentStrategy {
    public void pay(int amount) { System.out.println("Paid via Card"); }
}
```

---

### 🔹 **419. Proxy Pattern**

✅ Controls access to another object.

```java
interface Internet {
    void connect(String site);
}

class RealInternet implements Internet {
    public void connect(String site) {
        System.out.println("Connecting to " + site);
    }
}

class ProxyInternet implements Internet {
    private RealInternet real = new RealInternet();
    public void connect(String site) {
        if (site.equals("blocked.com"))
            System.out.println("Access Denied!");
        else
            real.connect(site);
    }
}
```

---

### 🔹 **420. Real-Life Example of All Three**

| Pattern   | Real-life Use Case                     |
| --------- | -------------------------------------- |
| Singleton | Logger, DB Connection Pool             |
| Factory   | `newInstance()` in JDBC                |
| Observer  | UI button listeners, Event-driven apps |

---

Here is your **Java Interview & Practice – Set 30**, focused on **Multithreading – Advanced to Mastery Level**. This is a must for both **product-based** and **service-based** interviews.

---

## 🚀 **Java Interview & Practice – Set 30: Multithreading (Advanced)**

---

### 🔹 **421. What is a Thread in Java?**

A **thread** is a lightweight subprocess. Java supports **multithreading** to run multiple tasks concurrently.

Ways to create a thread:

```java
// 1. Extend Thread class
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread Running...");
    }
}

// 2. Implement Runnable interface
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable Running...");
    }
}
```

---

### 🔹 **422. Thread Lifecycle in Java**

| State         | Description                           |
| ------------- | ------------------------------------- |
| New           | Thread is created but not started     |
| Runnable      | `start()` is called, waiting for CPU  |
| Running       | Thread is currently executing         |
| Blocked       | Waiting for a lock                    |
| Waiting/Timed | Waiting indefinitely or for some time |
| Terminated    | Execution is complete or stopped      |

---

### 🔹 **423. Difference between `start()` and `run()`**

* `start()` → Creates a new thread and then calls `run()`.
* `run()` → Runs on the **current thread**, no new thread is created.

🔍 **Mistake Example:**

```java
MyThread t = new MyThread();
t.run();     // ❌ runs on main thread
t.start();   // ✅ runs on new thread
```

---

### 🔹 **424. `synchronized` Keyword in Threads**

Prevents multiple threads from accessing critical code simultaneously.

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }
}
```

Use it for:

* Methods: `public synchronized void method()`
* Blocks: `synchronized(obj) { }`

---

### 🔹 **425. Deadlock in Java**

Deadlock occurs when two threads hold a lock and wait for each other's lock, causing a circular wait.

```java
Thread-1: Lock A → waiting for Lock B  
Thread-2: Lock B → waiting for Lock A
```

💣 **Solution**: Use lock ordering or `tryLock()` from `ReentrantLock`.

---

### 🔹 **426. What is `volatile` keyword?**

Used to indicate that a variable's value may be modified by different threads.

```java
volatile boolean flag = true;
```

✅ Ensures changes are **visible to all threads**.
❌ Doesn’t guarantee **atomicity**.

---

### 🔹 **427. Difference: `volatile` vs `synchronized`**

| Feature    | `volatile` | `synchronized`            |
| ---------- | ---------- | ------------------------- |
| Visibility | ✅ Yes      | ✅ Yes                     |
| Atomicity  | ❌ No       | ✅ Yes                     |
| Blocking   | ❌ No       | ✅ Yes (may block threads) |

---

### 🔹 **428. Thread-safe Singleton using `synchronized`**

```java
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}
```

Better: **Double-Checked Locking**

```java
public class Singleton {
    private static volatile Singleton instance;
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```

---

### 🔹 **429. What is `Thread.sleep()` and `join()`?**

* `sleep(ms)` – Pauses current thread for specified time.
* `join()` – Waits for another thread to finish.

```java
Thread t = new Thread(() -> {
    System.out.println("Child thread running");
});

t.start();
t.join(); // waits for t to complete
```

---

### 🔹 **430. How to use `ExecutorService` (Thread Pool)?**

```java
ExecutorService pool = Executors.newFixedThreadPool(2);

pool.submit(() -> System.out.println("Task 1"));
pool.submit(() -> System.out.println("Task 2"));
pool.shutdown();
```

✅ Better performance than creating threads manually every time.

---

Here is your **Java Interview & Practice – Set 31**, focused on **Exception Handling and Custom Exceptions** – a commonly tested topic in both coding and theoretical rounds.

---

## ⚠️ **Java Interview & Practice – Set 31: Exception Handling (Pro to Mastery Level)**

---

### 🔹 **431. What is an Exception in Java?**

An **exception** is an event that disrupts the normal flow of a program during runtime.

✅ All exceptions in Java are objects of class `Throwable`.

```java
Throwable
├── Error            → Serious problems, not recoverable (e.g., `OutOfMemoryError`)
└── Exception        → Problems that can be handled (e.g., `IOException`, `NullPointerException`)
    ├── Checked      → Must be handled (e.g., `IOException`)
    └── Unchecked    → Occur at runtime (e.g., `NullPointerException`)
```

---

### 🔹 **432. Checked vs Unchecked Exception**

| Feature      | Checked Exception             | Unchecked Exception                           |
| ------------ | ----------------------------- | --------------------------------------------- |
| Compile Time | Must be handled               | No requirement to handle                      |
| Extends      | `Exception`                   | `RuntimeException`                            |
| Example      | `IOException`, `SQLException` | `NullPointerException`, `ArithmeticException` |

---

### 🔹 **433. Common Exception Handling Syntax**

```java
try {
    // Code that may throw an exception
} catch (ExceptionType name) {
    // Code to handle exception
} finally {
    // Code that always executes (optional)
}
```

Example:

```java
try {
    int a = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Can't divide by zero!");
} finally {
    System.out.println("Cleanup done.");
}
```

---

### 🔹 **434. What is `finally` block? When is it executed?**

✅ Always runs whether an exception is thrown or not.

✅ Useful for resource cleanup like closing files, DB, etc.

---

### 🔹 **435. Can we have try without catch?**

Yes, **try-finally** is allowed:

```java
try {
   // risky code
} finally {
   // always runs
}
```

---

### 🔹 **436. Custom Exception Example**

Creating your own checked/unchecked exception class:

```java
class MyException extends Exception {
    public MyException(String msg) {
        super(msg);
    }
}

public class Test {
    public static void main(String[] args) throws MyException {
        throw new MyException("Custom checked exception");
    }
}
```

---

### 🔹 **437. What is `throw` and `throws`?**

* `throw` – Used to **explicitly throw** an exception.
* `throws` – Declares exceptions in method signature.

```java
void check(int age) throws MyException {
    if (age < 18) throw new MyException("Too young");
}
```

---

### 🔹 **438. Difference: `throw` vs `throws`**

| Feature | `throw`                       | `throws`                         |
| ------- | ----------------------------- | -------------------------------- |
| Purpose | Actually throws the exception | Declares a method may throw it   |
| Used in | Method body                   | Method signature                 |
| Follows | `throw new Exception();`      | `void method() throws Exception` |

---

### 🔹 **439. What happens if exception is not caught?**

❌ If unchecked → program terminates.
❌ If checked → compiler error (must be caught or declared).

---

### 🔹 **440. Can we catch multiple exceptions?**

Yes, using **multi-catch**:

```java
try {
    // risky code
} catch (IOException | SQLException e) {
    e.printStackTrace();
}
```

Or one-by-one:

```java
try {
   // risky code
} catch (IOException e) {
   // handle IO
} catch (Exception e) {
   // generic handler
}
```

---

Here is your **Java Interview & Practice – Set 32**, focused on **Java Collections Framework (JCF)** – a *must-know topic* for both interviews and real-world Java development.

---

## 📚 **Java Interview & Practice – Set 32: Collections Framework (List, Set, Map, Queue, Stack)**

---

### 🔸 **441. What is Java Collections Framework (JCF)?**

* A **unified architecture** to store, access, and manipulate groups of objects.
* Includes interfaces (List, Set, Map, Queue) and classes (ArrayList, HashSet, HashMap, etc.).

✅ All collection classes are in the `java.util` package.

---

### 🔸 **442. Key Interfaces in Collections**

| Interface | Description                         | Implementations                       |
| --------- | ----------------------------------- | ------------------------------------- |
| `List`    | Ordered, indexed, allows duplicates | `ArrayList`, `LinkedList`, `Vector`   |
| `Set`     | No duplicates                       | `HashSet`, `LinkedHashSet`, `TreeSet` |
| `Queue`   | Follows FIFO                        | `PriorityQueue`, `Deque`              |
| `Map`     | Key-value pairs, no duplicate keys  | `HashMap`, `TreeMap`, `LinkedHashMap` |

---

### 🔸 **443. Difference: List vs Set vs Map**

| Feature    | List        | Set            | Map                 |
| ---------- | ----------- | -------------- | ------------------- |
| Order      | Maintained  | Not guaranteed | Maintains keys      |
| Duplicates | Allowed     | Not allowed    | Key: no, Value: yes |
| Access     | Index-based | Iterator-based | Key-based           |

---

### 🔸 **444. ArrayList vs LinkedList**

| Feature       | `ArrayList`            | `LinkedList`              |
| ------------- | ---------------------- | ------------------------- |
| Access speed  | Fast (indexing)        | Slow                      |
| Insert/delete | Slow (shifting needed) | Fast (node rearrangement) |
| Backed by     | Array                  | Doubly linked list        |

```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list.get(1)); // Python
```

---

### 🔸 **445. HashSet vs TreeSet**

| Feature     | `HashSet`     | `TreeSet`               |
| ----------- | ------------- | ----------------------- |
| Order       | Unordered     | Sorted (natural order)  |
| Null        | Allows 1 null | No null                 |
| Performance | Fast          | Slower (due to sorting) |

```java
Set<Integer> set = new TreeSet<>();
set.add(30); set.add(10); set.add(20);
System.out.println(set); // [10, 20, 30]
```

---

### 🔸 **446. HashMap vs TreeMap vs LinkedHashMap**

| Feature          | `HashMap`  | `TreeMap`           | `LinkedHashMap` |
| ---------------- | ---------- | ------------------- | --------------- |
| Order            | No order   | Sorted by keys      | Insertion order |
| Null keys/values | 1 null key | No null key allowed | 1 null key      |
| Performance      | Fast       | Slower (sorted)     | Moderate        |

```java
Map<String, Integer> map = new HashMap<>();
map.put("Java", 1);
map.put("Python", 2);
System.out.println(map.get("Java")); // 1
```

---

### 🔸 **447. Stack vs Queue**

| Feature | Stack (LIFO)      | Queue (FIFO)            |
| ------- | ----------------- | ----------------------- |
| Method  | `push()`, `pop()` | `add()`, `remove()`     |
| Usage   | Undo, Recursion   | Scheduling, Print queue |

```java
Stack<Integer> stack = new Stack<>();
stack.push(10); stack.push(20);
System.out.println(stack.pop()); // 20
```

---

### 🔸 **448. Iterate over List, Set, Map**

```java
// List
for (String item : list) System.out.println(item);

// Set
for (Integer val : set) System.out.println(val);

// Map
for (Map.Entry<String, Integer> entry : map.entrySet())
    System.out.println(entry.getKey() + " = " + entry.getValue());
```

---

### 🔸 **449. What is `Collections` vs `Collection`?**

* `Collection` → Root interface (List, Set, Queue).
* `Collections` → Utility class (`Collections.sort()`, `Collections.shuffle()`).

---

### 🔸 **450. Make List Immutable**

```java
List<String> list = List.of("A", "B", "C"); // Java 9+
list.add("D"); // ❌ Throws UnsupportedOperationException
```

---

### 🔸 **451. Convert Array to List and vice versa**

```java
// Array to List
String[] arr = {"A", "B"};
List<String> list = Arrays.asList(arr);

// List to Array
String[] array = list.toArray(new String[0]);
```

---

Here is your **Java Interview & Practice – Set 33**, focused on **Java 8 Features** – a crucial topic for **modern Java interviews**.

---

## 📚 **Java Interview & Practice – Set 33: Java 8 Features (Lambda, Stream, Functional Interface)**

---

### 🔸 **452. What are major features of Java 8?**

✅ Important Java 8 features:

* **Lambda Expressions**
* **Functional Interfaces**
* **Stream API**
* **Default & Static Methods in Interfaces**
* **Optional Class**
* **Method References**
* **Date & Time API (java.time)**
* **Collectors, Predicate, Consumer, etc.**

---

### 🔸 **453. What is a Lambda Expression?**

Lambda = **Anonymous function**

```java
(parameter) -> expression
```

### 🔹 Example:

```java
interface Sayable {
    void say(String msg);
}

Sayable s = (msg) -> System.out.println("You said: " + msg);
s.say("Java 8 is powerful");
```

---

### 🔸 **454. What is a Functional Interface?**

A **Functional Interface** has **only one abstract method**. Used with lambda.

✅ Uses `@FunctionalInterface` annotation (optional but good practice).

```java
@FunctionalInterface
interface Calculator {
    int operate(int a, int b);
}
```

---

### 🔸 **455. Stream API – What is it?**

* **Stream** = Sequence of elements supporting **pipeline operations**.
* Introduced to simplify **collection processing** (filtering, mapping, etc.).

### 🔹 Example:

```java
List<String> names = Arrays.asList("Java", "Python", "C++", "JavaScript");

names.stream()
     .filter(name -> name.startsWith("J"))
     .map(String::toUpperCase)
     .forEach(System.out::println);
// Output: JAVA, JAVASCRIPT
```

---

### 🔸 **456. Intermediate vs Terminal Stream Operations**

| Type         | Examples                            |
| ------------ | ----------------------------------- |
| Intermediate | `filter()`, `map()`, `sorted()`     |
| Terminal     | `forEach()`, `collect()`, `count()` |

---

### 🔸 **457. What is Optional in Java 8?**

Used to **avoid null checks** and prevent `NullPointerException`.

```java
Optional<String> opt = Optional.of("Java");
opt.ifPresent(System.out::println); // Java

String value = opt.orElse("Default");
```

---

### 🔸 **458. Default and Static Methods in Interface**

```java
interface Vehicle {
    default void start() {
        System.out.println("Starting...");
    }

    static void fuel() {
        System.out.println("Petrol");
    }
}
```

* `default` → Implement in interfaces
* `static` → Belongs to interface, not implementation class

---

### 🔸 **459. Method References (Shortcut of Lambda)**

```java
// Lambda
names.forEach(name -> System.out.println(name));

// Method Reference
names.forEach(System.out::println);
```

✅ Syntax: `ClassName::methodName` or `object::method`

---

### 🔸 **460. Predicate, Consumer, Supplier, Function**

| Interface | Input | Output  | Use For             |
| --------- | ----- | ------- | ------------------- |
| Predicate | T     | boolean | Filter conditions   |
| Consumer  | T     | void    | Consume object      |
| Supplier  | -     | T       | Supply values       |
| Function  | T     | R       | Map input to output |

```java
Predicate<String> isShort = str -> str.length() < 5;
System.out.println(isShort.test("Java")); // true
```

---

### 🔸 **461. Collectors in Stream API**

Used for **terminal operations** like grouping, joining, counting.

```java
List<String> list = Arrays.asList("A", "B", "C");

String joined = list.stream().collect(Collectors.joining(","));
System.out.println(joined); // A,B,C
```

---

### 🔸 **462. FlatMap vs Map**

| `map()`    | `flatMap()`                     |
| ---------- | ------------------------------- |
| One-to-one | One-to-many (flattens the data) |

```java
List<List<String>> data = Arrays.asList(
    Arrays.asList("a", "b"),
    Arrays.asList("c", "d")
);

List<String> flat = data.stream()
    .flatMap(Collection::stream)
    .collect(Collectors.toList());

System.out.println(flat); // [a, b, c, d]
```

---

### 🔸 **463. Filter null or empty elements with Stream**

```java
list.stream()
    .filter(Objects::nonNull)
    .filter(s -> !s.isEmpty())
    .collect(Collectors.toList());
```

---

### 🔸 **464. How to sort a list using lambda**

```java
List<String> names = Arrays.asList("Z", "A", "M");

names.sort((a, b) -> a.compareTo(b));
System.out.println(names); // [A, M, Z]
```

---

Here is your **Java Interview & Practice – Set 34**, focused on **Multithreading & Concurrency** – a highly asked topic in senior-level interviews.

---

## 📚 **Java Interview & Practice – Set 34: Multithreading & Concurrency**

---

### 🔸 **465. What is a thread in Java?**

A **thread** is a lightweight sub-process. Java supports **multithreading**, allowing concurrent execution.

* Main thread runs by default.
* You can create your own threads to run tasks in parallel.

---

### 🔸 **466. Ways to create a thread in Java**

1. **Extend `Thread` class**
2. **Implement `Runnable` interface**

#### Example 1: Extending Thread

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Running in thread: " + Thread.currentThread().getName());
    }
}

new MyThread().start();
```

#### Example 2: Using Runnable

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable thread running");
    }
}

Thread t = new Thread(new MyRunnable());
t.start();
```

---

### 🔸 **467. What is the Thread Lifecycle?**

| State           | Description                 |
| --------------- | --------------------------- |
| New             | Thread object created       |
| Runnable        | Thread ready to run         |
| Running         | Thread executing            |
| Blocked/Waiting | Thread waiting for resource |
| Terminated      | Thread finished             |

---

### 🔸 **468. What is the difference between `start()` and `run()`?**

* `start()` → Creates a **new thread** and calls `run()`
* `run()` → Just a **method call** in current thread

---

### 🔸 **469. What is the use of `join()` in Java threads?**

It makes one thread **wait** until another completes.

```java
Thread t1 = new Thread(() -> {
    System.out.println("Thread A");
});
t1.start();
t1.join(); // Main waits for t1 to finish
```

---

### 🔸 **470. What is synchronization in Java?**

It prevents **race conditions** by allowing only one thread to access a **critical section**.

```java
synchronized void increment() {
    count++;
}
```

---

### 🔸 **471. Synchronized block vs method**

* **Synchronized method** → Locks entire method.
* **Synchronized block** → Locks only the required part of code.

```java
synchronized(this) {
   // Critical section
}
```

---

### 🔸 **472. What is volatile keyword in Java?**

* Used to ensure that changes made by one thread are **visible** to others.
* Prevents **caching** of variables.

```java
volatile boolean flag = true;
```

---

### 🔸 **473. Difference between `volatile` and `synchronized`**

| Feature    | `volatile`    | `synchronized`       |
| ---------- | ------------- | -------------------- |
| Scope      | Variable only | Code block or method |
| Visibility | Yes           | Yes                  |
| Atomicity  | No            | Yes                  |
| Locking    | No            | Yes                  |

---

### 🔸 **474. What is a deadlock?**

Deadlock occurs when **two or more threads** are blocked forever, each waiting for the other’s lock.

### 🔹 Example:

```java
Thread 1 locks A then waits for B  
Thread 2 locks B then waits for A
```

To prevent:

* Always lock objects in the same order
* Use `tryLock()` in `ReentrantLock`

---

### 🔸 **475. Difference between `wait()`, `notify()`, and `notifyAll()`**

| Method        | Description                                |
| ------------- | ------------------------------------------ |
| `wait()`      | Causes thread to wait and release the lock |
| `notify()`    | Wakes up one waiting thread                |
| `notifyAll()` | Wakes up all waiting threads               |

Used with `synchronized` blocks.

---

### 🔸 **476. What is `Thread.sleep()`?**

* Pauses execution of current thread for specific time.
* Doesn’t release lock.

```java
Thread.sleep(1000); // sleep for 1 sec
```

---

### 🔸 **477. What is a daemon thread?**

* **Background thread** that dies when all user threads die.
* Used for background tasks (e.g., GC).

```java
t.setDaemon(true);
```

---

### 🔸 **478. Difference between process and thread**

| Feature       | Process           | Thread             |
| ------------- | ----------------- | ------------------ |
| Memory        | Separate memory   | Shared memory      |
| Communication | Slow (IPC needed) | Fast (shared vars) |
| Creation      | Heavyweight       | Lightweight        |

---

### 🔸 **479. What is ExecutorService in Java?**

Used to manage thread pools, submit tasks, and control concurrency.

```java
ExecutorService ex = Executors.newFixedThreadPool(3);
ex.execute(() -> System.out.println("Running task"));
ex.shutdown();
```

---

### 🔸 **480. Callable vs Runnable**

| Feature   | Runnable             | Callable          |
| --------- | -------------------- | ----------------- |
| Return    | void                 | Returns a value   |
| Exception | Cannot throw checked | Can throw checked |

---

Here is your **Java Interview & Practice – Set 35**, focused on **Spring Boot + REST APIs** – one of the most common frameworks used in enterprise applications and interviews.

---

## 📚 **Java Interview & Practice – Set 35: Spring Boot + REST API**

---

### 🔸 **481. What is Spring Boot?**

Spring Boot is a Java framework used to **build stand-alone, production-grade Spring-based applications** with minimal configuration.

#### 🔹 Key Features:

* Auto-configuration
* Embedded servers (Tomcat, Jetty)
* Production-ready (Actuator)
* No XML configuration

---

### 🔸 **482. Difference between Spring and Spring Boot**

| Feature     | Spring Framework        | Spring Boot              |
| ----------- | ----------------------- | ------------------------ |
| Setup       | Manual, XML/Java config | Auto-configured          |
| Server      | External                | Embedded (Tomcat/Jetty)  |
| Boilerplate | More                    | Less                     |
| Build Tool  | Not enforced            | Uses Maven/Gradle easily |

---

### 🔸 **483. How do you create a Spring Boot application?**

**3 main steps:**

1. Add Spring Boot dependencies (via [Spring Initializr](https://start.spring.io))
2. Create main class with `@SpringBootApplication`
3. Run the application

```java
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
```

---

### 🔸 **484. What does `@SpringBootApplication` do?**

It combines:

* `@Configuration` → For beans
* `@EnableAutoConfiguration` → Enables Spring Boot auto config
* `@ComponentScan` → Scans components

---

### 🔸 **485. How to create a REST API in Spring Boot?**

Use `@RestController` and `@RequestMapping`:

```java
@RestController
public class HelloController {
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello, World!";
    }
}
```

---

### 🔸 **486. HTTP Method Annotations in Spring Boot**

| Annotation       | HTTP Method |
| ---------------- | ----------- |
| `@GetMapping`    | GET         |
| `@PostMapping`   | POST        |
| `@PutMapping`    | PUT         |
| `@DeleteMapping` | DELETE      |
| `@PatchMapping`  | PATCH       |

---

### 🔸 **487. How to pass data in REST APIs**

* **PathVariable**: `/users/{id}`
* **RequestParam**: `/search?name=John`
* **RequestBody**: Send JSON in POST/PUT

```java
@GetMapping("/users/{id}")
public String getUser(@PathVariable int id)

@PostMapping("/users")
public String save(@RequestBody User u)
```

---

### 🔸 **488. What is `@RestController` vs `@Controller`?**

* `@Controller` → Used for HTML views (Thymeleaf/JSP)
* `@RestController` → Combines `@Controller` + `@ResponseBody` to return JSON

---

### 🔸 **489. What is Spring Boot Starter?**

Starters are dependency bundles.
Examples:

* `spring-boot-starter-web`
* `spring-boot-starter-data-jpa`
* `spring-boot-starter-security`

---

### 🔸 **490. What is application.properties/yml?**

Used for configuring:

* Server port
* DB config
* Logging

```properties
server.port=8081
spring.datasource.url=jdbc:mysql://localhost/test
```

---

### 🔸 **491. What is Spring Boot Actuator?**

Actuator provides production-ready endpoints:

* `/actuator/health`
* `/actuator/metrics`
* `/actuator/info`

Used for monitoring.

---

### 🔸 **492. How to connect to a database in Spring Boot?**

1. Add JDBC / JPA dependency
2. Configure DB in `application.properties`
3. Use `@Entity`, `@Repository`, and `@Service`

---

### 🔸 **493. Example Entity and Repository**

```java
@Entity
public class User {
   @Id
   private int id;
   private String name;
}

@Repository
public interface UserRepo extends JpaRepository<User, Integer> {}
```

---

### 🔸 **494. What is JPA and Hibernate?**

* **JPA** (Java Persistence API): Java standard to access relational data.
* **Hibernate**: Popular JPA implementation.

---

### 🔸 **495. Difference between `@Autowired`, `@Component`, `@Service`, and `@Repository`**

| Annotation    | Use                       |
| ------------- | ------------------------- |
| `@Autowired`  | Inject dependencies       |
| `@Component`  | Generic Spring bean       |
| `@Service`    | Service layer bean        |
| `@Repository` | DAO layer + DB exceptions |

---

### 🔸 **496. How to handle exceptions in Spring Boot?**

Use `@ControllerAdvice` and `@ExceptionHandler`.

```java
@ControllerAdvice
public class GlobalException {
   @ExceptionHandler(Exception.class)
   public ResponseEntity<String> handle(Exception ex) {
      return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
   }
}
```

---

### 🔸 **497. What is ResponseEntity?**

Used to build custom response:

```java
return ResponseEntity.status(HttpStatus.CREATED).body("Created");
```

---

### 🔸 **498. Difference between `@RequestBody` and `@ResponseBody`**

* `@RequestBody`: JSON → Java Object
* `@ResponseBody`: Java Object → JSON

---

### 🔸 **499. How do you test Spring Boot REST APIs?**

* Use tools: Postman, curl
* Write tests using: `MockMvc`, `WebTestClient`, or SpringBootTest

---

### 🔸 **500. How to deploy a Spring Boot application?**

* Create JAR using:

```bash
mvn clean install
```

* Run:

```bash
java -jar target/app.jar
```

* Deploy to server (AWS, Heroku, Docker, etc.)

---
